var content=$.views.documentation.content;content.find.samples=content.useStorage&&$.parseJSON(localStorage.getItem("JsViewsDocTopics/find/samples"))||{samples:{sections:[{_type:"para",title:"",text:"Note: New content is being added regularly to this set of samples.\n"},{_type:"links",title:"",text:""},{_type:"para",title:"",text:"See also:\n\nthe demos folder of the JsRender GitHub repository – available here as live samples\nthe demos folder of the JsViews GitHub repository – or here as live samples\n\n"}]},"samples/jsr":{sections:[{_type:"para",title:"",text:"Note: New content is being added regularly to this set of samples.\n"},{_type:"links",title:"",text:""},{_type:"para",title:"",text:"See also the additional samples in the demos folder of the JsRender GitHub repository (available here as live samples).\n"}]},"samples/jsr/composition":{sections:[{_type:"links",title:"",text:""}]},"samples/jsr/composition/tmpl":{sections:[{_type:"sample",title:"",url:"samples/jsrender/composition/tmpl/sample",text:'Composition by providing tmpl parameters referencing external templates, rather than inline block content, as in:\n{{for languages tmpl="#columnTemplate"/}}\n\nor:\n{{if name.charAt(0)===\'E\' tmpl=\'#rowTemplate\'}}\n{{else tmpl=\'#columnTemplate\'}}\n{{/if}}\n\nAlso shows wrapping, where an external template is used which then wraps the rendered block content, as in:\n{{include tmpl="#sectionWrapperTemplate"}}\n  {{>title}}\n{{/include}}\n\n<script id="sectionWrapperTemplate" type="text/x-jsrender">\n  <td>Section: <em>{{include tmpl=#content/}}</em></td>\n</script>\n\nor as in:\n{{for languages tmpl=\'#indexWrapperTemplate\'}}\n  <b>{{>name}}</b>\n{{/for}}\n\n<script id="indexWrapperTemplate" type="text/x-jsrender">\n  <div>\n    {{:#index}}:\n    {{include tmpl=#content/}}\n  </div>\n</script>\n\nNote that tmpl=#content above is not a jQuery selector, but rather uses view.content. See Wrapping content.\n\n"use strict";\nvar movies = [\n  {\n    title: "Meet Joe Black",\n    languages: [\n      {name: "English"},\n      {name: "French"}\n    ],\n    tmpl: "#columnTemplate"\n  },\n  {\n    title: "Eyes Wide Shut",\n    languages: [\n      {name: "French"},\n      {name: "Esperanto"},\n      {name: "Spanish"}\n    ],\n    tmpl: "#rowTemplate"\n  },\n  {\n    title: "The Inheritance",\n    languages: [\n      {name: "English"},\n      {name: "German"}\n    ],\n    tmpl: "#columnTemplate"\n  }\n];\n\n$("#movieList").html(\n  $("#movieTemplate").render(movies)\n);\n\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <tr>\r\n    {{include tmpl="#headerTemplate"/}}\r\n    <td>\r\n      {{for languages tmpl="#columnTemplate"/}}\r\n    </td>\r\n    <td>\r\n      {{for languages tmpl=tmpl/}}\r\n    </td>\r\n    <td>\r\n      {{for languages tmpl=\'#conditionalTemplate\'/}}\r\n    </td>\r\n    {{include tmpl="#sectionWrapperTemplate"}}\r\n      {{>title}}\r\n    {{/include}}\r\n    <td>\r\n      {{for languages tmpl=\'#indexWrapperTemplate\'}}\r\n        <b>{{>name}}</b>\r\n      {{/for}}\r\n    </td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="headerTemplate" type="text/x-jsrender">\r\n  <td>{{>title}}</td>\r\n</script>\r\n\r\n<script id="sectionWrapperTemplate" type="text/x-jsrender">\r\n  <td>Section: <em>{{include tmpl=#content/}}</em></td>\r\n</script>\r\n\r\n<script id="columnTemplate" type="text/x-jsrender">\r\n  <div>\r\n    <em>{{>name}}</em>\r\n  </div>\r\n</script>\r\n\r\n<script id="rowTemplate" type="text/x-jsrender">\r\n  <span>\r\n    <b>{{>name}}</b>\r\n  </span>\r\n</script>\r\n\r\n<script id="conditionalTemplate" type="text/x-jsrender">\r\n  {{if name.charAt(0)===\'E\' tmpl=\'#rowTemplate\'}}\r\n  {{else tmpl=\'#columnTemplate\'}}\r\n  {{/if}}\r\n</script>\r\n\r\n<script id="indexWrapperTemplate" type="text/x-jsrender">\r\n  <div>\r\n    {{:#index}}:\r\n    {{include tmpl=#content/}}\r\n  </div>\r\n</script>\r\n\r\n<table>\r\n<thead>\r\n  <tr><th>Synopsis</th><th>Fixed Template</th>\r\n  <th>Template specified in data</th><th>Conditional Template</th>\r\n  <th>Wrapper Template</th><th>Repeating Wrapper Template</th></tr>\r\n</thead>\r\n<tbody id="movieList"></tbody>\r\n</table>\n'},{_type:"para",title:"",text:"See also the following samples which are variants of this sample:\n"},{_type:"links",title:"",text:""}]},"samples/jsr/composition/from-strings":{sections:[{_type:"para",title:"",text:"All of the templates referenced by tmpl=… in the preceding tmpl parameter sample were declared as script blocks. But they could equally have been compiled from markup strings.\nHere is a simple example:\n"},{_type:"sample",url:"samples/jsrender/composition/from-strings/sample",text:'Simple example of composition\nWe register two named templates, compiled from markup strings:\n$.templates({\n  people: \'<div>{{:name}} lives in {{for address tmpl="address" /}}</div>\',\n  address: \'<b>{{>city}}</b>\'\n});\n\nThe first one uses the second as a nested template:\n{{for address tmpl="address" /}}\n\n\n"use strict";\n$.templates({\n  people: \'<div>{{:name}} lives in {{for address tmpl="address" /}}</div>\',\n  address: \'<b>{{>city}}</b>\'\n});\n\nfunction showPeople(people) {\n  var html = $.templates.people.render(people);\n  $("#peopleList").html(html);\n}\n\nvar people1 = [\n    {\n      "name": "Pete", "address": { "city": "Seattle" }\n    },\n    {\n      "name": "Heidi", "address": { "city": "Sidney" }\n    }\n  ],\n\n  people2 = [\n    {\n      "name": "Adriana", "address": { "city": "Dubai" }\n    },\n    {\n      "name": "Robert", "address": { "city": "London" }\n    }\n  ];\n\n$("#show1").on("click", function() {\n  showPeople(people1);\n});\n\n$("#show2").on("click", function() {\n  showPeople(people2);\n});\n\n<button id="show1">Show People1</button>\r\n<button id="show2">Show People2</button>\r\n\r\n<div id="peopleList"></div>\n'},{_type:"para",title:"",text:"In the next remote templates sample we will show a modified version of this sample but with the strings fetched “lazily” from the server.\n"}]},"samples/jsr/composition/remote-tmpl":{sections:[{_type:"para",title:"",text:"This sample takes the preceding Template composition/from strings sample, and modifies it to use templates loaded from the server.\n(See also the simple examples of loading templates from the server, in the Compile templates API topic.)\n"},{_type:"sample",url:"samples/jsrender/composition/remote-tmpl/sample",text:'Asynchronous loading of templates from the server\nThis sample illustrates one approach to loading remote templates: the template file on the server is a javascript file which registers a named template.\n\nTemplate resource on the server: address.js \n\n$.templates("address", "{{>city}}");\n\nlazyGetTemplate() helper function\nWe use a helper to “lazily” fetch the template, asynchronously, but only if it has not yet been fetched. Also, we make sure the template only gets compiled from a string once.\n(Note that for optimal performance, it is always best to ensure that the $.template(... markup) method, which compiles a template from a string, is only ever called once for a given string).\nfunction lazyGetTemplate(name) {\n  var deferred = $.Deferred();\n  if ($.templates[name]) {\n    deferred.resolve();\n  } else {\n    $.getScript(...).then(function() {\n      ...  \n      deferred.resolve();\n    });\n  }\n  return deferred.promise();\n}\n\n\nWhen all templates are loaded...\nOnce the requested template (along with any nested templates used in the template composition) is loaded, the render() method can be called (or the link() method if you are using JsViews):\n$.when(\n    lazyGetTemplate("people"),\n    ...  \n  )\n  .done(function() {\n    // Render or link once all templates for template composition are loaded\n    var html = $.templates.people.render(people);\n    ...\n  });\n\n\n"use strict";\nfunction lazyGetTemplate(name) {\n  // If the named remote template is not yet loaded and compiled\n  // as a named template, fetch it. In either case, return a promise\n  // (already resolved, if the template has already been loaded)\n  var deferred = $.Deferred();\n  if ($.templates[name]) {\n    deferred.resolve();\n  } else {\n    $.getScript(\n      "//www.jsviews.com/samples/resources/templates/"\n              + name + ".js")\n      .then(function() {\n        if ($.templates[name]) {\n          deferred.resolve();\n        } else {\n          alert("Script: \\"" + name + ".js\\" failed to load");\n          deferred.reject();\n        }\n      });\n  }\n  return deferred.promise();\n}\n\nfunction showPeople(people) {\n  $.when(\n\n    lazyGetTemplate("people"),\n// \'<div>{{:name}} lives in {{for address tmpl="address" /}}</div>\'\n// fetched from www.jsviews.com/samples/resources/templates/people.js\n\n    lazyGetTemplate("address")\n// Template: \'<b>{{>city}}</b>\'\n// fetched from www.jsviews.com/samples/resources/templates/address.js\n\n  )\n    .done(function() {\n      // Render once all templates for template composition are loaded\n      var html = $.templates.people.render(people);\n      $("#peopleList").html(html);\n    });\n}\n\nvar people1 = [\n    {\n      "name": "Pete", "address": { "city": "Seattle" }\n    },\n    {\n      "name": "Heidi", "address": { "city": "Sidney" }\n    }\n  ],\n\n  people2 = [\n    {\n      "name": "Adriana", "address": { "city": "Dubai" }\n    },\n    {\n      "name": "Robert", "address": { "city": "London" }\n    }\n  ];\n\n$("#show1").on("click", function() {\n  showPeople(people1);\n});\n\n$("#show2").on("click", function() {\n  showPeople(people2);\n});\n\n$.templates("people", \'<div>{{:name}} lives in {{for address tmpl="address" /}}</div>\');\n$.templates("address", "<b>{{>city}}</b>");\n<button id="show1">Show People1</button>\r\n<button id="show2">Show People2</button>\r\n\r\n<div id="peopleList"></div>\n'}]},"samples/jsr/composition/sub-tmpl":{sections:[{_type:"para",title:"",text:"This sample takes the previous tmpl parameter sample and modifies it to declare nested templates as sub-templates of the calling template.\n"},{_type:"sample",url:"samples/jsrender/composition/sub-tmpl/sample",text:'Using sub-templates\n$.templates("movieTemplate", {\n  markup: "#movieTemplate",\n  templates: {\n    columnTemplate: "#columnTemplate",\n    ...\n  }\n});\n\nNow “columnTemplate” is a named template available only to the “movieTemplate”. (See $.templates().)\n<script id="movieTemplate" type="text/x-jsrender">\n  ...\n  {{for languages tmpl="columnTemplate"/}}\n  ...\n</script>\n\n\n"use strict";\nvar movies = [\n  {\n    title: "Meet Joe Black",\n    languages: [\n      {name: "English"},\n      {name: "French"}\n    ],\n    tmpl: "columnTemplate"\n  },\n  {\n    title: "Eyes Wide Shut",\n    languages: [\n      {name: "French"},\n      {name: "Esperanto"},\n      {name: "Spanish"}\n    ],\n    tmpl: "rowTemplate"\n  },\n  {\n    title: "The Inheritance",\n    languages: [\n      {name: "English"},\n      {name: "German"}\n    ],\n    tmpl: "columnTemplate"\n  }\n];\n\n$.templates("movieTemplate", {\n  markup: "#movieTemplate",\n  templates: {\n    columnTemplate: "#columnTemplate",\n    rowTemplate: "#rowTemplate",\n    conditionalTemplate: "#conditionalTemplate"\n  }\n});\n\n$("#movieList").html(\n  $.render.movieTemplate(movies)\n);\n\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <tr>\r\n    <td>{{>title}}</td>\r\n    <td>\r\n      {{for languages tmpl="columnTemplate"/}}\r\n    </td>\r\n    <td>\r\n      {{for languages tmpl=tmpl/}}\r\n    </td>\r\n    <td>\r\n      {{for languages tmpl="conditionalTemplate"/}}\r\n    </td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="columnTemplate" type="text/x-jsrender">\r\n  <div>\r\n    <em>{{>name}}</em>\r\n  </div>\r\n</script>\r\n\r\n<script id="rowTemplate" type="text/x-jsrender">\r\n  <span>\r\n    <b>{{>name}}</b>\r\n  </span>\r\n</script>\r\n\r\n<script id="conditionalTemplate" type="text/x-jsrender">\r\n  {{if name.charAt(0)===\'E\' tmpl=\'rowTemplate\'}}\r\n  {{else tmpl=\'columnTemplate\'}}\r\n  {{/if}}\r\n</script>\r\n\r\n<table>\r\n  <thead><tr><th>Synopsis</th><th>Fixed Template</th>\r\n  <th>Template specified in data</th><th>Conditional Template</th>\r\n  </tr></thead>\r\n  <tbody id="movieList"></tbody>\r\n</table>\n'}]},"samples/jsr/composition/tmpl-objects":{sections:[{_type:"para",title:"",text:"This sample takes the previous tmpl parameter sample and provides  nested templates to the calling template, by passing them in as compiled template objects, associated with a helper object.\n"},{_type:"sample",url:"samples/jsrender/composition/tmpl-objects/sample",text:'nestedTemplates is an object which holds references to compiled template objects for each of the nested templates. We pass it in as a helper object in the render() call.\n(Note we could also have provided the templates via helper objects registered globally with $.views.helpers(...)).\nvar nestedTemplates = {\n  columnTemplate: $.templates("#columnTemplate"),\n  ...\n};\n\nvar html = movieTemplate.render(movies, sub-templates);\n\nNow each of the compiled templates, such as nestedTemplates.columnTemplate can be accessed from the outer template, and used for composition. Templates are accessed as regular helper objects such as ~columnTemplate.\n<script id="movieTemplate" type="text/x-jsrender">\n  ...\n  {{for languages tmpl=~columnTemplate/}}\n  ...\n</script>\n\n\n"use strict";\nvar movies = [\n  {\n    title: "Meet Joe Black",\n    languages: [\n      {name: "English"},\n      {name: "French"}\n    ],\n    tmpl: "#columnTemplate"\n  },\n  {\n    title: "Eyes Wide Shut",\n    languages: [\n      {name: "French"},\n      {name: "Esperanto"},\n      {name: "Spanish"}\n    ],\n    tmpl: "#rowTemplate"\n  },\n  {\n    title: "The Inheritance",\n    languages: [\n      {name: "English"},\n      {name: "German"}\n    ],\n    tmpl: "#columnTemplate"\n  }\n];\n\nvar movieTemplate = $.templates("#movieTemplate");\n\nvar nestedTemplates = {\n  columnTemplate: $.templates("#columnTemplate"),\n  rowTemplate: $.templates("#rowTemplate"),\n  conditionalTemplate: $.templates("#conditionalTemplate")\n};\n\nvar html = movieTemplate.render(movies, nestedTemplates);\n\n$("#movieList").html(html);\n\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <tr>\r\n    <td>{{>title}}</td>\r\n    <td>\r\n      {{for languages tmpl=~columnTemplate/}}\r\n    </td>\r\n    <td>\r\n      {{for languages tmpl=tmpl/}}\r\n    </td>\r\n    <td>\r\n      {{for languages tmpl=~conditionalTemplate/}}\r\n    </td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="columnTemplate" type="text/x-jsrender">\r\n  <div>\r\n    <em>{{>name}}</em>\r\n  </div>\r\n</script>\r\n\r\n<script id="rowTemplate" type="text/x-jsrender">\r\n  <span>\r\n    <b>{{>name}}</b>\r\n  </span>\r\n</script>\r\n\r\n<script id="conditionalTemplate" type="text/x-jsrender">\r\n  {{if name.charAt(0)===\'E\' tmpl=~rowTemplate}}\r\n  {{else tmpl=~columnTemplate}}\r\n  {{/if}}\r\n</script>\r\n\r\n<table>\r\n  <thead><tr><th>Synopsis</th><th>Fixed Template</th>\r\n  <th>Template specified in data</th><th>Conditional Template</th>\r\n  </tr></thead>\r\n  <tbody id="movieList"></tbody>\r\n</table>\n'}]},"samples/jsr/tags":{sections:[{_type:"para",title:"Custom tags for JsRender",text:"Custom tags for JsRender\nThe following examples are custom tags that can be used in JsRender or in JsViews:\n"},{_type:"links",title:"",text:""},{_type:"para",title:"Custom tags for JsViews",text:"Custom tags for JsViews\nSee also the examples of JsViews custom tags (tag controls) which include data-linking and interactivity – and are in fact fully-fledged “widgets” or controls, such as the date-picker control, or the tabs control:\n"},{_type:"links",title:"",text:""}]},"samples/jsr/tags/wrap-content":{sections:[{_type:"sample",url:"samples/jsrender/tags/wrap-content/sample",text:'Composition with custom tags\nThis sample shows some basic custom tags implemented as simple render functions, or templates, and in each case shows how the tag can incorporate block content…\n{{mytag}}\n  {{>title}}\n{{/mytag}}\n\n…into its rendering.\nA variant, is to incorporate external content (through a tag parameter such as tmpl, referencing an external template) into the rendered output…\n{{mytag tmpl="#externalcontent"/}}\n\n\n"use strict";\n$.views.tags({\n\n  // Tag with a render method to return HTML content,\n  // including data, and the rendered inline content\n  fntag: function() {\n    return "Title:<br/><b>" +\n      this.tagCtx.render() +\n      "</b><br/>" +\n      this.tagCtx.view.data.languages.length +\n      "&nbsp;languages.";\n  },\n\n  // Tag with no render method. Just a template to\n  // render HTML content including data, and the\n  // rendered inline content.\n  tmpltag: {\n    template: "Title:<br/><b>" +\n      "{{include tmpl=#content/}}" + // render the block content \n      "</b><br/>{{:languages.length}}&nbsp;languages."\n  },\n\n  // Tag with render method to reverse-sort an array\n  sort: function(array) {\n    var ret = "";\n    if (this.tagCtx.props.reverse) {\n      // Render in reverse order\n      for (var i = array.length; i; i--) {\n        ret += this.tagCtx.render(array[i - 1]);\n      }\n    } else {\n      // Render in original order\n      ret += this.tagCtx.render(array);\n    }\n    return ret;\n  }\n\n});\n\nvar movies = [\n  {\n    title: "Meet Joe Black",\n    languages: [\n      {name: "English"},\n      {name: "French"}\n    ]\n  },\n  {\n    title: "Eyes Wide Shut",\n    languages: [\n      {name: "French"},\n      {name: "German"},\n      {name: "Spanish"}\n    ]\n  }\n];\n\n$("#movieList").html(\n  $("#movieTemplate").render(movies)\n);\n\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <tr>\r\n    <td>\r\n      {{fntag}}\r\n        {{>title}}\r\n      {{/fntag}}\r\n    </td>\r\n    <td>\r\n      {{fntag tmpl="#externalTmpl"/}}\r\n    </td>\r\n    <td>\r\n      {{tmpltag}}\r\n        {{>title}}\r\n      {{/tmpltag}}\r\n    </td>\r\n    <td>\r\n      {{tmpltag tmpl="#externalTmpl"/}}\r\n    </td>\r\n    <td>\r\n      {{sort languages reverse=true}}\r\n        <div>\r\n          <b>{{>name}}</b>\r\n        </div>\r\n      {{/sort}}\r\n    </td>\r\n    <td>{{sort languages tmpl="#externalSortedTmpl"/}}</td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="externalSortedTmpl" type="text/x-jsrender">\r\n  <div>{{>name}}</div>\r\n</script>\r\n\r\n<script id="externalTmpl" type="text/x-jsrender">\r\n  {{>title}}\r\n</script>\r\n\r\n<table>\r\n  <thead><tr>\r\n  <th>Render method wrapping content</th>\r\n  <th>Render method with external content</th>\r\n  <th>Tag template wrapping content</th>\r\n  <th>Tag template with external content</th>\r\n  <th>Sort tag: Reverse order</th>\r\n  <th>Sort tag: Languages (external content)</th></tr></thead>\r\n  <tbody id="movieList"></tbody>\r\n</table>\n'}]},"samples/jsr/tags/extend-for":{sections:[{_type:"para",title:"",text:"This sample shows a custom tag: {{range}} – extending the {{for}} tag, used with JsRender (code: range.js).\n(See also the tag-controls/range sample – which uses the same tag with JsViews, as a data-linked custom tag control.)\n"},{_type:"sample",url:"samples/jsrender/tags/extend-for/sample",text:'A {{range}} tag - extending the {{for}} tag\n{{range}} inherits from {{for}}, and adds support for iterating over a range (start to end) of items within an array, or for iterating directly over integers from start integer to end integer.\n\nRange of items from array\n\n{{range members start=1 end=3}}\n  ...\n{{else}}\n  ...\n{{/range}}\n\nRange of integers\n\n{{range start=10 end=40}}\n  ...\n{{else}}\n  ...\n{{/range}}\n\nDerive from {{for}} tag\n\n$.views.tags({\n  range: {\n    // Inherit from {{for}} tag\n    baseTag: "for",\n\n    // Override the render method of {{for}}\n    render: function(val) {\n\n      ...\n\n      // Call the baseTag render method\n      return this.baseTag.render.apply(this, val ? [val] : arguments);\n    },\n\n    ...\n  }\n});\n\n\n"use strict";\nvar team = {\n  members: [\n    {name: "Robert"},\n    {name: "Sarah"},\n    {name: "Xavier"},\n    {name: "Adriana"}\n  ]\n};\n\nvar html = $("#teamTemplate").render(team);\n\n$("#team").html(html);\n\n/*! Sample JsViews tag control: {{range}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n// An extended {{for}} tag: {{range}} inherits from {{for}}, and adds\n// support for iterating over a range (start to end) of items within an array,\n// or for iterating directly over integers from start integer to end integer\n\n$.views.tags({\n  range: {\n    boundProps: ["start", "end"],\n\n    // Inherit from {{for}} tag\n    baseTag: "for",\n\n    // Override the render method of {{for}}\n    render: function(val) {\n      var array = val,\n        tagCtx = this.tagCtx,\n        start = tagCtx.props.start || 0,\n        end = tagCtx.props.end,\n        props = tagCtx.params.props;\n\n      if (start || end) {\n        if (!tagCtx.args.length) { // No array argument passed from tag, so create\n                                   // a computed array of integers from start to end\n\n          array = [];\n          end = end || 0;\n          for (var i = start; i <= end; i++) {\n            array.push(i);\n          }\n        } else if ($.isArray(array)) { // There is an array argument and start and end\n                 // properties,so render using the array truncated to the chosen range\n          array = array.slice(start, end);\n        }\n      }\n\n      // Call the {{for}} baseTag render method\n      return arguments.length || props && (props.start || props.end)\n        ? this.base(array)\n        : this.base(); // Final {{else}} tag, so call base() without arguments, for\n                       // final {{else}} of base {{for}} tag\n    },\n\n    // override onArrayChange of the {{for}} tag implementation\n    onArrayChange: function(ev, eventArgs) {\n      this.refresh();\n    }\n  }\n});\n\n})(this.jQuery);\n\n<div id="team"></div>\r\n\r\n<script id="teamTemplate" type="text/x-jsrender">\r\n  <h4>Members 2 to 4</h4>\r\n  <ul>\r\n    {{range members start=1 end=3}}\r\n      <li>\r\n        {{:name}}\r\n      </li>\r\n    {{else}}\r\n      <li>No items</li>\r\n    {{/range}}\r\n  </ul>\r\n\r\n  <h4>Members 2 to end</h4>\r\n  <ul>\r\n    {{range members start=1}}\r\n      <li>\r\n        {{:name}}\r\n      </li>\r\n    {{else}}\r\n      <li>No items</li>\r\n    {{/range}}\r\n  </ul>\r\n\r\n  <h4>Members 5 to 8</h4>\r\n  <ul>\r\n    {{range members start=4 end=7}}\r\n      <li>\r\n        {{:name}}\r\n      </li>\r\n    {{else}}\r\n      <li>No items</li>\r\n    {{/range}}\r\n  </ul>\r\n\r\n  <h4>Integers 3 to 7</h4>\r\n  <ul>\r\n    {{range start=3 end=7}}\r\n      <li>\r\n        {{:#data}}\r\n      </li>\r\n    {{else}}\r\n      <li>No items</li>\r\n    {{/range}}\r\n  </ul>\r\n\r\n\r\n  <h4>Integers from 4 to 0</h4>\r\n  <ul>\r\n    {{range start=4}}\r\n      <li>\r\n        {{:#data}}\r\n      </li>\r\n    {{else}}\r\n      <li>No items</li>\r\n    {{/range}}\r\n  </ul>\r\n\r\n</script>\n'}]},"samples/tag-controls/multiselect":{sections:[{_type:"sample",url:"samples/tag-controls/multiselect/sample",text:'A multiselect custom tag control \nThis is a fairly advanced sample: A multiselect control which supports both the inline data-binding syntax:\n{^{multisel items=items selected=selectedItems .../}}\n\nand the element-based data-link syntax, using a <select> tag:\n<select data-link="{multisel items=items selected=selectedItems ...}"></select>\n\nIt provides two array  properties, items and selectedItems. Both use observable arrayChange data-binding, so you can (as in the example) use two-way binding between the selectedItems property of one multiselect and the items of another, following a cascading pattern.\n\n"use strict";\nvar count = 1,\n  pageTmpl = $.templates("#pageTmpl"),\n\n  // Using the default labelProp="name" valueProp="id".\n  // (Or use non-default and set on tag, e.g. valueProp="key")\n  items = [{id: "a", name:"first"}, {id: "b", name:"second"}, {id: "c", name:"third"}],\n  selectedItems = [items[0], items[2]],\n  selectedSelectedItems = [items[2]],\n\n  model = {\n    valueProp: "name",\n    items: items,\n    selectedItems: selectedItems,\n    selectedSelectedItems: selectedSelectedItems\n  };\n\npageTmpl.link("#page", model);\n\n$("#add").on("click", function() {\n  $.observable(items).insert({id: "n" + count, name: "new" + count++});\n});\n\n$("#remove").on("click", function() {\n  $.observable(items).remove();\n});\n\n/*! Sample JsViews tag control: {{multiselect}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n$.views.tags({\n    multisel: {\n    boundProps: ["size"],\n    init: function(tagCtx, linkCtx) {\n      var tag = this;\n      tag.valueProp = tag.tagCtx.props.valueProp || "id",\n      tag.labelProp = tag.tagCtx.props.labelProp || "name";\n      tag.items = tagCtx.props.items;\n      tag.selectedItems = tagCtx.props.selected || [];\n      tag._optionsTmpl = "{^{for ~tag.items}}<option data-link=\'value{:" + tag.valueProp + "}\'>{{:" + tag.labelProp + "}}</option>{{/for}}";\n      if (tag._.inline) {\n        if (tagCtx.content) {\n          $.views.sub.error("{{multiselect}} must be empty");\n        } else {\n          tag.template = "<select multiple=\'multiple\'>" + tag._optionsTmpl + "</select>";\n        }\n      } else {\n        linkCtx.elem.multiple = "multiple";\n        tag.template = tag._optionsTmpl;\n      }\n    },\n    onBind: function(tagCtx, linkCtx) {\n      var tag = this;\n      tag.selectElem = tag._.inline ? tag.contents("select") : $(linkCtx.elem);\n      tag.selectElem.on("change", function(ev, evargs) {\n          var newSelection = tag.selectElem.children().map(function(i) {\n            return this.selected && tag.items[i] || null;\n          }).get();\n\n        tag._selSet = true;\n        $.observable(tag.selectedItems).refresh(newSelection);\n        tag._selSet = false;\n      });\n      $([tag.selectedItems]).on("arrayChange", $.proxy(tag.updateSelection, tag));\n      $([tag.items]).on("arrayChange", $.proxy(tag.updateItems, tag));\n      tag.updateSelection();\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      if (tagCtx.props.size) {\n        this.selectElem[0].size = tagCtx.props.size;\n      }\n    },\n    onDispose: function() {\n      var tag = this;\n      $([tag.selectedItems]).off("arrayChange", tag.updateSelection);\n      $([tag.items]).off("arrayChange", tag.updateItems);\n    },\n    onUpdate: false, // don\'t rerender\n    attr: "html",\n\n    //METHODS\n    updateSelection: function() {\n      var tag = this;\n      if (!tag._selSet) {\n        // Map selectedItems to the corresponding array of strings\n        // (the names, or other prop specified by valueProp)\n        var selection = tag.selectedItems.map(function(val) {\n          return val[tag.valueProp];\n        });\n        tag.selectElem.val(selection); // Set selection on the <select> element\n      }\n    },\n    updateItems: function() {\n      var tag = this,\n        l = tag.selectedItems.length;\n      while (l-- > 0) {\n        if ($.inArray(tag.selectedItems[l], tag.items) < 0) {\n          // This selectedItem is no longer in the items\n          $.observable(tag.selectedItems).remove(l);\n        }\n      }\n      this.updateSelection();\n    },\n    dataBoundOnly: true\n  }\n});\n\n})(this.jQuery);\n\n<h3>JsViews \'multiselect\' tag control: The {{multisel}} tag</h3>\r\n\r\n<script id="liTmpl" type="text/x-jsrender">\r\n  <li>{{:name}}</li>\r\n</script>\r\n\r\n<script id="noneTmpl" type="text/x-jsrender">\r\n  <li>(no selection)</li>\r\n</script>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n  {{!-- tag syntax (with default value and label props, "id" and "name" --}}\r\n  {^{multisel items=items selected=selectedItems size=items.length/}}\r\n\r\n  {{!-- Optionally choose different value and label props - e.g. {^{multilsel valueProp="key" ...--}}\r\n\r\n  {{!-- alternative element-based syntax - allowing you to set styles, etc. --}}\r\n  <select data-link="{multisel items=items selected=selectedItems size=items.length}" class="multisel2"></select>\r\n\r\n  <h4>Selected Items</h4>\r\n  {^{multisel items=selectedItems selected=selectedSelectedItems size=selectedItems.length /}}\r\n\r\n  <ul>{^{for selectedItems tmpl="#liTmpl" }}{{else tmpl="#noneTmpl" }}{{/for}}</ul>\r\n\r\n  <h4>Selected selected items</h4>\r\n\r\n  {{!-- You can use element-based syntax for {{for}} too if you want...) --}}\r\n  <ul data-link="{for selectedSelectedItems tmpl=\'#liTmpl\'}{else tmpl=\'#noneTmpl\'}"></ul>\r\n</script>\r\n\r\n<p>\r\n  <button id="add">add item</button>\r\n  <button id="remove">remove item</button>\r\n</p>\r\n\r\n<div id="page"></div>\n'}]},jsvrendertmpl:{sections:[{_type:"para",title:"",text:"paragraph\n"}]},"samples/jsr/helpers":{sections:[{_type:"para",title:"",text:"This sample shows both passing helpers to template.render() and rendering an array as a non-repeating layout\n"},{_type:"sample",url:"samples/jsrender/helpers/sample",text:'For more information about helpers, see the $.views.helpers() API topic.\nThis sample shows passing in helpers to the render() method:\nvar html = $("#movieTemplate").render(\n  // Pass in data\n  [movies],\n  // Pass in helpers\n  {\n    reverseSort: reverse,\n    ...\n  }\n);\n\nIn this case our template renders an array (with sort-order based on the ~reverseSort boolean value we pass in as a helper).\nTo make our template render just once, rather than iterating over the movies array, we wrap the array – as render([myArray]) – and then within the template we do the iteration, using {{for #data}}.\n{{for #data}}\n  <tr>\n    <td>{{>~format(title)}}</td>\n    <td>\n      {{sort languages reverse=~reverseSort}}\n        <div><b>{{>name}}</b></div>\n      {{/sort}}\n    </td>\n  </tr>\n{{/for}}\n\n\n"use strict";\n$.views.tags({\n\n  // Tag to reverse-sort an array\n  sort: function(array) {\n    var ret = "";\n    if (this.tagCtx.props.reverse) {\n      // Render in reverse order\n      for (var i = array.length; i; i--) {\n        ret += this.tagCtx.render(array[i - 1]);\n      }\n    } else {\n      // Render in original order\n      ret += this.tagCtx.render(array);\n    }\n    return ret;\n  }\n\n});\n\nvar reverse = false,\n  upperCase = false,\n  movies = [\n    {\n      title: "Meet Joe Black",\n      languages: [\n        {name: "English"},\n        {name: "French"}\n      ]\n    },\n    {\n      title: "Eyes Wide Shut",\n      languages: [\n        {name: "French"},\n        {name: "German"},\n        {name: "Spanish"}\n      ]\n    }\n  ];\n\nfunction myFormatFunction(value) {\n  return upperCase ? value.toUpperCase() : value.toLowerCase();\n}\n\n$("#movieList")\n  .on("click", "#sortBtn", function() {\n    reverse = !reverse;\n    renderList();\n  })\n  .on("click", "#formatBtn", function() {\n    upperCase = !upperCase;\n    renderList();\n  });\n\nfunction renderList() {\n  var html = $("#movieTemplate").render(\n    // Wrap movies array in an array, to render as a layout with header and footer\n    [movies],\n    // pass in helpers\n    {\n      reverseSort: reverse,\n      format: myFormatFunction,\n      buttonCaption: function(val) {\n        if (val === \'sort\') {\n          return reverse ? "Sort increasing" : "Sort decreasing";\n        }\n        return upperCase ? "to lower" : "to upper";\n      }\n    }\n  );\n\n  $("#movieList").html(html);\n}\nrenderList();\n\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <thead>\r\n    <tr>\r\n      <th>Title\r\n        <button id="formatBtn">\r\n          {{>~buttonCaption(\'case\')}}\r\n        </button>\r\n      </th>\r\n      <th>\r\n        <button id="sortBtn">\r\n          {{>~buttonCaption(\'sort\')}}\r\n        </button>\r\n      </th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    {{for #data}}\r\n      <tr>\r\n        <td>{{>~format(title)}}</td>\r\n        <td>\r\n          {{sort languages reverse=~reverseSort}}\r\n            <div><b>{{>name}}</b></div>\r\n          {{/sort}}\r\n        </td>\r\n      </tr>\r\n    {{/for}}\r\n  </tbody>\r\n</script>\r\n\r\n<table id="movieList"></table>\n'
}]},"samples/jsr/paths":{sections:[{_type:"sample",url:"samples/jsrender/paths/sample",text:'Data paths, helper paths and view paths\nThis sample shows the use of different kinds of path, in JsRender tag expressions.\n\nData paths:\nThe following example shows a data path, address.street for ‘drilling down’ into data from the current data item.\n{{>address.street}}\n\nAnd here is an example of a slightly more complex expression, with a null check for address:\n{{if address && address.street}}\n\n\nHelper paths\nHelper paths start with ~. Here is a helper path (in this case, to a helper method):\n{{for ~combine(phones, cells)}}\n\nThe following shows helper paths referencing ‘helper properties’ (objects, or values):\n{{:~lateMessages.noAddress || ~messages.noAddress}}\n\nAnd here is an example of a helper path, ~frstNm, which is actually an ‘alias’ for the firstName, taken from an outer data-context, and is passed in through the nesting data contexts of the \'views’:\n{{for ... ~frstNm=firstName}}\n  ... {{>~frstNm}} ...\n{{else}}\n  ... {{>~frstNm}} ...\n{{/for}}\n\n\nView paths\nView paths start with "#":\n{{>#data}}\n\n{{>#parent.parent.data.firstName}}\n\nA view path is a way to access the current ‘view’ object (instance of a rendered template or of the block content of a tag), and drill into its properties. The examples above access view.data and view.parent.parent.data.firstName\n\n"use strict";\nvar people = [\n  {\n    firstName: "Pete",\n    lastName: "Ruffles",\n    address: {\n      city: "Bellevue"\n    },\n    cells: ["425 666 3455", "425 222 1111"]\n  },\n  {\n    firstName: "Xavier",\n    lastName: "NoStreet",\n    phones: ["222 666 3455"],\n    cells: ["444 666 3455", "999 222 1111"]\n  },\n  {\n    firstName: "Christie",\n    lastName: "Sutherland",\n    address: {\n      street: "222 2nd Ave NE",\n      city: "Redmond"\n    }\n  }\n];\n\n$.views.helpers({\n  combine: function(arr1, arr2) {\n    return arr1 && arr2 ? arr1.concat(arr2) : arr1 || arr2;\n  },\n  messages: {\n    noAddress: "Has no address..."\n  }\n});\n\n$("#peopleList").html(\n  $("#peopleTemplate").render(people,\n    {lateMessages: {\n      noAddress: "Absolutely no address!..."}\n    }\n  )\n);\n\n<script id="peopleTemplate" type="text/x-jsrender">\r\n\r\n  <b>{{:#index+1}}:</b> {{>firstName}} {{>lastName}}:\r\n\r\n  <br/>\r\n  {{for address tmpl="#addressTemplate"}}{{else}}\r\n    Address missing\r\n  {{/for}}\r\n\r\n  <div>\r\n    Phones:\r\n    {{for ~combine(phones, cells)}}\r\n      <b>{{>#data}}</b> ({{>#parent.parent.data.firstName}}\'s)\r\n    {{else}}\r\n      {{>#parent.data.firstName}} has no phones or cells\r\n    {{/for}}\r\n\r\n{{!-- or provide an alias to get to firstName from nested content\r\n    Phones:\r\n    {{for ~combine(phones, cells) ~frstNm=firstName}}\r\n      <b>{{>#data}}</b> ({{>~frstNm}}\'s)\r\n    {{else}}\r\n      {{>~frstNm}} has no phones or cells\r\n    {{/for}}\r\n--}}\r\n  </div>\r\n\r\n  <br/>\r\n\r\n  <i>\r\n    {{>firstName}}\r\n\r\n    {{if address && address.street}}\r\n      {{!-- address may be null or undefined --}}\r\n      lives in {{>address.street}}.\r\n    {{else}}\r\n      {{:~lateMessages.noAddress || ~messages.noAddress}}\r\n    {{/if}}\r\n  </i>\r\n  <hr/>\r\n\r\n</script>\r\n\r\n<script id="addressTemplate" type="text/x-jsrender">\r\n  <div>\r\n    {{if street}}\r\n      {{>street}}\r\n    {{else}}\r\n      <i>Somewhere</i> in\r\n    {{/if}}\r\n    {{>city}}\r\n  </div>\r\n</script>\r\n\r\n<div id="peopleList"></div>\n'}]},"samples/jsv":{sections:[{_type:"para",title:"",text:"Note: New content is being added regularly to this set of samples.\n"},{_type:"links",title:"",text:""},{_type:"para",title:"",text:"See also the additional samples in the demos folder of the JsViews GitHub repository (available here as live samples).\n"}]},"samples/jsr/converters":{sections:[{_type:"para",title:"Using built-in HTML and URL and attribute encoders",text:"Using built-in HTML and URL and attribute encoders\nJsRender includes built-in converters, for HTML encoding, attribute encoding and URL encoding. A common use for these converters is to protect against injection attacks from untrusted data.\nIt is generally best to use {{> }} when rendering data within element content, if the data is not intended to provide markup for insertion in the DOM.\nIn the context of HTML attributes, use {{attr: }}, or it the case of attributes corresponding to URLs,  {{url: }}\n"},{_type:"sample",title:"Using {{: }} or {{> }} to render data values with optional conversion or encoding",url:"samples/jsrender/converters/sample",text:'Using {{: }} or {{> }} to render data values with optional conversion or encoding\nSpecifying converters:\n\n{{:value}} — does not convert. Used to render values that include html markup.\n{{loc:value lang="..."}} — Uses custom converter, below.\n{{html:value}} — Converts using built-in HTML encoder. (Better security within element content, but slight perf cost).\n{{>value}} — Alternative syntax for built-in HTML encoder.\n{{attr:availability}} — Converts using built-in attribute encoder. (Better security within attributes).\n{{url:value}} — Converts using built-in URL encoder.\n\n\nDeclaring custom converters\n\n$.views.converters({\n  loc: function(value) {\n    var language = this.tagCtx.props.lang;\n    ... (return localized value based on language)\n  }\n});\n\n\n"use strict";\nvar movies = [{\n   availability: "Available in \'X&Y\' Cinemas",\n    title: "Meet Joe Black",\n    synopsis: "The <span class=\'role\'>grim reaper</span> visits"\n    + "<span class=\'role\'>Bill Parrish</span>..."\n  },\n  {\n    availability: "Available at < 20kms from London",\n    title: "Eyes Wide Shut",\n    synopsis: "Director <span class=\'director\'>Stanley Kubrick\'s</span> final film:"\n    + "<br/><br/><img src=\'http://cdn-4.nflximg.com/US/boxshots/large/5670434.jpg\'/>"\n  }\n];\n\n$.views.converters({\n  loc: function(value) {\n    var language = this.tagCtx.props.lang;\n    var result = "";\n\n    switch(language) {\n      case "EN":\n        result = value;\n        break;\n\n      case "FR":\n        switch (value) {\n          case "Meet Joe Black":\n            result = "Rencontrez Joe Black";\n            break;\n\n          case "Eyes Wide Shut":\n            result = "Les Yeux Grand Ferm\\xE9s";\n            break;\n        }\n      break;\n    }\n    return result;\n  }\n});\n\n$("#movieList").html(\n  $("#movieTemplate").render(movies)\n);\n<table>\r\n  <thead><tr>\r\n    <th>Title (loc:English)</th><th>Title (loc:French)</th>\r\n    <th>No Convert</th><th>HTML Encode</th>\r\n  </tr></thead>\r\n  <tbody id="movieList"></tbody>\r\n</table>\r\n\r\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <tr title="{{attr:availability}}">\r\n    <td>{{loc:title lang=\'EN\'}}</td>\r\n    <td>{{loc:title lang=\'FR\'}}</td>\r\n    <td class="synopsis">{{:synopsis}}</td>\r\n    <td class="synopsis">{{>synopsis}}</td>\r\n  </tr>\r\n</script>\n'}]},"samples/tag-controls":{sections:[{_type:"links",title:"",text:""}]},"samples/tag-controls/tabs":{sections:[{_type:"sample",title:"Tabs control",url:"samples/tag-controls/tabs/sample",text:'Tabs control\nNested tags:\nThe sample shows two instances of a custom {{tabs}} tag control – an outer one, and a second inner one in one of the tabs of the outer one…\n\nHere is markup for the inner one:\n\n{^{tabs tabCaption="Inner One"}}\n  ONE inner\n{{else tabCaption="Inner Two"}}\n  TWO  {{>label2}}\n{{else tabCaption="Inner Three"}}\n  THREE inner\n{{/tabs}}\n\n\n"use strict";\nvar state = {\n    innerSelect: 1\n  },\n  tabsTmpl = $.templates("#tabsTmpl");\n\n  tabsTmpl.link("#tabsView",\n    {\n      label2: "Inner Tab Label2",\n      width: 290\n    },\n    {\n      state: state,\n      onAfterCreate: function(view) {\n        // When the outer tabs controls tab changes to a tab containing\n        // a nested tabs control, the inner tabs control we must\n        // hook up the selectionChange handler\n        if (view.type === "tabs" && view.tag.tagCtx.props.id === "inner") {\n          view.tag.onSelectionChange = function(index) {\n            $.observable(state).setProperty("innerSelect", index);\n          }\n        }\n      }\n    }\n  );\n/*! Sample JsViews tag control: {{tabs}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n$.views.tags({\n  tabs: {\n    init: function(tagCtx) {\n      this.selectedIndex = tagCtx.props.selectedIndex || 0;\n      this.tabCount = this.tagCtxs.length;\n    },\n    render: function() {\n      var tagCtx = this.tagCtx;\n      return this.selectedIndex === tagCtx.index ? tagCtx.render() : "";\n    },\n    onBind: function() {\n      var self = this;\n      self.contents(true, ".tabstrip").first()\n        .on("click", ".header_false", function() {\n          self.setTab($.view(this).index);\n        });\n    },\n    template: \'<table class="tabsview"><tbody>\' +\n      \'<tr class="tabstrip">\' +\n      \'{{for ~tag.tagCtxs}}\' +\n        \'<th data-link="class{:\\\'header_\\\' + (#index === ~tag.selectedIndex)}">\' +\n          \'{{>props.tabCaption}}\' +\n        \'</th>\' +\n      \'{{/for}}\' +\n    \'</tr>\' +\n    \'<tr class="tabscontent">\' +\n      \'<td colspan="{{:~tag.tagCtxs.length}}">\' +\n        \'<div style="width:{{attr:~tag.tagCtxs[0].props.width}};\' +\n                    \'height:{{attr:~tag.tagCtxs[0].props.height}}">\' +\n          \'{^{for ^tmpl=~tag.tagCtxs[~tag.selectedIndex].tmpl /}}\' +\n        \'</div>\' +\n        \'</td>\' +\n      \'</tr>\' +\n    \'</tbody></table>\',\n\n    //METHODS\n    setTab: function(index) {\n      $.observable(this).setProperty("selectedIndex", index);\n      if (this.onSelectionChange) {\n        this.onSelectionChange(index, this);\n      }\n    },\n    dataBoundOnly: true\n  }\n});\n\n})(this.jQuery);\n\n\n<h3>JsViews \'tabs\' tag control: The {{tabs}} tag</h3>\r\n\r\n<div id="tabsView">..loading</div>\r\n\r\n<script id="tabsTmpl" type="text/x-jsrender">\r\n  {^{tabs id="outer" ^width=width+"px" height="125px" tabCaption="first"}}\r\n    <div class="special">Some tabbed content:</div>\r\n    {^{tabs id="inner" ^selectedIndex=~state.innerSelect\r\n      ^width=(width-23)+"px" height="35px" tabCaption="Inner One"}}\r\n      ONE inner\r\n    {{else tabCaption="Inner Two"}}\r\n      TWO {{>label2}}\r\n    {{else tabCaption="Inner Three"}}\r\n      THREE inner\r\n    {{/tabs}}\r\n  {{else tabCaption="second"}}\r\n    <ul style="margin:0"><li>Some</li><li>other</li><li>content</li></ul>\r\n  {{/tabs}}\r\n\r\n  <br/><br/>\r\n\r\n  Modify width (pixels): <input data-link="width" />\r\n</script>\n'}]},"samples/jsrandjsvconverters":{sections:[{_type:"sample",text:""}]},"samples/jso":{sections:[]},"samples/editable/tags":{sections:[{_type:"para",title:"",text:"This is the first of four samples exploring alternative patterns for creating two-way binding and providing UI for editing data.\n"},{_type:"sample",url:"samples/editable-data/linked-tags/sample",text:'Data-linked tags: {^{for ...}}, {^{:...}}, etc.\nThis sample uses data-linked tags for {^{for ...}} (iteration over arrays) and for {^{:...}} and {^{>...}} (one-way data binding):\n{^{for movies}}\n  <tr class="hover" data-link="css-background-color{:~bgColor()}">\n      <td>\n      {^{:#index + 1}}: {^{>title}}\n      </td>\n      <td>\n      {^{for languages}}\n          <div>{^{>name}}</div>\n      {{/for}}\n    </td>\n    ...\n  </tr>\n{{/for}}\n\n\nData-linked elements: <input data-link="..."/>\nBut for two-way data binding of the textboxes in the detail view it uses data-linked <input/> elements:\n{^{for movies[selectedIndex]}}\n  ...\n  <input data-link="title" />\n  ...\n  {^{for languages}}\n    ...\n    <input data-link="name" />\n    ...\n  {{/for}}\n  ...\n{{/for}}\n\n\n"use strict";\nvar counter = 0,\n  movies = [\n    {\n      title:"Meet Joe Black",\n      languages: [\n        {name: "English"},\n        {name: "French"}\n      ]\n    },\n    {\n      title:"Eyes Wide Shut",\n      languages: [\n        {name: "German"},\n        {name: "French"},\n        {name: "Spanish"}\n      ]\n    }\n  ],\n  app = {\n    selectedIndex: null,\n    movies: movies,\n    select: function select(index) {\n      if (this.selectedIndex !== index) {\n        $.observable(this)\n          .setProperty("selectedIndex", index);\n      }\n    }\n  };\n\n$.templates({\n  movieTmpl: {\n    markup: "#movieTemplate",\n    helpers: {\n      bgColor: bgColor\n    }\n  }\n});\n\nfunction bgColor() {\n  return this.ctx.root.selectedIndex === this.index\n      ? "yellow"\n      : (this.index%2 ? "#fdfdfe" : "#efeff2");\n}\nbgColor.depends = ["#index", "~root.selectedIndex"];\n\n$.link.movieTmpl("#movieList", app)\n  .on("click", ".addMovie", function() {\n    $.observable(movies).insert({\n      title: "NewTitle" + counter ,\n      languages: [\n        {name: "NewLanguage" + counter++}\n      ]}\n    );\n    // Set selection on the added item\n    app.select($.view(".movies tr:last").index);\n  })\n\n  .on("click", ".movies tr", function() {\n    app.select($.view(this).index);\n  })\n\n  .on("click", ".removeMovie", function() {\n    app.select();\n    $.observable(movies).remove($.view(this).index);\n    return false;\n  })\n\n  .on("click", ".addLanguage", function() {\n    var languages = $.view(this).data.languages;\n    $.observable(languages).insert({\n      name: "NewLanguage" + counter++\n    });\n  })\n\n  .on("click", ".removeLanguage", function() {\n    var view = $.view(this);\n    $.observable(view.parent.data).remove(view.index);\n    return false;\n  });\n\n$("#deletelast").on("click", function() {\n  if (movies.length) {\n    var languages = movies[movies.length - 1].languages;\n    $.observable(languages).remove();\n  }\n});\n\n$("#showdata").on("click", function() {\n  $("#console").append("<hr/>" + $("#showData").render(movies));\n});\n\n<div class="buttons">\r\n  <button id="showdata">show data</button>\r\n  <button id="deletelast">delete last language</button>\r\n</div>\r\n\r\n<div class="comment">Click to select and edit</div>\r\n\r\n<div id="movieList"></div>\r\n\r\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <table>\r\n    <thead><tr>\r\n      <th>Title</th><th>Languages</th>\r\n      <th><span class="addMovie">Add</span></th>\r\n    </tr></thead>\r\n    <tbody class="movies">\r\n      {^{for movies}}\r\n        <tr class="hover" data-link="css-background-color{:~bgColor()}">\r\n          <td>\r\n            {^{:#index + 1}}: {^{>title}}\r\n          </td>\r\n          <td>\r\n            {^{for languages}}\r\n              <div>{^{>name}}</div>\r\n            {{/for}}\r\n          </td>\r\n          <td><span class="removeMovie"></span></td>\r\n        </tr>\r\n      {{/for}}\r\n    </tbody>\r\n  </table>\r\n\r\n  <div class="detail">\r\n    {^{for movies[selectedIndex]}}\r\n      <div>\r\n        <div class="title">Title:</div>\r\n        <div><input data-link="title" /></div>\r\n        <div class="title">\r\n          Languages: <span class="addLanguage">Add</span>\r\n        </div>\r\n        {^{for languages}}\r\n          <input data-link="name" />\r\n          <span class="removeLanguage"></span>\r\n        {{/for}}\r\n      </div>\r\n    {{/for}}\r\n  </div>\r\n</script>\r\n\r\n<script id="showData" type="text/x-jsrender">\r\n  <div>\r\n    <b>Movie:</b> {{>title}}\r\n    <b>Languages:</b> {{for languages}} {{>name}}{{/for}}\r\n  </div>\r\n</script>\r\n\r\n<div id="console">\r\n</div>\n'},{_type:"para",title:"",text:"In the next sample we will replace the data-linked tags for one-way binding by equivalent data-linked elements.\n"}]},"samples/editable/elems":{sections:[{_type:"para",title:"",text:"This sample modifies the previous sample by replacing the data-linked tags for one-way binding with equivalent data-linked elements.\n"},{_type:"sample",url:"samples/editable-data/linked-elems/sample",text:'Data-linked elements: <span data-link="..."> etc.\nThis sample uses data-linked tags for {^{for ...}} (iteration over arrays) but it uses data-linked elements for one-way data binding:\n{^{for movies}}\n  <tr class="hover" data-link="css-background-color{:~bgColor()}">\n      <td>\n        <span data-link="#index + 1"></span>:\n        <span data-link="title"></span>\n      </td>\n      <td>\n      {^{for languages}}\n        <div data-link="name"></div>\n      {{/for}}\n    </td>\n    ...\n  </tr>\n{{/for}}\n\nas well as for the two-way data binding of the textboxes in the detail view:\n{^{for movies[selectedIndex]}}\n  ...\n  <input data-link="title" />\n  ...\n  {^{for languages}}\n    ...\n    <input data-link="name" />\n    ...\n  {{/for}}\n  ...\n{{/for}}\n\n\n"use strict";\nvar counter = 0,\n  movies = [\n    {\n      title:"Meet Joe Black",\n      languages: [\n        {name: "English"},\n        {name: "French"}\n      ]\n    },\n    {\n      title:"Eyes Wide Shut",\n      languages: [\n        {name: "German"},\n        {name: "French"},\n        {name: "Spanish"}\n      ]\n    }\n  ],\n  app = {\n    selectedIndex: null,\n    movies: movies,\n    select: function(index) {\n      if (this.selectedIndex !== index) {\n        $.observable(this)\n          .setProperty("selectedIndex", index);\n      }\n    }\n  };\n\n$.templates({\n  movieTmpl: {\n    markup: "#movieTemplate",\n    helpers: {\n      bgColor: bgColor\n    }\n  }\n});\n\nfunction bgColor() {\n  return this.ctx.root.selectedIndex === this.index\n      ? "yellow"\n      : (this.index%2 ? "#fdfdfe" : "#efeff2");\n}\nbgColor.depends = ["#index", "~root.selectedIndex"];\n\n$.link.movieTmpl("#movieList", app)\n  .on("click", ".addMovie", function() {\n    $.observable(movies).insert({\n      title: "NewTitle" + counter ,\n      languages: [\n        {name: "NewLanguage" + counter++}\n      ]}\n    );\n    // Set selection on the added item\n    app.select($.view(".movies tr:last").index);\n  })\n\n  .on("click", ".movies tr", function() {\n    app.select($.view(this).index);\n  })\n\n  .on("click", ".removeMovie", function() {\n    app.select();\n    $.observable(movies).remove($.view(this).index);\n    return false;\n  })\n\n  .on("click", ".addLanguage", function() {\n    var languages = $.view(this).data.languages;\n    $.observable(languages).insert({\n      name: "NewLanguage" + counter++\n    });\n  })\n\n  .on("click", ".removeLanguage", function() {\n    var view = $.view(this);\n    $.observable(view.parent.data).remove(view.index);\n    return false;\n  });\n\n$("#deletelast").on("click", function() {\n  if (movies.length) {\n    var languages = movies[movies.length - 1].languages;\n    $.observable(languages).remove();\n  }\n});\n\n$("#showdata").on("click", function() {\n  $("#console").append("<hr/>" + $("#showData").render(movies));\n});\n\n<div class="buttons">\r\n  <button id="showdata">show data</button>\r\n  <button id="deletelast">delete last language</button>\r\n</div>\r\n\r\n<div class="comment">Click to select and edit</div>\r\n\r\n<div id="movieList"></div>\r\n\r\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <table>\r\n    <thead><tr>\r\n      <th>Title</th><th>Languages</th>\r\n      <th><span class="addMovie">Add</span></th>\r\n    </tr></thead>\r\n    <tbody class="movies">\r\n      {^{for movies}}\r\n        <tr class="hover" data-link="css-background-color{:~bgColor()}">\r\n          <td>\r\n            <span data-link="#index + 1"></span>:\r\n            <span data-link="title"></span>\r\n          </td>\r\n          <td>\r\n            {^{for languages}}\r\n              <div data-link="name"></div>\r\n            {{/for}}\r\n          </td>\r\n          <td><span class="removeMovie"></span></td>\r\n        </tr>\r\n      {{/for}}\r\n    </tbody>\r\n  </table>\r\n\r\n  <div class="detail">\r\n    {^{for movies[selectedIndex]}}\r\n      <div>\r\n        <div class="title">Title:</div>\r\n        <div><input data-link="title" /></div>\r\n        <div class="title">\r\n          Languages: <span class="addLanguage">Add</span>\r\n        </div>\r\n        {^{for languages}}\r\n          <input data-link="name" />\r\n          <span class="removeLanguage"></span>\r\n        {{/for}}\r\n      </div>\r\n    {{/for}}\r\n  </div>\r\n</script>\r\n\r\n<script id="showData" type="text/x-jsrender">\r\n  <div>\r\n    <b>Movie:</b> {{>title}}\r\n    <b>Languages:</b> {{for languages}} {{>name}}{{/for}}\r\n  </div>\r\n</script>\r\n\r\n<div id="console">\r\n</div>\n'},{_type:"para",title:"",text:"In the next sample we will replace some of the templated content by top-level data-linked elements, and we will show how to use {for} bindings with data-linked elements.\n"}]},"samples/editable/toplevel-for":{sections:[{_type:"para",title:"",text:"This sample modifies the previous sample by replacing some of the templated content by top-level data-linked elements. It also shows how to use {for} bindings with data-linked elements.\n"},{_type:"sample",url:"samples/editable-data/toplevel-for/sample",text:'Data-linked top-level elements: <div data-link="..."> etc.\nThis sample uses data-linking on top-level elements (i.e. elements that are not part of rendered templates):\n$.link(true, "#linkedContent", app)\n\n<div id="linkedContent">\n  <table>\n    ...\n    <tbody class="movies" data-link="{for movies tmpl=\'movieTmpl\'}"></tbody>\n  </table>\n\n  <div class="detail" data-link="{for movies[selectedIndex] tmpl=\'#detailTemplate\'}"></div>\n</div>\n\n\nData-linked {for} binding: data-link="{for ...}"\nThe data-linked <tbody> element uses a {for ...} binding, referencing a template –\n<tbody class="movies" data-link="{for movies tmpl=\'movieTmpl\'}"></tbody>\n\n– so it is the element-based data-linking equivalent of\n{^{for movies tmpl=\'movieTmpl\'}}\n\nand the content of the <tbody> is automatically incrementally updated when the movies array is modified.\nSimilarly the whole detail view, with its dynamic linking to the selected movie item, is achieved by a single data-linked top-level <div ...>, using {for ...} referencing a template:\n<div class="detail" data-link="{for movies[selectedIndex] tmpl=\'#detailTemplate\'}"></div>\n\n\n"use strict";\nvar counter = 0,\n  movies = [\n    {\n      title:"Meet Joe Black",\n      languages: [\n        {name: "English"},\n        {name: "French"}\n      ]\n    },\n    {\n      title:"Eyes Wide Shut",\n      languages: [\n        {name: "German"},\n        {name: "French"},\n        {name: "Spanish"}\n      ]\n    }\n  ],\n  app = {\n    selectedIndex: null,\n    movies: movies,\n    select: function(index) {\n      if (this.selectedIndex !== index) {\n        $.observable(this)\n          .setProperty("selectedIndex", index);\n      }\n    }\n  };\n\n$.templates({\n  movieTmpl: {\n    markup: "#movieTemplate",\n    helpers: {\n      bgColor: bgColor\n    },\n    templates: {\n      languageName: "<div data-link=\\"name\\"></div>"\n    }\n  }\n});\n\nfunction bgColor() {\n  return app.selectedIndex === this.index\n      ? "yellow"\n      : (this.index%2 ? "#fdfdfe" : "#efeff2");\n}\nbgColor.depends = ["#index", app, "selectedIndex"];\n\n$.link(true, "#linkedContent", app)\n  .on("click", ".addMovie", function() {\n    $.observable(movies).insert({\n      title: "NewTitle" + counter ,\n      languages: [\n        {name: "NewLanguage" + counter++}\n      ]}\n    );\n    // Set selection on the added item\n    app.select($.view(".movies tr:last").index);\n  })\n\n  .on("click", ".movies tr", function() {\n    app.select($.view(this).index);\n  })\n\n  .on("click", ".removeMovie", function() {\n    app.select();\n    $.observable(movies).remove($.view(this).index);\n    return false;\n  })\n\n  .on("click", ".addLanguage", function() {\n    var languages = $.view(this).data.languages;\n    $.observable(languages).insert({\n      name: "NewLanguage" + counter++\n    });\n  })\n\n  .on("click", ".removeLanguage", function() {\n    var view = $.view(this);\n    $.observable(view.parent.data).remove(view.index);\n    return false;\n  });\n\n$("#deletelast").on("click", function() {\n  if (movies.length) {\n    var languages = movies[movies.length - 1].languages;\n    $.observable(languages).remove();\n  }\n});\n\n$("#showdata").on("click", function() {\n  $("#console").append("<hr/>" + $("#showData").render(movies));\n});\n\n<div class="buttons">\r\n  <button id="showdata">show data</button>\r\n  <button id="deletelast">delete last language</button>\r\n</div>\r\n\r\n<div class="comment">Click to select and edit</div>\r\n\r\n<!----------------- Data-linked content -------------------> \r\n<div id="linkedContent">\r\n  <table>\r\n    <thead><tr>\r\n      <th>Title</th><th>Languages</th>\r\n      <th><span class="addMovie">Add</span></th>\r\n    </tr></thead>\r\n    <tbody class="movies" data-link="{for movies tmpl=\'movieTmpl\'}"></tbody>\r\n  </table>\r\n\r\n  <div class="detail" data-link="{for movies[selectedIndex] tmpl=\'#detailTemplate\'}"></div>\r\n</div>\r\n\r\n<!----------------- Templates ------------------->\r\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <tr class="hover" data-link="css-background-color{:~bgColor()}">\r\n    <td>\r\n      <span data-link="#index + 1"></span>:\r\n      <span data-link="title"></span>\r\n    </td>\r\n    <td data-link="{for languages tmpl=\'languageName\'}"></td>\r\n    <td><span class="removeMovie"></span></td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="detailTemplate" type="text/x-jsrender">\r\n  <div>\r\n    <div class="title">Title:</div>\r\n    <div><input data-link="title" /></div>\r\n    <div class="title">\r\n      Languages: <span class="addLanguage">Add</span>\r\n    </div>\r\n    {^{for languages}}\r\n      <input data-link="name" />\r\n      <span class="removeLanguage"></span>\r\n    {{/for}}\r\n  </div>\r\n</script>\r\n\r\n<!----------------- Show data ------------------->\r\n<script id="showData" type="text/x-jsrender">\r\n  <div>\r\n    <b>Movie:</b> {{>title}}\r\n    <b>Languages:</b> {{for languages}} {{>name}}{{/for}}\r\n  </div>\r\n</script>\r\n\r\n<div id="console">\r\n</div>\n'},{_type:"para",title:"",text:"In the next sample we will replace the declarative top-level binding for the detail view by a programmatic approach, using $.observe().\n"}]},"samples/editable/observe":{sections:[{_type:"para",title:"",text:"This sample modifies the previous sample by replacing the declarative top-level binding for the detail view by a programmatic approach, using $.observe().\n"},{_type:"sample",url:"samples/editable-data/observe/sample",text:'We will replace the top-level data-linked element for the detail view:\n<div class="detail" data-link="{for movies[selectedIndex] tmpl=\'#detailTemplate\'}"></div>\n\nby an unlinked element:\n<div id="movieDetail" class="detail"></div>\n\nNow, we will set up a listener for observable changes in the selectedIndex property of our app object, and when it changes we will insert or remove data-linked templated content for the selected data item, within our movieDetail element.\n$.observe(app, "selectedIndex",  function(event, args) {\n  var selectedIndex = args.value;\n  if (selectedIndex > -1) {\n    $.link.detailTmpl("#movieDetail", app.movies[selectedIndex]);\n  } else {\n    $("#movieDetail").empty();\n  }\n});\n\n\n"use strict";\nvar counter = 0,\n  movies = [\n    {\n      title:"Meet Joe Black",\n      languages: [\n        {name: "English"},\n        {name: "French"}\n      ]\n    },\n    {\n      title:"Eyes Wide Shut",\n      languages: [\n        {name: "German"},\n        {name: "French"},\n        {name: "Spanish"}\n      ]\n    }\n  ],\n  app = {\n    selectedIndex: null,\n    movies: movies,\n    select: function(index) {\n      if (this.selectedIndex !== index) {\n        $.observable(this)\n          .setProperty("selectedIndex", index);\n      }\n    }\n  };\n\n$.templates({\n  movieTmpl: {\n    markup: "#movieTemplate",\n    helpers: {\n      bgColor: bgColor\n    },\n    templates: {\n      languageName: "<div data-link=\\"name\\"></div>"\n    }\n  },\n  detailTmpl: "#detailTemplate"\n});\n\n$.observe(app, "selectedIndex",  function(event, args) {\n  var selectedIndex = args.value;\n  if (selectedIndex > -1) {\n    $.link.detailTmpl("#movieDetail", app.movies[selectedIndex]);\n  } else {\n    $("#movieDetail").empty();\n  }\n});\n\nfunction bgColor() {\n  return app.selectedIndex === this.index\n      ? "yellow"\n      : (this.index%2 ? "#fdfdfe" : "#efeff2");\n}\nbgColor.depends = ["#index", app, "selectedIndex"];\n\n$.link(true, "#movieList", app)\n  .on("click", ".addMovie", function() {\n    $.observable(movies).insert({\n      title: "NewTitle" + counter ,\n      languages: [\n        {name: "NewLanguage" + counter++}\n      ]}\n    );\n    // Set selection on the added item\n    app.select($.view(".movies tr:last").index);\n  })\n\n  .on("click", ".movies tr", function() {\n    app.select($.view(this).index);\n  })\n\n  .on("click", ".removeMovie", function() {\n    app.select();\n    $.observable(movies).remove($.view(this).index);\n    return false;\n  });\n\n$("#movieDetail")\n  .on("click", ".addLanguage", function() {\n    var languages = $.view(this).data.languages;\n    $.observable(languages).insert({\n      name: "NewLanguage" + counter++\n    });\n  })\n\n  .on("click", ".removeLanguage", function() {\n    var view = $.view(this);\n    $.observable(view.parent.data).remove(view.index);\n    return false;\n  });\n\n$("#deletelast").on("click", function() {\n  if (movies.length) {\n    var languages = movies[movies.length - 1].languages;\n    $.observable(languages).remove();\n  }\n});\n\n$("#showdata").on("click", function() {\n  $("#console").append("<hr/>" + $("#showData").render(movies));\n});\n\n<div class="buttons">\r\n  <button id="showdata">show data</button>\r\n  <button id="deletelast">delete last language</button>\r\n</div>\r\n\r\n<div class="comment">Click to select and edit</div>\r\n\r\n<table id="movieList">\r\n  <thead><tr>\r\n    <th>Title</th><th>Languages</th>\r\n    <th><span class="addMovie">Add</span></th>\r\n  </tr></thead>\r\n  <tbody class="movies" data-link="{for movies tmpl=\'movieTmpl\'}"></tbody>\r\n</table>\r\n\r\n<div id="movieDetail" class="detail"></div>\r\n\r\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <tr class="hover" data-link="css-background-color{:~bgColor()}">\r\n    <td>\r\n      <span data-link="#index + 1"></span>:\r\n      <span data-link="title"></span>\r\n    </td>\r\n    <td data-link="{for languages tmpl=\'languageName\'}"></td>\r\n    <td><span class="removeMovie"></span></td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="detailTemplate" type="text/x-jsrender">\r\n  <div>\r\n    <div class="title">Title:</div>\r\n    <div><input data-link="title" /></div>\r\n    <div class="title">\r\n      Languages: <span class="addLanguage">Add</span>\r\n    </div>\r\n    {^{for languages}}\r\n      <input data-link="name" />\r\n      <span class="removeLanguage"></span>\r\n    {{/for}}\r\n  </div>\r\n</script>\r\n\r\n<script id="showData" type="text/x-jsrender">\r\n  <div>\r\n    <b>Movie:</b> {{>title}}\r\n    <b>Languages:</b> {{for languages}} {{>name}}{{/for}}\r\n  </div>\r\n</script>\r\n\r\n<div id="console">\r\n</div>\n'},{_type:"para",title:"",text:"In the next sample we will return to the declarative top-level binding approach for the detail view, and replace the plain objects hierarchy by a hierarchy of compiled View Models.\n"}]},"samples/editable/compiled":{sections:[{_type:"para",title:"",text:"This sample returns to the sample with declarative top-level binding for the detail view, and replaces the plain objects hierarchy by a hierarchy of compiled View Models.\n"},{_type:"sample",url:"samples/editable-data/compiled/sample",text:'Set up initial data:\napp = {\n  selectedIndex: null,\n  movies: [...]\n};\n\nCompile View Models:\n$.views.viewModels({\n  MovieApp: {\n    getters: [...],\n    extend: {...}\n  },\n  Movie: {\n    ...\n  },\n  Language: {\n    ...\n  }\n});\n\nInstantiate View Models:\nvar appVm = $.views.viewModels.MovieApp.map(app);\n\nTop level data-linking – bind content to View Models:\n$.link(true, ".linkedContent", appVm);\n\n\n"use strict";\nvar VMs = $.views.viewModels,\n  counter = 0,\n\n// Initial data\n  app = {\n    selectedIndex: null,\n    movies: [\n    {\n      title:"Meet Joe Black",\n      languages: [\n        {name: "English"},\n        {name: "French"}\n      ]\n    },\n    {\n      title:"Eyes Wide Shut",\n      languages: [\n        {name: "German"},\n        {name: "French"},\n        {name: "Spanish"}\n      ]\n    }\n  ]\n  };\n\n// Compile View Models\nVMs({\n  MovieApp: {\n    getters: [\n      "selectedIndex",\n      {\n        getter: "movies",\n        type: "Movie"\n      }\n    ],\n    extend: {\n      addMovie: function() {\n        $.observable(this.movies()).insert(VMs.Movie(\n          "NewTitle" + counter ,\n          [VMs.Language("NewLanguage" + counter++)]\n        ));\n        // Set selection on the added item\n        this.select($.view(".movies tr:last").index);\n      },\n      removeMovie: function(index) {\n        this.select(); // unselect\n        $.observable(this.movies()).remove(index);\n        return false;\n      },\n      select: function(index) {\n        if (this.selectedIndex() !== index) {\n          this.selectedIndex(index);\n        }\n      },\n      deleteLast: function() { // Example of action using View Model hierarchy\n        var moviesCount = this.movies().length;\n        if (moviesCount) {\n          var lastMovie = this.movies()[moviesCount-1];\n          var languagesCount = lastMovie.languages().length;\n          if (languagesCount) {\n            lastMovie.removeLanguage(languagesCount-1);\n          }\n        }\n      },\n      showData: function() { // Get the current data, and display in \'console\'\n        $("#console").append($("#showData").render(this.unmap()));\n      },\n      bgColor: bgColor // Helper for background color rendering\n    }\n  },\n  Movie: {\n    getters: [\n      "title",\n      {\n        getter: "languages",\n        type: "Language"\n      }\n    ],\n    extend: {\n      addLanguage: function() {\n        $.observable(this.languages()).insert(VMs.Language("NewLanguage" + counter++));\n      },\n      removeLanguage: function(index) {\n        $.observable(this.languages()).remove(index);\n        return false;\n      }\n    }\n  },\n  Language: {\n    getters: ["name"]\n  }\n});\n\n// Instantiate View Models\nvar appVm = $.views.viewModels.MovieApp.map(app);\n\n// Background color helper function\nfunction bgColor(index) {\n  return this.selectedIndex() === index\n    ? "yellow"\n    : (index%2 ? "#fdfdfe" : "#efeff2");\n}\n\nbgColor.depends = ["#index", appVm, "selectedIndex"];\n\n// Top level data-linking - bind content to View Models\n$.link(true, ".linkedContent", appVm);\n\n<!----------------- Data-linked content -------------------> \r\n<div class="linkedContent">\r\n  <div class="buttons">\r\n    <button data-link="{on showData}">show data</button>\r\n    <button data-link="{on deleteLast}">delete last language</button>\r\n  </div>\r\n  <div class="comment">Click to select and edit</div>\r\n\r\n  <table>\r\n    <thead><tr>\r\n      <th>Title</th><th>Languages</th>\r\n      <th><span class="addMovie" data-link="{on addMovie}">Add</span></th>\r\n    </tr></thead>\r\n    <tbody class="movies" data-link="{for movies() tmpl=\'#movieTemplate\'}"></tbody>\r\n  </table>\r\n\r\n  <div class="detail" data-link="{for movies()[selectedIndex()] tmpl=\'#detailTemplate\'}"></div>\r\n</div>\r\n\r\n<!----------------- Templates ------------------->\r\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <tr class="hover" data-link="css-background-color{:~root.bgColor(#index)} {on ~root.select #index}">\r\n    <td>\r\n      <span data-link="#index + 1"></span>:\r\n      <span data-link="title()"></span>\r\n    </td>\r\n    <td>\r\n      {^{for languages()}}\r\n        <div data-link="name()"></div>\r\n      {{/for}}\r\n    </td>\r\n    <td><span class="removeMovie" data-link="{on ~root.removeMovie #index}"></span></td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="detailTemplate" type="text/x-jsrender">\r\n  <div>\r\n    <div class="title">Title:</div>\r\n    <div><input data-link="title()" /></div>\r\n    <div class="title">\r\n      Languages: <span class="addLanguage" data-link="{on addLanguage}">Add</span>\r\n    </div>\r\n    {^{for languages() ~movie=#data}}\r\n      <input data-link="name()" />\r\n      <span class="removeLanguage" data-link="{on ~movie.removeLanguage #index}"></span>\r\n    {{/for}}\r\n  </div>\r\n</script>\r\n\r\n<!----------------- Show data ------------------->\r\n<script id="showData" type="text/x-jsrender">\r\n  <hr/>\r\n  {{for movies}}<div>\r\n    <b>Movie:</b> {{>title}}\r\n    <b>Languages:</b> {{for languages}} {{>name}}{{/for}}\r\n  </div>{{/for}}\r\n</script>\r\n\r\n<div id="console">\r\n</div>\n'
},{_type:"para",title:"",text:"In the next sample we will provide a Save/Undo feature – where Save uses the submit action of an HTML form to save data changes to the server, and Undo uses the compiled View Model merge() and unmap() features to revert changes.\n"}]},"samples/editable/submit":{sections:[{_type:"para",title:"Using merge() and unmap() for Save/Undo behavior, in an MVVM application",text:"Using merge() and unmap() for Save/Undo behavior, in an MVVM application\nThe following sample (available also at MVVM Dynamic view hierarchy) modifies the previous sample by providing a Save/Undo feature.\nIt provides a Submit Changes button (which makes a ‘snapshot’ of current View Model data, and which would in a ‘real app’ save that data back to the server), and an Undo button (which reverts current View Model data back to the last ‘snapshot’).\nSpecifically:\n\nSubmit Changes is bound to the submit action of an HTML form – so will be triggered also by Enter\nIt uses the compiled View Model unmap() feature to make a snapshot of data for sending to the server\nUndo uses the compiled View Model merge() feature to revert changes\n\n"},{_type:"sample",url:"samples/editable-data/submit/sample",text:'Provide Submit Changes and Undo buttons, binding to saveData and undo methods of View Model:\n<div class="linkedContent">\n  ...\n  <button data-link="{on undo} ...">Undo</button>\n  ...\n  <form data-link="{on \'submit\' saveData}">\n    <button type="submit" ...>Submit Changes</button>\n    ...\n    <tbody class="movies" data-link="{for movies() tmpl=\'#movieTemplate\'}"></tbody>\n    ...\n    <div class="detail" data-link="{for movies()[selectedIndex()] tmpl=\'#detailTemplate\'}"></div>\n  </form>\n</div>\n\nProvide undo and saveData methods on compiled View Model:\n$.views.viewModels({\n  MovieApp: {\n    getters: [...],\n    extend: {\n      undo: function() {\n        // Revert to previous savedData\n        this.merge(savedData);\n        ...\n      },\n      saveData: function() {\n        // Save current data, for subsequent Undo behavior\n        savedData = this.unmap();\n        // Submit current data to server\n        $.post("/save/data", ...savedData, function(msg) {...});\n        ...\n      },\n      ...\n\n\n"use strict";\nvar VMs = $.views.viewModels,\n  counter = 0,\n\n// Initial data\n  app = {\n    msg: null,\n    selectedIndex: null,\n    movies: [\n    {\n      title:"Meet Joe Black",\n      languages: [\n        {name: "English"},\n        {name: "French"}\n      ]\n    },\n    {\n      title:"Eyes Wide Shut",\n      languages: [\n        {name: "German"},\n        {name: "French"},\n        {name: "Spanish"}\n      ]\n    }\n  ]\n  };\n\n// Compile View Models\nVMs({\n  MovieApp: {\n    getters: [\n      "msg",\n      "selectedIndex",\n      {\n        getter: "movies",\n        type: "Movie"\n      }\n    ],\n    extend: {\n      undo: function() {\n        this.merge(savedData); // Revert to previous savedData\n        this.msg(null);\n      },\n      saveData: function() {\n        // Save current data, for subsequent Undo behavior\n        savedData = this.unmap();\n        savedData.selectedIndex = null;\n        savedData = JSON.stringify(savedData);\n\n        // In real app, uncomment to save current data to the server:\n        // $.post("/save/data", {movieData : savedData}, function(msg) {\n          var msg = "In a real app, updated data would have been saved to server";\n          this.msg(msg); // Display message\n        //});\n        return false; // Do not do default form action for submit\n      },\n      addMovie: function() {\n        $.observable(this.movies()).insert(VMs.Movie(\n          "NewTitle" + counter ,\n          [VMs.Language("NewLanguage" + counter++)]\n        ));\n        // Set selection on the added item\n        this.select($.view(".movies tr:last").index);\n      },\n      removeMovie: function(index) {\n        this.select(); // unselect\n        $.observable(this.movies()).remove(index);\n        return false;\n      },\n      select: function(index) {\n        if (this.selectedIndex() !== index) {\n          this.selectedIndex(index);\n        }\n      },\n      deleteLast: function() { // Example of action using View Model hierarchy\n        var moviesCount = this.movies().length;\n        if (moviesCount) {\n          var lastMovie = this.movies()[moviesCount-1];\n          var languagesCount = lastMovie.languages().length;\n          if (languagesCount) {\n            lastMovie.removeLanguage(languagesCount-1);\n          }\n        }\n      },\n      showData: function() { // Get the current data, and display in \'console\'\n        $("#console").append($("#showData").render(this.unmap()));\n      },\n      bgColor: bgColor // Helper for background color rendering\n    }\n  },\n  Movie: {\n    getters: [\n      "title",\n      {\n        getter: "languages",\n        type: "Language"\n      }\n    ],\n    extend: {\n      addLanguage: function() {\n        $.observable(this.languages()).insert(VMs.Language("NewLanguage" + counter++));\n      },\n      removeLanguage: function(index) {\n        $.observable(this.languages()).remove(index);\n        return false;\n      }\n    }\n  },\n  Language: {\n    getters: ["name"]\n  }\n});\n\n// Instantiate View Models\nvar appVm = $.views.viewModels.MovieApp.map(app);\n\n// Background color helper function\nfunction bgColor(index) {\n  return this.selectedIndex() === index\n    ? "yellow"\n    : (index%2 ? "#fdfdfe" : "#efeff2");\n}\n\nbgColor.depends = ["#index", appVm, "selectedIndex"];\n\n// Save copy of initial data, for Undo feature\nvar savedData = app;\n\n// Top level data-linking - bind content to View Models\n$.link(true, ".linkedContent", appVm);\n\n// Detect changes - to enable Submit/Undo buttons, and warn on page navigation\n$.observable(appVm.movies()).observeAll(function() {\n  // If there have been any data changes, clear message and enable Submit and Undo buttons\n  appVm.msg("");\n});\n\n// "Navigate away" behavior\n$(window).on(\'beforeunload\', function(){\n  if (appVm.msg() === "") {\n    return "You have unsaved changes.";\n  }\n});\n\n<!----------------- Data-linked content -------------------> \r\n<div class="linkedContent">\r\n  <button data-link="{on showData}">show data</button>\r\n  <button data-link="{on deleteLast}">delete last language</button>\r\n  <button data-link="{on undo} disabled{:msg() !== \'\'}">Undo</button>\r\n\r\n  <form data-link="{on \'submit\' saveData}">\r\n    <button class="buttons" type="submit" data-link="disabled{:msg() !== \'\'}">Submit Changes</button>\r\n\r\n    <div class="comment">Click to select and edit</div>\r\n    <table>\r\n      <thead><tr>\r\n        <th>Title</th><th>Languages</th>\r\n        <th><span class="addMovie" data-link="{on addMovie}">Add</span></th>\r\n      </tr></thead>\r\n      <tbody class="movies" data-link="{for movies() tmpl=\'#movieTemplate\'}"></tbody>\r\n    </table>\r\n\r\n    <div class="detail" data-link="{for movies()[selectedIndex()] tmpl=\'#detailTemplate\'}"></div>\r\n  </form>\r\n\r\n  <div class="message" data-link="msg()"></div>\r\n</div>\r\n\r\n<!----------------- Templates ------------------->\r\n<script id="movieTemplate" type="text/x-jsrender">\r\n  <tr class="hover" data-link="css-background-color{:~root.bgColor(#index)} {on ~root.select #index}">\r\n    <td>\r\n      <span data-link="#index + 1"></span>:\r\n      <span data-link="title()"></span>\r\n    </td>\r\n    <td>\r\n      {^{for languages()}}\r\n        <div data-link="name()"></div>\r\n      {{/for}}\r\n    </td>\r\n    <td><span class="removeMovie" data-link="{on ~root.removeMovie #index}"></span></td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="detailTemplate" type="text/x-jsrender">\r\n  <div>\r\n    <div class="title">Title:</div>\r\n    <div><input data-link="title()" /></div>\r\n    <div class="title">\r\n      Languages: <span class="addLanguage" data-link="{on addLanguage}">Add</span>\r\n    </div>\r\n    {^{for languages() ~movie=#data}}\r\n      <input data-link="name()" />\r\n      <span class="removeLanguage" data-link="{on ~movie.removeLanguage #index}"></span>\r\n    {{/for}}\r\n  </div>\r\n</script>\r\n\r\n<!----------------- Show data ------------------->\r\n<script id="showData" type="text/x-jsrender">\r\n  <hr/>\r\n  {{for movies}}<div>\r\n    <b>Movie:</b> {{>title}}\r\n    <b>Languages:</b> {{for languages}} {{>name}}{{/for}}\r\n  </div>{{/for}}\r\n</script>\r\n\r\n<div id="console">\r\n</div>\n'}]},"samples/editable":{sections:[{_type:"para",title:"",text:"These four samples explore alternative patterns for creating two-way binding and providing UI for editing data.\nThe UI for all four is visually identical, but the approach to templated rendering and data-linking is different.\n"},{_type:"links",title:"",text:""}]},"samples/tag-controls/tree":{sections:[{_type:"para",title:"",text:"This set of samples shows three variants of a tree tag control:\nThe first uses visible{:...} binding to show and hide tree nodes using display:none. It also allows the user to select/deselect nodes. \nThe second uses {^{if ...}} binding to conditionally render tree nodes.\nThe third adds editability, to allow the user to create or remove nodes, and to modify labels."},{_type:"links",title:"",text:""}]},"samples/tag-controls/validate":{sections:[{_type:"para",title:"",text:"These samples use the custom {{validate}} tag control.\nThis provides validation support to all the two-way bound controls based on form elements, such as text box, dropdown, checkbox, radio button group or textarea, as well as to custom tags such as the {{datepicker}} and {{slider}} controls.\nIn addition, a {{validation}} control adds group validation. See the date-picker validation wizard sample, as an example of using the group validation features: In that sample, the next button is only enabled when all controls on the current pane validate successfully.\n"},{_type:"links",title:"",text:""}]},"samples/tag-controls/jqui/datepicker":{sections:[{_type:"para",title:"",text:"The {{datepicker}} tag integrates the jQuery UI datepicker widget (api).\nThis allows data-linking directly to widget properties, as well as using generic tag functionality such as convert and convertBack.\nIn addition, validation support is obtained, simply by wrapping a {{datepicker}} tag with a {{validate}}.\n"},{_type:"links",title:"",text:""},{_type:"para",title:"",text:"See also: {{timespinner}}\n"}]},"samples/tag-controls/jqui/slider":{sections:[{_type:"para",title:"",text:"The {{slider}} tag integrates the jQuery UI slider widget (api).\nThis allows data-linking directly to widget properties, as well as using generic tag functionality such as convert and convertBack.\nIn addition, validation support is obtained, simply by wrapping a {{slider}} tag with a {{validate}}.\n"},{_type:"links",title:"",text:""}]},"samples/tag-controls/jqui/datepicker/simple":{sections:[{_type:"para",title:"Date picker as pop-up, or displayed inline",text:'Date picker as pop-up, or displayed inline\nBy default the {{datepicker}} is associated with an <input> - and behaves as a pop-up. Alternatively it can be associated with a <div> (either by wrapping a <div> element, or by setting {^{datepicker ... elem="div" ... /}} – in which case it will display inline.\n'},{_type:"sample",title:"",url:"samples/tag-controls/jqui/datepicker/simple/sample",text:'Simple datepicker\n\n{^{datepicker startDate /}}\n\ndatepicker with data-linked properties\n\n{^{datepicker startDate\n  _changeMonth=true\n  ^_maxDate=endDate\n/}}\n\nIn-line datepicker with data-linked properties\n\n{^{datepicker middleDate\n  ^_minDate=startDate\n  ^_maxDate=endDate\n  ^_numberOfMonths=~page.monthsSpan\n}}\n  \n{{/datepicker}}\n\n"use strict";\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  pageOptions = {\n    monthsSpan: 2\n  },\n  model = {\n    startDate: "",\n    endDate: "",\n    middleDate: ""\n  };\n\npageTmpl.link("#page", model, {\n  page: pageOptions\n});\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n<h3>JsViews \'datepicker\' tag controls (using jQuery UI datepicker) &ndash; pop-up or inline</h3>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n  <h4>Choose a start date:</h4>\r\n\r\n  {^{datepicker startDate\r\n    _changeMonth=true\r\n    ^_maxDate=endDate\r\n  /}}\r\n\r\n  <h4>Choose an end date:</h4>\r\n\r\n  {^{datepicker endDate\r\n    ^_minDate=startDate\r\n  /}}\r\n\r\n  <h4>Choose a day during the chosen period:</h4>\r\n\r\n  <p>\r\n    <label>Number of months:</label>\r\n    <select data-link="{:~page.monthsSpan:tonum}">\r\n      <option value="1">1 month</option>\r\n      <option value="2">2 months</option>\r\n      <option value="3">3 months</option>\r\n      <option value="4">4 months</option>\r\n    </select>\r\n  </p>\r\n\r\n  {^{datepicker middleDate\r\n    ^_minDate=startDate\r\n    ^_maxDate=endDate\r\n    ^_numberOfMonths=~page.monthsSpan\r\n  }}\r\n    <div></div>\r\n  {{/datepicker}}\r\n\r\n  <h4>Your chosen day:</h4>\r\n\r\n  <div data-link="middleDate || \'No date chosen!\'" class="chosenday"></div>\r\n\r\n  <h4>Set the middle date directly:</h4>\r\n\r\n  {^{datepicker middleDate\r\n    _showOn= "button"\r\n    _buttonImage="https://jqueryui.com/resources/demos/datepicker/images/calendar.gif"\r\n    _buttonImageOnly= true\r\n    _buttonText= "Choose middle date"\r\n  /}}\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/jqui/datepicker/variants":{sections:[{_type:"sample",url:"samples/tag-controls/jqui/datepicker/variants/sample",text:'Multiple examples of {{datepicker}} syntax…\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n$.datepicker.setDefaults("dateFormat", "mm/dd/yy"); // Set default date format for jQuery UI Datepicker\n\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  pageOptions = {\n    monthsSpan: 2\n  },\n  today = new Date(),\n  model = {\n    startDate: $.datepicker.formatDate("mm/dd/yy", today),\n    endDate: $.datepicker.formatDate("mm/dd/yy", new Date(today.getTime() + 31*24*60*60*1000)),\n    middleDate: ""\n  };\n\npageTmpl.link("#page", model, {\n  page: pageOptions\n});\n<h3>JsViews \'datepicker\' tag control - using jQuery UI datepicker widget: Syntax variants</h3>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n  <h4>Your chosen day:</h4>\r\n\r\n  <div data-link="middleDate || \'No date chosen!\'" class="chosenday"></div>\r\n\r\n  <h4>Number of months:</h4>\r\n  <select data-link="{:~page.monthsSpan:tonum}">\r\n    <option value="1">1 month</option>\r\n    <option value="2">2 months</option>\r\n    <option value="3">3 months</option>\r\n    <option value="4">4 months</option>\r\n  </select>\r\n\r\n  <h3>Variants of the &lcub;{datepicker}&rcub; tag:</h3>\r\n\r\n  <h4>Tag syntax</h4>\r\n\r\n  <pre>&lcub;^{datepicker .../}&rcub;</pre>\r\n\r\n  {^{datepicker middleDate\r\n    ^_minDate=startDate\r\n    ^_maxDate=endDate\r\n    ^_numberOfMonths=~page.monthsSpan\r\n  /}}\r\n\r\n  <h4>Tag syntax specifying \'div\' element and class</h4>\r\n\r\n<pre>\r\n&lcub;^{datepicker\r\n  ...\r\n  class=\'blueborder\'\r\n  elem=\'div\'\r\n/}&rcub;\r\n</pre>\r\n\r\n  {^{datepicker middleDate\r\n    ^_minDate=startDate\r\n    ^_maxDate=endDate\r\n    ^_numberOfMonths=~page.monthsSpan\r\n    class=\'blueborder\'\r\n    elem=\'div\'\r\n  /}}\r\n\r\n  <h4>Tag syntax, wrapping input element:</h4>\r\n\r\n<pre>\r\n&lcub;^{datepicker ...}&rcub;\r\n    &lt;input .../&gt;\r\n&lcub;^{/datepicker}&rcub;\r\n</pre>\r\n\r\n  {^{datepicker middleDate\r\n    ^_minDate=startDate\r\n    ^_maxDate=endDate\r\n    ^_numberOfMonths=~page.monthsSpan\r\n  }}\r\n    <input />\r\n  {{/datepicker}}\r\n\r\n  <h4>Tag syntax, wrapping div element:</h4>\r\n\r\n<pre>\r\n&lcub;^{datepicker ...}&rcub;\r\n    &lt;div ...> ... &lt;/div>\r\n&lcub;^{/datepicker}&rcub;\r\n</pre>\r\n\r\n  {^{datepicker middleDate\r\n    ^_minDate=startDate\r\n    ^_maxDate=endDate\r\n    ^_numberOfMonths=~page.monthsSpan\r\n  }}\r\n    <div></div>\r\n  {{/datepicker}}\r\n\r\n  <h4>Element-based data-link syntax (input):</h4>\r\n\r\n<pre>\r\n&lt;input data-link="{datepicker ...}"/&gt;\r\n</pre>\r\n\r\n  <input data-link="{datepicker middleDate\r\n    ^_minDate=startDate\r\n    ^_maxDate=endDate\r\n    ^_numberOfMonths=~page.monthsSpan\r\n  }" />\r\n\r\n  <h4>Element-based data-link syntax (div):</h4>\r\n\r\n<pre>\r\n&lt;div data-link="{datepicker ...}">&lt;/div>\r\n</pre>\r\n\r\n  <div data-link="{datepicker middleDate\r\n    ^_minDate=startDate\r\n    ^_maxDate=endDate\r\n    ^_numberOfMonths=~page.monthsSpan\r\n  }"></div>\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/jqui/datepicker/with-validation":{sections:[{_type:"sample",url:"samples/tag-controls/jqui/datepicker/with-validation/sample",text:'To add validation to a datepicker, simply wrap with a {{validate}} tag.\n{^{validate startDate\n  required=true\n  ^maxday=endDate\n}}\n  {^{datepicker startDate _numberOfMonths=2 /}}\n{{/validate}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n$.datepicker.setDefaults("dateFormat", "mm/dd/yy"); // Set default date format for jQuery UI Datepicker\n\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\n// Register additional validators for dates\n$.views.tags.validate.validators({\n  minday: {\n    message: "Choose a date after: %cond%",\n    test: function(condition, val) {\n      var vals = val.split("/"),\n        conds = condition.split("/");\n      vals = vals[2]*10000 + vals[0]*100 + vals[1];\n      conds = conds[2]*10000 + conds[0]*100 + conds[1];\n      return vals < conds;\n    }\n  },\n  maxday: {\n    message: "Choose a date before: %cond%",\n    test: function(condition, val) {\n      var vals = val.split("/"),\n        conds = condition.split("/");\n      vals = vals[2]*10000 + vals[0]*100 + vals[1];\n      conds = conds[2]*10000 + conds[0]*100 + conds[1];\n      return vals > conds;\n    }\n  },\n  weekday: {\n    message: "Please choose a weekday!",\n    test: function(condition, val) {\n      var vals = val.split("/"),\n        day = new Date(vals[2], vals[0]-1, vals[1]).getDay();\n      return condition ^ (day > 0 && day < 6);\n    }\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  pageOptions = {\n    monthsSpan: 3\n  },\n  today = new Date(),\n  model = {\n    startDate: $.datepicker.formatDate("mm/dd/yy", today),\n    endDate: "",\n    middleDate: ""\n  };\n\npageTmpl.link("#page", model, {\n  page: pageOptions\n});\n/*! Sample JsViews tag control: {{validate}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n  $.views.tags({\n  validation: {\n    init: function() {\n      this.childValidates = [];\n    },\n    validate: function() {\n      var l = this.childValidates.length,\n          result = true;\n      while (l-- && result !== false) {\n        result = this.childValidates[l].validate();\n      }\n      return result;\n    },\n    clearMessage: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].clearMessage();\n      }\n    },\n    refreshValidates: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].refresh();\n      }\n    },\n    addChild: function(child) {\n      this.childValidates.push(child);\n    },\n    removeChild: function(child) {\n      var l = this.childValidates.length;\n      while (l--) {\n        if (this.childValidates[l] === child) {\n          this.childValidates.splice(l, 1);\n          this.updateIsValid();\n          break;\n        }\n      }\n    },\n    onChildValidate: function() {\n      this.updateIsValid();\n    },\n    updateIsValid: function() {\n      var groupIsValid = true,\n        l = this.childValidates.length;\n      while (l--) {\n        if (!this.childValidates[l].isValid) {\n          groupIsValid = false;\n          break;\n        }\n      }\n      $.observable(this).setProperty("isValid", groupIsValid);\n    },\n    isValid: true,\n    dataBoundOnly: true\n  },\n  validate: {\n    baseTag: "radiogroup",\n    linkedElement: "select,textarea,input",\n    boundProps: ["preventInvalidData"],\n    init: function(tagCtx, linkCtx) {\n      var tag = this;\n      if (tag.radiogroup = tagCtx.props.radiogroup) {\n        tag.baseApply(arguments);\n      } else if (tag._.inline && !tagCtx.content) {\n        tag.template = "<input/>";\n      }\n      tag.validationGroup = this.parents.validation;\n      if (tag.validationGroup) {\n        tag.validationGroup.addChild(this);\n      }\n    },\n    render: function(val) {\n      var ret,\n        tag = this,\n        tagCtx = this.tagCtx;\n      if (tag._.inline) {\n         // Keep same data context for content\n        ret = tagCtx.render(tagCtx.view, true);\n        // For radio buttons provide wrapper for validation messages\n        ret = tag.radiogroup ? ("<div>" + ret + "</div>") : ret;\n        return ret;\n      }\n    },\n    onBind: function(tagCtx, linkCtx) {\n      var targetTag,\n        tag = this,\n        target = tag.linkedElem && tag.linkedElem[0];\n\n      if (targetTag = tag.childTags()[0]) {\n        // {{validate}} may wrap another tag, such as {{slider}}\n        // or {{datepicker}} rather than an element such as <input/>\n        tag.targetTag = targetTag;\n        if (target && $.view(target).tag === targetTag) {\n          tag.linkedElem = undefined;\n        }\n        targetTag.onBeforeChange = function(ev, val) {\n          return tag.onBeforeChange.call(tag, ev, val);\n        };\n      }\n      if (tag.radiogroup) {\n        this.baseApply(arguments);\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        targetTag = tag.targetTag,\n        props = tagCtx.props,\n        arg0 = tag.cvtArgs()[0];\n\n      if (targetTag) {\n        targetTag.updateValue(arg0);\n      }\n\n      if (props.preventInvalidData !== undefined) {\n        tag.preventInvalidData = props.preventInvalidData;\n      } else if (tag.parents.validation) {\n        tag.preventInvalidData = tag.parents.validation.tagCtx.props.preventInvalidData;\n      }\n      if (!tag.messageElem || !tag.messageElem.parentNode) {\n        if (tag.radiogroup) {\n          // messageElem is the div which wraps the group of radio buttons and/or labels\n          tag.messageElem = tag._.inline ? tagCtx.contents("div") : $(linkCtx.elem);\n          tag.messageElem.addClass("radiogroup");\n        } else {\n          if (!tag._.inline && (targetTag = $.views.sub._glt(linkCtx.elem)[0])) {\n            // Scenario with data-link="{targetTag ...}{validate ...}" (both tags data-linked on same linkedElem)\n            tag.targetTag = targetTag;\n          }\n          tag.messageElem = targetTag && (targetTag.displayElem || targetTag.linkedElem)\n            || tag.displayElem || tag.linkedElem;\n        }\n        tag.messageElem.addClass("val-msg");\n      }\n\n      if (!tag.label || !tag.label.parentNode) {\n        tag.label = $("<label class=\\"error\\"></label><br/>").insertAfter(tag.messageElem)[0];\n      }\n      tag.validate(arg0); // Validate initial data\n    },\n    onUpdate: function(ev, eventArgs, tagCtxs) {\n      this.clearMessage();\n      return false; // don\'t rerender\n    },\n    onBeforeChange: function(ev, eventArgs) {\n      if (this.preventInvalidData) {\n        this.validate(eventArgs.value);\n        return this.isValid;\n        // Allow data to be updated to invalid values - unless preventInvalidData set to true\n      }\n    },\n    onDispose: function() {\n      if (this.validationGroup) {\n        this.validationGroup.removeChild(this);\n      }\n    },\n    validate: function(val) {\n      var message, linkedElem, testName, condition,\n        tag = this,\n        props = tag.tagCtx.props,\n        linkedElems = tag.linkedElem;\n\n      if (val === undefined) {\n        // If no val passed in, get current value from linkedElem, and validate that\n        if (tag._.radio && linkedElems) {\n          linkedElems = linkedElems.find("input:checked");\n        }\n        linkedElem = linkedElems && linkedElems[0];\n        val = "";\n        if (linkedElem) {\n          val = linkedElem.type === "checkbox" ? linkedElem.checked : linkedElem.value;\n        } else if (tag.targetTag) {\n          val = tag.targetTag.bndArgs()[0];\n        }\n        val = val || "";\n      }\n      tag.clearMessage();\n\n      // Test the validation conditions, one after the other.\n      this.isValid = true;\n      for (var validator in this.validators) {\n        condition = props[validator];\n        if (condition !== undefined && this.validators[validator].test(condition, val)) {\n          testName = validator;\n          this.isValid = false;\n          break;\n        }\n      }\n      if (!this.isValid) {// A test failed. Show message for first failed test.\n        message = props["msg_" + testName] || this.validators[testName].message;\n        if ($.isFunction(message)) {\n          message = message(condition, val);\n        }\n        message = message.replace(/%cond%/g, condition).replace(/%val%/g, val)\n        if (tag.label.textContent !== undefined) {\n          tag.label.textContent = message;\n        } else {\n          tag.label.innerText = message; // Older IE does not support textContent\n        }\n        tag.messageElem.addClass("invalid");\n      }\n      if (this.validationGroup) {\n        this.validationGroup.onChildValidate();\n      }\n      return this.isValid;\n    },\n    validators: function(validators) {\n      for (var validator in validators) {\n        this.validators[validator] = validators[validator];\n      }\n    },\n    clearMessage: function() {\n      // Clear previous message.\n      var tag = this,\n        label = tag.label;\n      if (tag.messageElem) {\n        tag.messageElem.removeClass("invalid");\n        if (label.textContent !== undefined) {\n          label.textContent = "";\n        } else {\n          label.innerText = ""; // Older IE does not support textContent\n        }\n      }\n    }\n}\n});\n\n$.views.tags.validate.validators({\n  required: {\n    message: "Please provide a value",\n    test: function(condition, val) {\n      return condition && val === "";\n    }\n  },\n  equal: {\n    message: "Value must be %cond%",\n    test: function(condition, val) {\n      return val !== "" + condition;\n    }\n  },\n  checked: {\n    message: function(condition, val) {\n      return "Must be " + (condition ? "checked" : "unchecked");\n    },\n    test: function(condition, val) {\n      return (val && val !== "false") !== condition;\n    }\n  },\n  min: {\n    message: "Minimum: %cond%",\n    test: function(condition, val) {\n      return val < condition;\n    }\n  },\n  max: {\n    message: "Maximum:  %cond%",\n    test: function(condition, val) {\n      return val > condition;\n    }\n  },\n  maxLength: {\n    message: "Maximum length: %cond%",\n    test: function(condition, val) {\n      return val.length > condition;\n    }\n  },\n  minLength: {\n    message: "Minimum length: %cond%",\n    test: function(condition, val) {\n      return val.length < condition;\n    }\n  },\n  regex: {\n    message: "Invalid string format",\n    test: function(condition, val) {\n      var regex = condition.test ? condition : new RegExp(condition);\n      return !regex.test(val);\n    }\n  }\n});\n\n})(this.jQuery);\n\n<h3>JsViews \'datepicker\' tag control (using jQuery UI datepicker) with validation</h3>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Choose a start date:</h4>\r\n  {^{validate startDate\r\n    required=true\r\n    ^maxday=endDate\r\n  }}\r\n    {^{datepicker startDate _numberOfMonths=2 /}}\r\n  {{/validate}}\r\n\r\n  <h4>Choose an end date:</h4>\r\n\r\n  {^{validate endDate\r\n    required=true\r\n    ^minday=startDate\r\n  }}\r\n    {^{datepicker endDate _numberOfMonths=2\r\n    /}}\r\n  {{/validate}}\r\n\r\n  <h4>Choose a weekday during the chosen period:</h4>\r\n\r\n  <p>\r\n    <label>Number of months:</label>\r\n    <select data-link="{:~page.monthsSpan:tonum}">\r\n      <option value="1">1 month</option>\r\n      <option value="2">2 months</option>\r\n      <option value="3">3 months</option>\r\n      <option value="4">4 months</option>\r\n    </select>\r\n  </p>\r\n\r\n  {^{validate middleDate\r\n    required=true\r\n    msg_required=\'Choose a weekday!\'\r\n    weekday=true\r\n    msg_weekday=\'Choose a weekday! %val% is not a weekday...\'\r\n    ^minday=startDate\r\n    ^maxday=endDate\r\n  }}\r\n    {^{datepicker middleDate\r\n      ^_minDate=~root.startDate\r\n      ^_maxDate=~root.endDate\r\n      ^_numberOfMonths=~page.monthsSpan\r\n    }}\r\n      <div></div>\r\n    {{/datepicker}}\r\n  {{/validate}}\r\n\r\n  <h4>Your chosen weekday, between {^{:startDate || \'...\'}} and {^{:endDate || \'...\'}}:</h4>\r\n\r\n  <div data-link="middleDate|| \'No date chosen!\'" class="chosenday"></div>\r\n\r\n  <h4>Set the chosen day directly:</h4>\r\n\r\n  {^{datepicker middleDate /}}\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/jqui/datepicker/with-validation-wizard":{sections:[{_type:"sample",title:"",url:"samples/tag-controls/jqui/datepicker/with-validation-wizard/sample",text:'The sample shows a wizard, using {^{if ...}} ... {{else ...}} ... {{else ...}} ... {{else}} ... {{/if}} to manage displaying the separate wizard steps, one after the other…\nMoving to the next step is not possible until the validate controls on the current step are all valid.\nThis is achieved by wrapping in a validation group {{validation}}.\nThe enabled/disabled state of the Next button is data-linked to the validation.isValid property:\n{^{validation}}\n  ...\n  <button id="next" data-link="... disabled{:!~tag.isValid}">Next</button>\n  ...\n  <h4>Choose a start date:</h4> \n  {^{validate startDate\n    required=true\n    ^maxday=endDate\n  }}\n    {^{datepicker startDate _numberOfMonths=1 /}}\n  {{/validate}}\n  ...\n{{/validation}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n/*! Sample JsViews tag control: {{validate}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n  $.views.tags({\n  validation: {\n    init: function() {\n      this.childValidates = [];\n    },\n    validate: function() {\n      var l = this.childValidates.length,\n          result = true;\n      while (l-- && result !== false) {\n        result = this.childValidates[l].validate();\n      }\n      return result;\n    },\n    clearMessage: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].clearMessage();\n      }\n    },\n    refreshValidates: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].refresh();\n      }\n    },\n    addChild: function(child) {\n      this.childValidates.push(child);\n    },\n    removeChild: function(child) {\n      var l = this.childValidates.length;\n      while (l--) {\n        if (this.childValidates[l] === child) {\n          this.childValidates.splice(l, 1);\n          this.updateIsValid();\n          break;\n        }\n      }\n    },\n    onChildValidate: function() {\n      this.updateIsValid();\n    },\n    updateIsValid: function() {\n      var groupIsValid = true,\n        l = this.childValidates.length;\n      while (l--) {\n        if (!this.childValidates[l].isValid) {\n          groupIsValid = false;\n          break;\n        }\n      }\n      $.observable(this).setProperty("isValid", groupIsValid);\n    },\n    isValid: true,\n    dataBoundOnly: true\n  },\n  validate: {\n    baseTag: "radiogroup",\n    linkedElement: "select,textarea,input",\n    boundProps: ["preventInvalidData"],\n    init: function(tagCtx, linkCtx) {\n      var tag = this;\n      if (tag.radiogroup = tagCtx.props.radiogroup) {\n        tag.baseApply(arguments);\n      } else if (tag._.inline && !tagCtx.content) {\n        tag.template = "<input/>";\n      }\n      tag.validationGroup = this.parents.validation;\n      if (tag.validationGroup) {\n        tag.validationGroup.addChild(this);\n      }\n    },\n    render: function(val) {\n      var ret,\n        tag = this,\n        tagCtx = this.tagCtx;\n      if (tag._.inline) {\n         // Keep same data context for content\n        ret = tagCtx.render(tagCtx.view, true);\n        // For radio buttons provide wrapper for validation messages\n        ret = tag.radiogroup ? ("<div>" + ret + "</div>") : ret;\n        return ret;\n      }\n    },\n    onBind: function(tagCtx, linkCtx) {\n      var targetTag,\n        tag = this,\n        target = tag.linkedElem && tag.linkedElem[0];\n\n      if (targetTag = tag.childTags()[0]) {\n        // {{validate}} may wrap another tag, such as {{slider}}\n        // or {{datepicker}} rather than an element such as <input/>\n        tag.targetTag = targetTag;\n        if (target && $.view(target).tag === targetTag) {\n          tag.linkedElem = undefined;\n        }\n        targetTag.onBeforeChange = function(ev, val) {\n          return tag.onBeforeChange.call(tag, ev, val);\n        };\n      }\n      if (tag.radiogroup) {\n        this.baseApply(arguments);\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        targetTag = tag.targetTag,\n        props = tagCtx.props,\n        arg0 = tag.cvtArgs()[0];\n\n      if (targetTag) {\n        targetTag.updateValue(arg0);\n      }\n\n      if (props.preventInvalidData !== undefined) {\n        tag.preventInvalidData = props.preventInvalidData;\n      } else if (tag.parents.validation) {\n        tag.preventInvalidData = tag.parents.validation.tagCtx.props.preventInvalidData;\n      }\n      if (!tag.messageElem || !tag.messageElem.parentNode) {\n        if (tag.radiogroup) {\n          // messageElem is the div which wraps the group of radio buttons and/or labels\n          tag.messageElem = tag._.inline ? tagCtx.contents("div") : $(linkCtx.elem);\n          tag.messageElem.addClass("radiogroup");\n        } else {\n          if (!tag._.inline && (targetTag = $.views.sub._glt(linkCtx.elem)[0])) {\n            // Scenario with data-link="{targetTag ...}{validate ...}" (both tags data-linked on same linkedElem)\n            tag.targetTag = targetTag;\n          }\n          tag.messageElem = targetTag && (targetTag.displayElem || targetTag.linkedElem)\n            || tag.displayElem || tag.linkedElem;\n        }\n        tag.messageElem.addClass("val-msg");\n      }\n\n      if (!tag.label || !tag.label.parentNode) {\n        tag.label = $("<label class=\\"error\\"></label><br/>").insertAfter(tag.messageElem)[0];\n      }\n      tag.validate(arg0); // Validate initial data\n    },\n    onUpdate: function(ev, eventArgs, tagCtxs) {\n      this.clearMessage();\n      return false; // don\'t rerender\n    },\n    onBeforeChange: function(ev, eventArgs) {\n      if (this.preventInvalidData) {\n        this.validate(eventArgs.value);\n        return this.isValid;\n        // Allow data to be updated to invalid values - unless preventInvalidData set to true\n      }\n    },\n    onDispose: function() {\n      if (this.validationGroup) {\n        this.validationGroup.removeChild(this);\n      }\n    },\n    validate: function(val) {\n      var message, linkedElem, testName, condition,\n        tag = this,\n        props = tag.tagCtx.props,\n        linkedElems = tag.linkedElem;\n\n      if (val === undefined) {\n        // If no val passed in, get current value from linkedElem, and validate that\n        if (tag._.radio && linkedElems) {\n          linkedElems = linkedElems.find("input:checked");\n        }\n        linkedElem = linkedElems && linkedElems[0];\n        val = "";\n        if (linkedElem) {\n          val = linkedElem.type === "checkbox" ? linkedElem.checked : linkedElem.value;\n        } else if (tag.targetTag) {\n          val = tag.targetTag.bndArgs()[0];\n        }\n        val = val || "";\n      }\n      tag.clearMessage();\n\n      // Test the validation conditions, one after the other.\n      this.isValid = true;\n      for (var validator in this.validators) {\n        condition = props[validator];\n        if (condition !== undefined && this.validators[validator].test(condition, val)) {\n          testName = validator;\n          this.isValid = false;\n          break;\n        }\n      }\n      if (!this.isValid) {// A test failed. Show message for first failed test.\n        message = props["msg_" + testName] || this.validators[testName].message;\n        if ($.isFunction(message)) {\n          message = message(condition, val);\n        }\n        message = message.replace(/%cond%/g, condition).replace(/%val%/g, val)\n        if (tag.label.textContent !== undefined) {\n          tag.label.textContent = message;\n        } else {\n          tag.label.innerText = message; // Older IE does not support textContent\n        }\n        tag.messageElem.addClass("invalid");\n      }\n      if (this.validationGroup) {\n        this.validationGroup.onChildValidate();\n      }\n      return this.isValid;\n    },\n    validators: function(validators) {\n      for (var validator in validators) {\n        this.validators[validator] = validators[validator];\n      }\n    },\n    clearMessage: function() {\n      // Clear previous message.\n      var tag = this,\n        label = tag.label;\n      if (tag.messageElem) {\n        tag.messageElem.removeClass("invalid");\n        if (label.textContent !== undefined) {\n          label.textContent = "";\n        } else {\n          label.innerText = ""; // Older IE does not support textContent\n        }\n      }\n    }\n}\n});\n\n$.views.tags.validate.validators({\n  required: {\n    message: "Please provide a value",\n    test: function(condition, val) {\n      return condition && val === "";\n    }\n  },\n  equal: {\n    message: "Value must be %cond%",\n    test: function(condition, val) {\n      return val !== "" + condition;\n    }\n  },\n  checked: {\n    message: function(condition, val) {\n      return "Must be " + (condition ? "checked" : "unchecked");\n    },\n    test: function(condition, val) {\n      return (val && val !== "false") !== condition;\n    }\n  },\n  min: {\n    message: "Minimum: %cond%",\n    test: function(condition, val) {\n      return val < condition;\n    }\n  },\n  max: {\n    message: "Maximum:  %cond%",\n    test: function(condition, val) {\n      return val > condition;\n    }\n  },\n  maxLength: {\n    message: "Maximum length: %cond%",\n    test: function(condition, val) {\n      return val.length > condition;\n    }\n  },\n  minLength: {\n    message: "Minimum length: %cond%",\n    test: function(condition, val) {\n      return val.length < condition;\n    }\n  },\n  regex: {\n    message: "Invalid string format",\n    test: function(condition, val) {\n      var regex = condition.test ? condition : new RegExp(condition);\n      return !regex.test(val);\n    }\n  }\n});\n\n})(this.jQuery);\n\n"use strict";\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\n// Register additional validators for dates\n$.views.tags.validate.validators({\n  minday: {\n    message: "Choose a date after: %cond%",\n    test: function(condition, val) {\n      var vals = val.split("/"),\n        conds = condition.split("/");\n      vals = vals[2]*10000 + vals[0]*100 + vals[1];\n      conds = conds[2]*10000 + conds[0]*100 + conds[1];\n      return vals < conds;\n    }\n  },\n  maxday: {\n    message: "Choose a date before: %cond%",\n    test: function(condition, val) {\n      var vals = val.split("/"),\n        conds = condition.split("/");\n      vals = vals[2]*10000 + vals[0]*100 + vals[1];\n      conds = conds[2]*10000 + conds[0]*100 + conds[1];\n      return vals > conds;\n    }\n  },\n  weekday: {\n    message: "Please choose a weekday!",\n    test: function(condition, val) {\n      var vals = val.split("/"),\n        day = new Date(vals[2], vals[0]-1, vals[1]).getDay();\n      return condition ^ (day > 0 && day < 6);\n    }\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  pageOptions = {\n    pane: 0,\n    monthsSpan: 2\n  },\n  today = new Date(),\n  model = {\n    startDate: $.datepicker.formatDate("mm/dd/yy", today),\n    endDate: "",\n    middleDate: ""\n  };\n\npageTmpl.link("#page", model, {\n  page: pageOptions\n})\n.on("click", "#next", function() {\n  if ($.view(this).ctx.tag.validate()) {\n    $.observable(pageOptions).setProperty("pane", pageOptions.pane + 1);\n  }\n})\n.on("click", "#prev", function() {\n  $.observable(pageOptions).setProperty("pane", pageOptions.pane - 1);\n});\n\n<h3>JsViews \'datepicker\' tag control (using jQuery UI datepicker) with validation</h3>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n{^{validation}}\r\n<div class="wizard">\r\n  <button id="next"\r\n    data-link="css-visibility{:~page.pane!==2?\'visible\':\'hidden\'} disabled{:!~tag.isValid}">\r\n    Next</button>\r\n  <button id="prev"\r\n    data-link="css-visibility{:~page.pane?\'visible\':\'hidden\'}">\r\n    Back</button>\r\n  {^{if ~page.pane === 0 }}\r\n\r\n    <br/><br/>\r\n    <h4>Choose a start date:</h4>\r\n    {^{validate startDate\r\n      required=true\r\n      ^maxday=endDate\r\n    }}\r\n      {^{datepicker startDate _numberOfMonths=1 /}}\r\n    {{/validate}}\r\n\r\n    <h4>Choose an end date:</h4>\r\n\r\n    {^{validate endDate\r\n      required=true\r\n      ^minday=startDate\r\n    }}\r\n      {^{datepicker endDate _numberOfMonths=2 /}}\r\n    {{/validate}}\r\n\r\n  {{else ~page.pane === 1 }}\r\n\r\n    <h4>Choose a weekday during the chosen period:</h4>\r\n\r\n    <p>\r\n      <label>Number of months:</label>\r\n      <select data-link="{:~page.monthsSpan:tonum}">\r\n        <option value="1">1 month</option>\r\n        <option value="2">2 months</option>\r\n      </select>\r\n    </p>\r\n\r\n    {^{validate middleDate\r\n      required=true\r\n      msg_required=\'Choose a weekday!\'\r\n      weekday=true\r\n      msg_weekday=\'Choose a weekday! %val% is not a weekday...\'\r\n      ^minday=startDate\r\n      ^maxday=endDate\r\n    }}\r\n      {^{datepicker middleDate\r\n        ^_minDate=~root.startDate\r\n        ^_maxDate=~root.endDate\r\n        ^_numberOfMonths=~page.monthsSpan\r\n      }}\r\n        <div></div>\r\n      {{/datepicker}}\r\n    {{/validate}}\r\n\r\n  {{else}}\r\n\r\n    <br/><br/>\r\n    <h4>Your chosen weekday, between {^{:startDate}} and {^{:endDate}}:</h4>\r\n\r\n    <div data-link="middleDate" class="chosenday"></div>\r\n\r\n  {{/if}}\r\n</div>\r\n{{/validation}}\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/tree/visible-binding":{sections:[{_type:"para",title:"",text:"This is the first of three variants of a tree tag control. This version uses visible{:...} binding to show and hide tree nodes using display:none.\n"},{_type:"sample",url:"samples/tag-controls/tree/visible-binding/sample",text:'The data is a hierarchy of node objects each of which has a name property and an optional folder property containing child data nodes:\nvar rootFolder = {\n  name: "Categories", folders: [\n    {name: "Drama", folders: [\n      {name: "Courtroom"},\n      {name: "Political"}\n    ]},\n    {name: "Classic", folders: [\n      ...\n    ]}\n  ]};\n\nThe {{tree}} tag is a tag control for a node in the tree. It renders a node in the data hierarchy, and has a boolean expanded property.\n$.views.tags({\n  tree: {\n    onBind: function() {\n      var self = this;\n      self.contents("li").first()\n        .on("click", ".toggle", function() {\n          self.toggle();\n        });\n    },\n    template: "<li>...",\n\n    //PROPERTIES\n    expanded: false, // default to unexpanded\n\n    //METHODS\n    toggle: function() {\n      $.observable(this).setProperty("expanded", !this.expanded);\n    },\n    ...\n  }\n});\n\nIt uses a template which recursively renders the child data nodes using the same data-linked tag: {^{tree}}, and data-links to the expanded property of the control (tag instance).\n<li>\n  ...\n  {{>name}}\n</li>\n{{if folders}}\n  <li data-link="visible{:~tag.expanded}">\n    <ul>\n      {{for folders}}\n        {^{tree/}}\n      {{/for}}\n    </ul>\n  </li>\n{{/if}}\n\nThis version of the {{tree}} tag binds using the data-link visible target  to show or hide the child nodes.\n<li data-link="visible{:~tag.expanded}">\n\n\n"use strict";\n/* Hierarchy of named folders */\nvar rootFolder = {\n  name: "Categories", folders: [\n    {name: "Drama", folders: [\n      {name: "Courtroom"},\n      {name: "Political"}\n    ]},\n    {name: "Classic", folders: [\n      {name: "Musicals", folders: [\n        {name: "Jazz"},\n        {name: "R&B/Soul"}\n      ]}\n    ]}\n  ]};\n\nvar pageTmpl = $.templates("#pageTemplate");\n\npageTmpl.link("#pageContent", rootFolder);\n\n/*! Sample JsViews tag control: {{tree}} control using visible{...} binding v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n$.views.tags({\n  tree: {\n    onBind: function() {\n      var self = this;\n      self.contents("li").first()\n        .on("click", ".toggle", function() {\n          self.toggle();\n        });\n    },\n    template: \'<li>\' +\n      \'{{if folders && folders.length}}\' +\n        \'<span class="toggle">{^{:~tag.expanded ? "-" : "+"}}</span>\' +\n      \'{{else}}\' +\n        \'<span class="spacer">&bull;</span>\' +\n      \'{{/if}}\' +\n      \'{{>name}}\' +\n    \'</li>\' +\n    \'{{if folders}}\' +\n      \'<li data-link="visible{:~tag.expanded}">\' +\n        \'<ul>\' +\n          \'{{for folders}}\' +\n            \'{^{tree/}}\' +\n          \'{{/for}}\' +\n        \'</ul>\' +\n      \'</li>\' +\n    \'{{/if}}\',\n\n    //PROPERTIES\n    expanded: false, // default to unexpanded\n\n    //METHODS\n    toggle: function() {\n      $.observable(this).setProperty("expanded", !this.expanded);\n    },\n    dataBoundOnly: true\n  }\n});\n\n})(this.jQuery);\n\n<h3>JsViews \'tree\' tag control: The {{tree}} tag</h3>\r\n<div class="subhead">Dynamic content blocks use <em>visible{:...}</em> binding</div>\r\n\r\n<div id="pageContent" class="folderView"></div>\r\n\r\n<script id="pageTemplate" type="text/x-jsrender">\r\n  <ul>{^{tree/}}</ul>\r\n</script>\n'}]},"samples/tag-controls/tree/if-binding":{sections:[{_type:"para",title:"",text:"This is the second of three variants of a tree tag control. This version uses {^{if ...}} binding to conditionally render tree nodes.\n"},{_type:"sample",url:"samples/tag-controls/tree/if-binding/sample",text:'The data is the same hierarchy of node objects used in the previous sample:\nvar rootFolder = {\n  name: "Categories", folders: [\n    {name: "Drama", folders: [\n      {name: "Courtroom"},\n      {name: "Political"}\n    ]},\n    {name: "Classic", folders: [\n      ...\n    ]}\n  ]};\n\nThe {{tree}} tag is a tag control for a node in the tree. It renders a node in the data hierarchy, and sets a boolean expanded property on the data node.\n$.views.tags({\n  tree: {\n    onBind: function() {\n      var self = this;\n      self.contents("li").first()\n        .on("click", ".toggle", function() {\n          self.toggle();\n        });\n    },\n    template: "<li>...",\n\n    //METHODS\n    toggle: function() {\n      $.observable(this.view.data).setProperty("expanded", !this.view.data.expanded);\n    },\n    ...\n  }\n});\n\nIt has a template which with a {^{if expanded }} section which renders the child data nodes only if expanded === true, using the same data-linked tag: {^{tree}}.\n<li>\n  ...\n  {{>name}}\n</li>\n{^{if expanded}}\n  <li>\n    <ul>\n      {{for folders}}\n        {^{tree/}}\n      {{/for}}\n    </ul>\n  </li>\n{{/if}}\n\n\n"use strict";\n/* Hierarchy of named folders */\nvar rootFolder = {\n  name: "Categories", folders: [\n    {name: "Drama", folders: [\n      {name: "Courtroom"},\n      {name: "Political"}\n    ]},\n    {name: "Classic", folders: [\n      {name: "Musicals", folders: [\n        {name: "Jazz"},\n        {name: "R&B/Soul"}\n      ]}\n    ]}\n  ]};\n\nvar pageTmpl = $.templates("#pageTemplate");\n\npageTmpl.link("#pageContent", rootFolder);\n\n/*! Sample JsViews tag control: {{tree}} control using {^{if}} binding v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n$.views.tags({\n  tree: {\n    onBind: function() {\n      var self = this;\n      self.contents("li").first()\n        .on("click", ".toggle", function() {\n          self.toggle();\n        });\n    },\n    template: \'<li>\' +\n      \'{{if folders && folders.length}}\' +\n        \'<span class="toggle">{^{:expanded ? "-" : "+"}}</span>\' +\n      \'{{else}}\' +\n        \'<span class="spacer">&bull;</span>\' +\n      \'{{/if}}\' +\n      \'{{>name}}\' +\n    \'</li>\' +\n    \'{^{if expanded}}\' +\n      \'<li>\' +\n        \'<ul>\' +\n          \'{{for folders}}\' +\n            \'{^{tree/}}\' +\n          \'{{/for}}\' +\n        \'</ul>\' +\n      \'</li>\' +\n    \'{{/if}}\',\n\n    //METHODS\n    toggle: function() {\n      var data = this.tagCtx.contentView.data;\n      $.observable(data).setProperty("expanded", !data.expanded);\n    },\n    dataBoundOnly: true\n  }\n});\n\n})(this.jQuery);\n\n<h3>JsViews \'tree\' tag control: The {{tree}} tag</h3>\r\n<div class="subhead">Dynamic content blocks use <em>{^{if}}</em> binding</div>\r\n\r\n<div id="pageContent" class="folderView"></div>\r\n\r\n<script id="pageTemplate" type="text/x-jsrender">\r\n  <ul>{^{tree/}}</ul>\r\n</script>\n'}]},"samples/tag-controls/tree/editable":{sections:[{_type:"para",title:"",text:"This is the third of three variants of a tree tag control. This version adds editability, to allow the user to create or remove nodes, and to modify labels.\n"},{_type:"sample",url:"samples/tag-controls/tree/editable/sample",text:'This version builds on the previous sample, and adds editability:\nCode:\n$.views.tags({\n  editableTree: {\n    ...\n    template: "#editableTreeTemplate",\n\n    //METHODS\n    ...\n    remove: function() {\n      var parentFolders = this.parent.view.data.folders,\n        index = this.tagCtx.view.index;\n      $.observable(parentFolders).remove(index);\n    },\n    addFolder: function() {\n      $.observable(this.view.data.folders).insert({\n        name: "new folder",\n        folders: []\n      });\n      $.observable(this.view.data).setProperty("expanded", true);\n    },    ...\n  }\n});\n\neditableTreeTemplate:\n<li>\n  ...\n  {^{if ~tag.tagCtx.props.editable}}\n    <input data-link="name" />\n    <span data-link="{on ~tag.addFolder}" class="add">add</span>\n    {^{if ~tag.parent && ~tag.parent.tagName===\'editableTree\'}}\n      {{!-- Don\'t allow removing the top-level tree control --}}\n      <span data-link="{on ~tag.remove}" class="remove"></span>\n    {{/if}}\n  {{else}}\n    {^{>name}}\n  {{/if}}\n</li>\n{^{if expanded}}\n  ...\n{{/if}}\n\n\n"use strict";\n$.views.tags({\n  tree: {\n    template: "#treeTemplate",\n\n    //METHODS\n    toggle: function() {\n      var data = this.tagCtx.contentView.data;\n      $.observable(data).setProperty("expanded", !data.expanded);\n    },\n    dataBoundOnly: true\n  },\n\n  editableTree: {\n    template: "#editableTreeTemplate",\n\n    //METHODS\n    toggle: function() {\n      var data = this.tagCtx.contentView.data;\n      $.observable(data).setProperty("expanded", !data.expanded);\n    },\n    remove: function() {\n      var parentFolders = this.parent.tagCtx.contentView.data.folders,\n        index = this.tagCtx.view.index;\n      $.observable(parentFolders).remove(index);\n    },\n    addFolder: function() {\n      var data = this.tagCtx.contentView.data;\n      $.observable(data.folders).insert({\n        name: "new folder",\n        folders: []\n      });\n      $.observable(data).setProperty("expanded", true);\n    },\n    dataBoundOnly: true\n  }\n});\n\n/* Hierarchy of named folders */\nvar rootFolder = {\n  editable: true,\n  name: "Categories", folders: [\n    {name: "Drama", folders: []}\n  ]};\n\nvar pageTmpl = $.templates("#pageTemplate");\n\npageTmpl.link("#pageContent", rootFolder);\n\n<h3>JsViews \'editable tree\' tag control: The {{editableTree}} tag</h3>\r\n<div class="subhead">Dynamic content blocks use <em>{^{if}}</em> binding</div>\r\n\r\n<div class="folderView" id="pageContent"></div>\r\n\r\n<script id="pageTemplate" type="text/x-jsrender">\r\n  <div class="left">\r\n    <div class="label">\r\n      <label><input type="checkbox" data-link="editable" /> Editable</label>\r\n    </div>\r\n    <ul>{^{editableTree ^editable=editable/}}</ul>\r\n  </div>\r\n  <div class="right">\r\n    <br/>\r\n    <ul>{^{tree/}}</ul>\r\n  </div>\r\n</script>\r\n\r\n<script id="treeTemplate" type="text/x-jsrender">\r\n  <li>\r\n    {^{if folders && folders.length}}\r\n      <span data-link="{on ~tag.toggle}" class="toggle">{^{:expanded ? \'-\' : \'+\'}}</span>\r\n    {{else}}\r\n      <span class="spacer">&bull;</span>\r\n    {{/if}}\r\n    {^{>name}}\r\n  </li>\r\n  {^{if expanded}}\r\n    <li>\r\n      <ul>\r\n        {^{for folders}}\r\n          {^{tree/}}\r\n        {{/for}}\r\n      </ul>\r\n    </li>\r\n  {{/if}}\r\n</script>\r\n\r\n<script id="editableTreeTemplate" type="text/x-jsrender">\r\n  <li>\r\n    {^{if folders && folders.length}}\r\n      <span data-link="{on ~tag.toggle}" class="toggle">{^{:expanded ? \'-\' : \'+\'}}</span>\r\n    {{else}}\r\n      <span class="spacer">&bull;</span>\r\n    {{/if}}\r\n    {^{if ~tag.tagCtx.props.editable}}\r\n      <input data-link="name" />\r\n      <span data-link="{on ~tag.addFolder}" class="add">add</span>\r\n      {^{if ~tag.parent && ~tag.parent.tagName===\'editableTree\'}}\r\n        {{!-- Don\'t allow removing the top-level tree control --}}\r\n        <span data-link="{on ~tag.remove}" class="remove"></span>\r\n      {{/if}}\r\n    {{else}}\r\n      {^{>name}}\r\n    {{/if}}\r\n  </li>\r\n  {^{if expanded}}\r\n    <li>\r\n      <ul>\r\n        {^{for folders}}\r\n          {^{editableTree editable=~tag.tagCtx.props.editable/}}\r\n        {{/for}}\r\n      </ul>\r\n    </li>\r\n  {{/if}}\r\n</script>\n'}]},"samples/tag-controls/jqui/slider/simple":{sections:[{_type:"para",title:"",text:"Here is a sample using data-linking to instantiate and bind a slider control, as well as SVG content, within a template:\n"},{_type:"sample",title:"Slider control",url:"samples/tag-controls/jqui/slider/simple/sample",text:'Slider control\nSimple slider\n\n{^{slider size /}}\n\nSlider with initialized properties\n{^{slider size _range=\'min\' _min=1 _max=200 width=400 _orientation=\'vertical\' /}}\n\nor\n<div data-link="{slider size _range=\'min\' _min=1 max=200 _orientation=\'vertical\' width=400}"></div>\n\n\nData-linking to SVG content\n\n\n  \n  ...\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    size: 150\n  };\n\npageTmpl.link("#page", model);\n<h3>JsViews \'slider\' tag control (using jQuery UI slider): {{slider}} tag, with data-linked SVG elements</h3>\r\n\r\n<h4>Data-linked SVG:</h4>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n<svg data-link="css-width{: 2 + size*2}" class="svg-circles">\r\n  <circle data-link="r{:size} cx{:size + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="green"></circle>\r\n  <circle data-link="r{:size*3/4} cx{:size + 1} cy{:102 - size*3/4}"\r\n    class="svg-circle" stroke="#aaa"></circle>\r\n  <circle data-link="r{:size/2} cx{:size + 1} cy{:size/2}"\r\n    class="svg-circle" stroke="#aaa"></circle>\r\n  <circle data-link="r{:size/4} cx{:size + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="blue"></circle>\r\n</svg>\r\n\r\n<h4>Slider</h4>\r\n\r\n{^{slider size _range=\'min\' _min=1 _max=200 width=400 /}}\r\n\r\n<h4>Size:</h4>\r\n\r\n<input type="text" data-link="{:size:tonum}" />\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"",text:"Here is another version of the above sample, using top-level data-linking to instantiate and bind the slider control and the SVG content (within top-level page content rather than in a rendered template):\n"},{_type:"sample",title:'Top-level data-link="{slider ...}"',url:"samples/tag-controls/jqui/slider/simple-toplevel/sample",text:'Top-level data-link="{slider ...}"\nSlider with initialized properties (top-level data-linking)\n<div data-link="{slider size _range=\'min\' _min=1 max=200 _orientation=\'vertical\' width=400}"></div>\n\n\nData-linking to SVG content\n\n\n  \n  ...\n\n\nActivate data-linking \n\n$.link(true, "body", model);\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\nvar model = {\n    size: 150\n  };\n\n$.link(true, "body", model);\n<h3>JsViews \'slider\' tag control. Top-level binding: data-link="{slider}" and data-linked SVG elements</h3>\r\n\r\n<h4>Top-level data-linked SVG:</h4>\r\n\r\n<svg data-link="css-width{: 2 + size*2}" class="svg-circles">\r\n  <circle data-link="r{:size} cx{:size + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="green"></circle>\r\n  <circle data-link="r{:size*3/4} cx{:size + 1} cy{:102 - size*3/4}"\r\n    class="svg-circle" stroke="#aaa"></circle>\r\n  <circle data-link="r{:size/2} cx{:size + 1} cy{:size/2}"\r\n    class="svg-circle" stroke="#aaa"></circle>\r\n  <circle data-link="r{:size/4} cx{:size + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="blue"></circle>\r\n</svg>\r\n\r\n<h4>Top-level data-linked slider</h4>\r\n\r\n<div data-link="{slider size _range=\'min\' _min=1 _max=200 width=400}"></div>\r\n\r\n<h4>Size:</h4>\r\n\r\n<input type="text" data-link="{:size:tonum}" />\n'
}]},"samples/tag-controls/jqui/slider/variants":{sections:[{_type:"sample",url:"samples/tag-controls/jqui/slider/variants/sample",text:'Multiple examples of {{slider}} syntax…\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    size: 150\n  };\n\npageTmpl.link("#page", model);\n<h3>JsViews \'slider\' tag control - using jQuery UI slider widget - with data-linked SVG elements</h3>\r\n\r\n<h5>Data-linked SVG:</h5>\r\n\r\n<pre>\r\n&lt;svg data-link="...">\r\n    &lt;circle data-link="..."\r\n    ...\r\n</pre>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<svg data-link="css-width{: 2 + size*2}" class="svg-circles">\r\n  <circle data-link="r{:size} cx{:size + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="green"></circle>\r\n  <circle data-link="r{:size*3/4} cx{:size + 1} cy{:102 - size*3/4}"\r\n    class="svg-circle" stroke="#aaa"></circle>\r\n  <circle data-link="r{:size/2} cx{:size + 1} cy{:size/2}"\r\n    class="svg-circle" stroke="#aaa"></circle>\r\n  <circle data-link="r{:size/4} cx{:size + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="blue"></circle>\r\n</svg>\r\n\r\n<h3>Variants of the &lcub;{slider}&rcub; tag:</h3>\r\n\r\n<h4>Tag syntax</h4>\r\n\r\n<pre>&lcub;^{slider size .../}&rcub;</pre>\r\n\r\n{^{slider size _range=\'min\' _min=1 _max=200 width=400 class="main-slider"/}}\r\n\r\n<h4>Tag syntax, wrapping element:</h4>\r\n\r\n<pre>\r\n&lcub;^{slider size ...}&rcub;\r\n    &lt;div ...> ... &lt;/div>\r\n&lcub;^{/slider}&rcub;\r\n</pre>\r\n\r\n{^{slider size _range=\'min\' _min=1 _max=200 width=400}}\r\n  <div class="main-slider"></div>\r\n{{/slider}}\r\n\r\n<h4>Element-based data-link syntax:</h4>\r\n\r\n<pre>\r\n&lt;div data-link="{slider size ...}">&lt;/div>\r\n</pre>\r\n\r\n<div data-link="{slider size _range=\'min\' _min=1 _max=200 width=400}" class="main-slider"></div>\r\n\r\n<h4>Size:</h4>\r\n\r\n<input type="text" data-link="{:size:tonum}" />\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/jqui/slider/with-validation":{sections:[{_type:"sample",url:"samples/tag-controls/jqui/slider/with-validation/sample",text:'To add validation to a slider, simply wrap with a {{validate}} tag.\n{^{validate size\n  min=20\n  max=150\n  msg_min="Min size: %cond%"\n  msg_max="Max size: %cond%"\n  preventInvalidData=~page.noInvalidData\n}}\n  {^{slider size _orientation=\'vertical\' ... /}}\n{{/validate}}\n\nor\n{^{validate size\n  min=50 max=100\n  msg_min="Min size: %cond%"\n  msg_max="Max size: %cond%"\n  preventInvalidData=~page.noInvalidData\n}}\n  <div data-link="{slider size _orientation=\'vertical\' ...}"></div>\n{{/validate}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n/*! Sample JsViews tag control: {{validate}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n  $.views.tags({\n  validation: {\n    init: function() {\n      this.childValidates = [];\n    },\n    validate: function() {\n      var l = this.childValidates.length,\n          result = true;\n      while (l-- && result !== false) {\n        result = this.childValidates[l].validate();\n      }\n      return result;\n    },\n    clearMessage: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].clearMessage();\n      }\n    },\n    refreshValidates: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].refresh();\n      }\n    },\n    addChild: function(child) {\n      this.childValidates.push(child);\n    },\n    removeChild: function(child) {\n      var l = this.childValidates.length;\n      while (l--) {\n        if (this.childValidates[l] === child) {\n          this.childValidates.splice(l, 1);\n          this.updateIsValid();\n          break;\n        }\n      }\n    },\n    onChildValidate: function() {\n      this.updateIsValid();\n    },\n    updateIsValid: function() {\n      var groupIsValid = true,\n        l = this.childValidates.length;\n      while (l--) {\n        if (!this.childValidates[l].isValid) {\n          groupIsValid = false;\n          break;\n        }\n      }\n      $.observable(this).setProperty("isValid", groupIsValid);\n    },\n    isValid: true,\n    dataBoundOnly: true\n  },\n  validate: {\n    baseTag: "radiogroup",\n    linkedElement: "select,textarea,input",\n    boundProps: ["preventInvalidData"],\n    init: function(tagCtx, linkCtx) {\n      var tag = this;\n      if (tag.radiogroup = tagCtx.props.radiogroup) {\n        tag.baseApply(arguments);\n      } else if (tag._.inline && !tagCtx.content) {\n        tag.template = "<input/>";\n      }\n      tag.validationGroup = this.parents.validation;\n      if (tag.validationGroup) {\n        tag.validationGroup.addChild(this);\n      }\n    },\n    render: function(val) {\n      var ret,\n        tag = this,\n        tagCtx = this.tagCtx;\n      if (tag._.inline) {\n         // Keep same data context for content\n        ret = tagCtx.render(tagCtx.view, true);\n        // For radio buttons provide wrapper for validation messages\n        ret = tag.radiogroup ? ("<div>" + ret + "</div>") : ret;\n        return ret;\n      }\n    },\n    onBind: function(tagCtx, linkCtx) {\n      var targetTag,\n        tag = this,\n        target = tag.linkedElem && tag.linkedElem[0];\n\n      if (targetTag = tag.childTags()[0]) {\n        // {{validate}} may wrap another tag, such as {{slider}}\n        // or {{datepicker}} rather than an element such as <input/>\n        tag.targetTag = targetTag;\n        if (target && $.view(target).tag === targetTag) {\n          tag.linkedElem = undefined;\n        }\n        targetTag.onBeforeChange = function(ev, val) {\n          return tag.onBeforeChange.call(tag, ev, val);\n        };\n      }\n      if (tag.radiogroup) {\n        this.baseApply(arguments);\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        targetTag = tag.targetTag,\n        props = tagCtx.props,\n        arg0 = tag.cvtArgs()[0];\n\n      if (targetTag) {\n        targetTag.updateValue(arg0);\n      }\n\n      if (props.preventInvalidData !== undefined) {\n        tag.preventInvalidData = props.preventInvalidData;\n      } else if (tag.parents.validation) {\n        tag.preventInvalidData = tag.parents.validation.tagCtx.props.preventInvalidData;\n      }\n      if (!tag.messageElem || !tag.messageElem.parentNode) {\n        if (tag.radiogroup) {\n          // messageElem is the div which wraps the group of radio buttons and/or labels\n          tag.messageElem = tag._.inline ? tagCtx.contents("div") : $(linkCtx.elem);\n          tag.messageElem.addClass("radiogroup");\n        } else {\n          if (!tag._.inline && (targetTag = $.views.sub._glt(linkCtx.elem)[0])) {\n            // Scenario with data-link="{targetTag ...}{validate ...}" (both tags data-linked on same linkedElem)\n            tag.targetTag = targetTag;\n          }\n          tag.messageElem = targetTag && (targetTag.displayElem || targetTag.linkedElem)\n            || tag.displayElem || tag.linkedElem;\n        }\n        tag.messageElem.addClass("val-msg");\n      }\n\n      if (!tag.label || !tag.label.parentNode) {\n        tag.label = $("<label class=\\"error\\"></label><br/>").insertAfter(tag.messageElem)[0];\n      }\n      tag.validate(arg0); // Validate initial data\n    },\n    onUpdate: function(ev, eventArgs, tagCtxs) {\n      this.clearMessage();\n      return false; // don\'t rerender\n    },\n    onBeforeChange: function(ev, eventArgs) {\n      if (this.preventInvalidData) {\n        this.validate(eventArgs.value);\n        return this.isValid;\n        // Allow data to be updated to invalid values - unless preventInvalidData set to true\n      }\n    },\n    onDispose: function() {\n      if (this.validationGroup) {\n        this.validationGroup.removeChild(this);\n      }\n    },\n    validate: function(val) {\n      var message, linkedElem, testName, condition,\n        tag = this,\n        props = tag.tagCtx.props,\n        linkedElems = tag.linkedElem;\n\n      if (val === undefined) {\n        // If no val passed in, get current value from linkedElem, and validate that\n        if (tag._.radio && linkedElems) {\n          linkedElems = linkedElems.find("input:checked");\n        }\n        linkedElem = linkedElems && linkedElems[0];\n        val = "";\n        if (linkedElem) {\n          val = linkedElem.type === "checkbox" ? linkedElem.checked : linkedElem.value;\n        } else if (tag.targetTag) {\n          val = tag.targetTag.bndArgs()[0];\n        }\n        val = val || "";\n      }\n      tag.clearMessage();\n\n      // Test the validation conditions, one after the other.\n      this.isValid = true;\n      for (var validator in this.validators) {\n        condition = props[validator];\n        if (condition !== undefined && this.validators[validator].test(condition, val)) {\n          testName = validator;\n          this.isValid = false;\n          break;\n        }\n      }\n      if (!this.isValid) {// A test failed. Show message for first failed test.\n        message = props["msg_" + testName] || this.validators[testName].message;\n        if ($.isFunction(message)) {\n          message = message(condition, val);\n        }\n        message = message.replace(/%cond%/g, condition).replace(/%val%/g, val)\n        if (tag.label.textContent !== undefined) {\n          tag.label.textContent = message;\n        } else {\n          tag.label.innerText = message; // Older IE does not support textContent\n        }\n        tag.messageElem.addClass("invalid");\n      }\n      if (this.validationGroup) {\n        this.validationGroup.onChildValidate();\n      }\n      return this.isValid;\n    },\n    validators: function(validators) {\n      for (var validator in validators) {\n        this.validators[validator] = validators[validator];\n      }\n    },\n    clearMessage: function() {\n      // Clear previous message.\n      var tag = this,\n        label = tag.label;\n      if (tag.messageElem) {\n        tag.messageElem.removeClass("invalid");\n        if (label.textContent !== undefined) {\n          label.textContent = "";\n        } else {\n          label.innerText = ""; // Older IE does not support textContent\n        }\n      }\n    }\n}\n});\n\n$.views.tags.validate.validators({\n  required: {\n    message: "Please provide a value",\n    test: function(condition, val) {\n      return condition && val === "";\n    }\n  },\n  equal: {\n    message: "Value must be %cond%",\n    test: function(condition, val) {\n      return val !== "" + condition;\n    }\n  },\n  checked: {\n    message: function(condition, val) {\n      return "Must be " + (condition ? "checked" : "unchecked");\n    },\n    test: function(condition, val) {\n      return (val && val !== "false") !== condition;\n    }\n  },\n  min: {\n    message: "Minimum: %cond%",\n    test: function(condition, val) {\n      return val < condition;\n    }\n  },\n  max: {\n    message: "Maximum:  %cond%",\n    test: function(condition, val) {\n      return val > condition;\n    }\n  },\n  maxLength: {\n    message: "Maximum length: %cond%",\n    test: function(condition, val) {\n      return val.length > condition;\n    }\n  },\n  minLength: {\n    message: "Minimum length: %cond%",\n    test: function(condition, val) {\n      return val.length < condition;\n    }\n  },\n  regex: {\n    message: "Invalid string format",\n    test: function(condition, val) {\n      var regex = condition.test ? condition : new RegExp(condition);\n      return !regex.test(val);\n    }\n  }\n});\n\n})(this.jQuery);\n\n"use strict";\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  pageOptions = {\n    noInvalidData: false\n  },\n  model = {\n    size: 150\n  };\n\npageTmpl.link("#page", model, {\n  page: pageOptions\n})\n\n<h3>JsViews \'slider\' tag control (using jQuery UI slider) with validation</h3>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n  Prevent invalid data:<input type="checkbox" data-link="~page.noInvalidData" /><br/>\r\n\r\n  <h4>Size:</h4>\r\n  <input type="text" data-link="{:size:tonum}" />\r\n\r\n  <h4>Data-linked SVG:</h4>\r\n\r\n  <svg data-link="css-width{: 2 + size*2}" class="svg-circles">\r\n    <circle data-link="r{:size} cx{:size + 1}"\r\n      class="svg-circle" cy="51" stroke-width="2" stroke="green"></circle>\r\n    <circle data-link="r{:size*3/4} cx{:size + 1} cy{:102 - size*3/4}"\r\n      class="svg-circle" stroke="#aaa"></circle>\r\n    <circle data-link="r{:size/2} cx{:size + 1} cy{:size/2}"\r\n      class="svg-circle" stroke="#aaa"></circle>\r\n    <circle data-link="r{:size/4} cx{:size + 1}"\r\n      class="svg-circle" cy="51" stroke-width="2" stroke="blue"></circle>\r\n  </svg>\r\n\r\n  <h4>Full range</h4>\r\n  <div data-link="{slider size\r\n    _range=\'min\'\r\n    _min=1\r\n    _max=200\r\n    width=400\r\n  }" class="main-slider"></div>\r\n\r\n  <h4>Limited range: 50 - 100</h4>\r\n  {^{validate size\r\n    min=50 max=100\r\n    msg_min="Min size: %cond%"\r\n    msg_max="Max size: %cond%"\r\n    preventInvalidData=~page.noInvalidData\r\n  }}\r\n    <div data-link="{slider size\r\n      _orientation=\'vertical\'\r\n      _range=\'min\'\r\n      _min=0\r\n      _max=200\r\n      height=120\r\n    }"></div>\r\n  {{/validate}}\r\n\r\n  <h4>Limited range: 20 - 150</h4>\r\n  {^{validate size\r\n    min=20\r\n    max=150\r\n    msg_min="Min size: %cond%"\r\n    msg_max="Max size: %cond%"\r\n    preventInvalidData=~page.noInvalidData\r\n  }}\r\n    {^{slider size\r\n      _orientation=\'vertical\'\r\n      _range=\'min\'\r\n      _min=0\r\n      _max=200\r\n      height=120\r\n    /}}\r\n  {{/validate}}\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/validate/simple":{sections:[{_type:"sample",url:"samples/tag-controls/validate/simple/sample",text:'The {{validate}} tag can be used as a validating textbox, checkbox, dropdown, radio button group or textarea.\nIn each case optional properties can be specified on the validate tag, not only for convert, convertBack, linkTo etc., but also properties specifying validation tests (validators) to be applied, such as minLength=3.\n\nData-linked textbox\n{^{validate person\n  minLength=3\n  msg_minLength=\'The name ... %cond% ...\'\n  convert="upper"\n  convertBack=~lower\n}}\n\nor\n<input data-link="{validate person\n  minLength=3\n  msg_minLength=\'The name ... %cond% ...\'\n  convert=\'upper\'\n  convertBack=~lower\n}"/>\n\n\nData-linked checkbox\n{{!-- optionally include properties on {{validate ...}} tag,\n      such as convert, convertBack, minLength=..., etc. --}}\n{^{validate agree ...}}\n  <input type="checkbox"/>\n{{/validate}}\n\nor\n{{!-- optionally include properties on {validate ...} tag, such as convert etc. --}}\n<input type="checkbox" data-link="{validate agree ...}"/>\n\n\nData-linked drop down\n{^{validate person ...}} \n  <select size="3">\n    <option value="JO">Jo</option>\n    <option value="MARY">Mary</option>\n  </select>\n{{/validate}}\n\nor\n<select size="3" data-link="{validate person ...\'}">\n  <option value="JO">Jo</option>\n  <option value="MARY">Mary</option>\n</select>\n\n\nData-linked radio buttons\n{^{validate name radiogroup=true ...}}\n  <div>\n    <label><input type="radio" value="JO" /> Jo</label>\n    ...\n  </div>\n{{/validate}}\n\nor\n<div data-link="{validate name radiogroup=true ...}">\n  <label><input type="radio" value="JO" /> Jo</label>\n  ...\n</div>\n\n\nData-linked textarea\n{^{validate person ...}}\n  <textarea></textarea>\n{{/validate}}\n\nor\n<textarea data-link="{validate person ...}"></textarea>\n\n\n/*! Sample JsViews tag control: {{validate}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n  $.views.tags({\n  validation: {\n    init: function() {\n      this.childValidates = [];\n    },\n    validate: function() {\n      var l = this.childValidates.length,\n          result = true;\n      while (l-- && result !== false) {\n        result = this.childValidates[l].validate();\n      }\n      return result;\n    },\n    clearMessage: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].clearMessage();\n      }\n    },\n    refreshValidates: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].refresh();\n      }\n    },\n    addChild: function(child) {\n      this.childValidates.push(child);\n    },\n    removeChild: function(child) {\n      var l = this.childValidates.length;\n      while (l--) {\n        if (this.childValidates[l] === child) {\n          this.childValidates.splice(l, 1);\n          this.updateIsValid();\n          break;\n        }\n      }\n    },\n    onChildValidate: function() {\n      this.updateIsValid();\n    },\n    updateIsValid: function() {\n      var groupIsValid = true,\n        l = this.childValidates.length;\n      while (l--) {\n        if (!this.childValidates[l].isValid) {\n          groupIsValid = false;\n          break;\n        }\n      }\n      $.observable(this).setProperty("isValid", groupIsValid);\n    },\n    isValid: true,\n    dataBoundOnly: true\n  },\n  validate: {\n    baseTag: "radiogroup",\n    linkedElement: "select,textarea,input",\n    boundProps: ["preventInvalidData"],\n    init: function(tagCtx, linkCtx) {\n      var tag = this;\n      if (tag.radiogroup = tagCtx.props.radiogroup) {\n        tag.baseApply(arguments);\n      } else if (tag._.inline && !tagCtx.content) {\n        tag.template = "<input/>";\n      }\n      tag.validationGroup = this.parents.validation;\n      if (tag.validationGroup) {\n        tag.validationGroup.addChild(this);\n      }\n    },\n    render: function(val) {\n      var ret,\n        tag = this,\n        tagCtx = this.tagCtx;\n      if (tag._.inline) {\n         // Keep same data context for content\n        ret = tagCtx.render(tagCtx.view, true);\n        // For radio buttons provide wrapper for validation messages\n        ret = tag.radiogroup ? ("<div>" + ret + "</div>") : ret;\n        return ret;\n      }\n    },\n    onBind: function(tagCtx, linkCtx) {\n      var targetTag,\n        tag = this,\n        target = tag.linkedElem && tag.linkedElem[0];\n\n      if (targetTag = tag.childTags()[0]) {\n        // {{validate}} may wrap another tag, such as {{slider}}\n        // or {{datepicker}} rather than an element such as <input/>\n        tag.targetTag = targetTag;\n        if (target && $.view(target).tag === targetTag) {\n          tag.linkedElem = undefined;\n        }\n        targetTag.onBeforeChange = function(ev, val) {\n          return tag.onBeforeChange.call(tag, ev, val);\n        };\n      }\n      if (tag.radiogroup) {\n        this.baseApply(arguments);\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        targetTag = tag.targetTag,\n        props = tagCtx.props,\n        arg0 = tag.cvtArgs()[0];\n\n      if (targetTag) {\n        targetTag.updateValue(arg0);\n      }\n\n      if (props.preventInvalidData !== undefined) {\n        tag.preventInvalidData = props.preventInvalidData;\n      } else if (tag.parents.validation) {\n        tag.preventInvalidData = tag.parents.validation.tagCtx.props.preventInvalidData;\n      }\n      if (!tag.messageElem || !tag.messageElem.parentNode) {\n        if (tag.radiogroup) {\n          // messageElem is the div which wraps the group of radio buttons and/or labels\n          tag.messageElem = tag._.inline ? tagCtx.contents("div") : $(linkCtx.elem);\n          tag.messageElem.addClass("radiogroup");\n        } else {\n          if (!tag._.inline && (targetTag = $.views.sub._glt(linkCtx.elem)[0])) {\n            // Scenario with data-link="{targetTag ...}{validate ...}" (both tags data-linked on same linkedElem)\n            tag.targetTag = targetTag;\n          }\n          tag.messageElem = targetTag && (targetTag.displayElem || targetTag.linkedElem)\n            || tag.displayElem || tag.linkedElem;\n        }\n        tag.messageElem.addClass("val-msg");\n      }\n\n      if (!tag.label || !tag.label.parentNode) {\n        tag.label = $("<label class=\\"error\\"></label><br/>").insertAfter(tag.messageElem)[0];\n      }\n      tag.validate(arg0); // Validate initial data\n    },\n    onUpdate: function(ev, eventArgs, tagCtxs) {\n      this.clearMessage();\n      return false; // don\'t rerender\n    },\n    onBeforeChange: function(ev, eventArgs) {\n      if (this.preventInvalidData) {\n        this.validate(eventArgs.value);\n        return this.isValid;\n        // Allow data to be updated to invalid values - unless preventInvalidData set to true\n      }\n    },\n    onDispose: function() {\n      if (this.validationGroup) {\n        this.validationGroup.removeChild(this);\n      }\n    },\n    validate: function(val) {\n      var message, linkedElem, testName, condition,\n        tag = this,\n        props = tag.tagCtx.props,\n        linkedElems = tag.linkedElem;\n\n      if (val === undefined) {\n        // If no val passed in, get current value from linkedElem, and validate that\n        if (tag._.radio && linkedElems) {\n          linkedElems = linkedElems.find("input:checked");\n        }\n        linkedElem = linkedElems && linkedElems[0];\n        val = "";\n        if (linkedElem) {\n          val = linkedElem.type === "checkbox" ? linkedElem.checked : linkedElem.value;\n        } else if (tag.targetTag) {\n          val = tag.targetTag.bndArgs()[0];\n        }\n        val = val || "";\n      }\n      tag.clearMessage();\n\n      // Test the validation conditions, one after the other.\n      this.isValid = true;\n      for (var validator in this.validators) {\n        condition = props[validator];\n        if (condition !== undefined && this.validators[validator].test(condition, val)) {\n          testName = validator;\n          this.isValid = false;\n          break;\n        }\n      }\n      if (!this.isValid) {// A test failed. Show message for first failed test.\n        message = props["msg_" + testName] || this.validators[testName].message;\n        if ($.isFunction(message)) {\n          message = message(condition, val);\n        }\n        message = message.replace(/%cond%/g, condition).replace(/%val%/g, val)\n        if (tag.label.textContent !== undefined) {\n          tag.label.textContent = message;\n        } else {\n          tag.label.innerText = message; // Older IE does not support textContent\n        }\n        tag.messageElem.addClass("invalid");\n      }\n      if (this.validationGroup) {\n        this.validationGroup.onChildValidate();\n      }\n      return this.isValid;\n    },\n    validators: function(validators) {\n      for (var validator in validators) {\n        this.validators[validator] = validators[validator];\n      }\n    },\n    clearMessage: function() {\n      // Clear previous message.\n      var tag = this,\n        label = tag.label;\n      if (tag.messageElem) {\n        tag.messageElem.removeClass("invalid");\n        if (label.textContent !== undefined) {\n          label.textContent = "";\n        } else {\n          label.innerText = ""; // Older IE does not support textContent\n        }\n      }\n    }\n}\n});\n\n$.views.tags.validate.validators({\n  required: {\n    message: "Please provide a value",\n    test: function(condition, val) {\n      return condition && val === "";\n    }\n  },\n  equal: {\n    message: "Value must be %cond%",\n    test: function(condition, val) {\n      return val !== "" + condition;\n    }\n  },\n  checked: {\n    message: function(condition, val) {\n      return "Must be " + (condition ? "checked" : "unchecked");\n    },\n    test: function(condition, val) {\n      return (val && val !== "false") !== condition;\n    }\n  },\n  min: {\n    message: "Minimum: %cond%",\n    test: function(condition, val) {\n      return val < condition;\n    }\n  },\n  max: {\n    message: "Maximum:  %cond%",\n    test: function(condition, val) {\n      return val > condition;\n    }\n  },\n  maxLength: {\n    message: "Maximum length: %cond%",\n    test: function(condition, val) {\n      return val.length > condition;\n    }\n  },\n  minLength: {\n    message: "Minimum length: %cond%",\n    test: function(condition, val) {\n      return val.length < condition;\n    }\n  },\n  regex: {\n    message: "Invalid string format",\n    test: function(condition, val) {\n      var regex = condition.test ? condition : new RegExp(condition);\n      return !regex.test(val);\n    }\n  }\n});\n\n})(this.jQuery);\n\n"use strict";\n$.views.converters({\n  upper:function(val) {\n    val = "" + val;\n    return val && val.toUpperCase();\n  },\n  lower:function(val) {\n    val = "" + val;\n    return val && val.toLowerCase();\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  pageOptions = {\n    noInvalidData: false\n  },\n  model = {\n    agree: false,\n    person: "Jo",\n    people: [\n      {name: "Jo"},\n      {name: "Mary"},\n      {name: "Xavier"}\n    ]\n  };\n\npageTmpl.link("#page", model, {\n  page: pageOptions,\n  upper: $.views.converters.upper,\n  lower: $.views.converters.lower\n});\n\n<h3>JsViews \'validate\' tag control: The {{validate}} tag</h3>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <label>Prevent invalid data <input type="checkbox" data-link="~page.noInvalidData" /></label><br/>\r\n\r\n  Chosen person: <input data-link="person" /><br/>\r\n  <label>Agree <input type="checkbox" data-link="agree"/></label><br/>\r\n\r\n  <h3>Data-linked tags</h3>\r\n\r\n  {^{validate person\r\n    minLength=3\r\n    ^preventInvalidData=~page.noInvalidData\r\n    convert="upper"\r\n    convertBack=~lower\r\n  /}}\r\n\r\n  {^{validate person\r\n    minLength=3\r\n    ^preventInvalidData=~page.noInvalidData\r\n    convert="upper"\r\n    convertBack=~lower\r\n  }}\r\n    <input/>\r\n  {{/validate}}\r\n\r\n  <label>Agree\r\n  {^{validate agree\r\n    checked=true\r\n    ^preventInvalidData=~page.noInvalidData\r\n  }}\r\n    <input type="checkbox"/>\r\n  {{/validate}}</label>\r\n\r\n  {^{validate person\r\n    minLength=3\r\n    msg_minLength=\'Select a name of at least %cond% characters\'\r\n    ^preventInvalidData=~page.noInvalidData\r\n    convert="upper"\r\n    convertBack=~lower\r\n  }}\r\n    <select size="3">\r\n      <option value="JO">Jo</option>\r\n      <option value="MARY">Mary</option>\r\n      <option value="XAVIER">Xavier</option>\r\n    </select>\r\n  {{/validate}}\r\n\r\n  {^{validate person\r\n    radiogroup=true\r\n    minLength=3\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n    ^preventInvalidData=~page.noInvalidData\r\n  }}\r\n    <label><input type="radio" value="JO" /> Jo</label><br/>\r\n    <label><input type="radio" value="MARY" /> Mary</label><br/>\r\n    <label><input type="radio" value="XAVIER" /> Xavier</label><br/>\r\n  {{/validate}}\r\n\r\n  {^{validate person\r\n    minLength=3\r\n    convert="upper"\r\n    convertBack=~lower\r\n    ^preventInvalidData=~page.noInvalidData\r\n  }}\r\n    <textarea></textarea>\r\n  {{/validate}}\r\n\r\n  <h3>Data-linked elements</h3>\r\n\r\n  <input data-link="{validate person\r\n    minLength=3\r\n    msg_minLength=\'The name must have at least %cond% characters\'\r\n    ^preventInvalidData=~page.noInvalidData\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }"/>\r\n\r\n  <label> Agree\r\n  <input type="checkbox" data-link="{validate agree\r\n    checked=true\r\n    ^preventInvalidData=~page.noInvalidData\r\n  }"/></label>\r\n\r\n  <select size="3" data-link="{validate person\r\n    minLength=3\r\n    ^preventInvalidData=~page.noInvalidData\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }">\r\n    <option value="JO">Jo</option>\r\n    <option value="MARY">Mary</option>\r\n    <option value="XAVIER">Xavier</option>\r\n  </select>\r\n\r\n  <div data-link="{validate person\r\n    radiogroup=true\r\n    minLength=3\r\n    ^preventInvalidData=~page.noInvalidData\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }">\r\n    <label><input type="radio" value="JO" /> Jo</label><br/>\r\n    <label><input type="radio" value="MARY" /> Mary</label><br/>\r\n    <label><input type="radio" value="XAVIER" /> Xavier</label><br/>\r\n  </div>\r\n\r\n  <textarea data-link="{validate person\r\n    minLength=3\r\n    ^preventInvalidData=~page.noInvalidData\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }"></textarea>\r\n</script>\r\n\r\n<div id="page"></div>\n'}]},"samples/tag-controls/validate/group":{sections:[{_type:"sample",url:"samples/tag-controls/validate/validation-group/sample",text:'The {{validation}} validation group control is a validation container, which manages all the {{validate}} tags within the container.\nIt provides useful functionality, such as a validate() method which validates the child tags, and triggers display of the validation message on the first invalid control encountered.\nIt is even possible to data-link directly to the isValid property of the {{validation}} tag, to determine whether the whole form (or container) is valid:\n{^{if ~tag.isValid}}\n  <span class="val-title">no errors</span>\n{{else}}\n  <span class="val-title-error">VALIDATION ERRORS</span>\n{{/if}}\n\n\n/*! Sample JsViews tag control: {{validate}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n  $.views.tags({\n  validation: {\n    init: function() {\n      this.childValidates = [];\n    },\n    validate: function() {\n      var l = this.childValidates.length,\n          result = true;\n      while (l-- && result !== false) {\n        result = this.childValidates[l].validate();\n      }\n      return result;\n    },\n    clearMessage: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].clearMessage();\n      }\n    },\n    refreshValidates: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].refresh();\n      }\n    },\n    addChild: function(child) {\n      this.childValidates.push(child);\n    },\n    removeChild: function(child) {\n      var l = this.childValidates.length;\n      while (l--) {\n        if (this.childValidates[l] === child) {\n          this.childValidates.splice(l, 1);\n          this.updateIsValid();\n          break;\n        }\n      }\n    },\n    onChildValidate: function() {\n      this.updateIsValid();\n    },\n    updateIsValid: function() {\n      var groupIsValid = true,\n        l = this.childValidates.length;\n      while (l--) {\n        if (!this.childValidates[l].isValid) {\n          groupIsValid = false;\n          break;\n        }\n      }\n      $.observable(this).setProperty("isValid", groupIsValid);\n    },\n    isValid: true,\n    dataBoundOnly: true\n  },\n  validate: {\n    baseTag: "radiogroup",\n    linkedElement: "select,textarea,input",\n    boundProps: ["preventInvalidData"],\n    init: function(tagCtx, linkCtx) {\n      var tag = this;\n      if (tag.radiogroup = tagCtx.props.radiogroup) {\n        tag.baseApply(arguments);\n      } else if (tag._.inline && !tagCtx.content) {\n        tag.template = "<input/>";\n      }\n      tag.validationGroup = this.parents.validation;\n      if (tag.validationGroup) {\n        tag.validationGroup.addChild(this);\n      }\n    },\n    render: function(val) {\n      var ret,\n        tag = this,\n        tagCtx = this.tagCtx;\n      if (tag._.inline) {\n         // Keep same data context for content\n        ret = tagCtx.render(tagCtx.view, true);\n        // For radio buttons provide wrapper for validation messages\n        ret = tag.radiogroup ? ("<div>" + ret + "</div>") : ret;\n        return ret;\n      }\n    },\n    onBind: function(tagCtx, linkCtx) {\n      var targetTag,\n        tag = this,\n        target = tag.linkedElem && tag.linkedElem[0];\n\n      if (targetTag = tag.childTags()[0]) {\n        // {{validate}} may wrap another tag, such as {{slider}}\n        // or {{datepicker}} rather than an element such as <input/>\n        tag.targetTag = targetTag;\n        if (target && $.view(target).tag === targetTag) {\n          tag.linkedElem = undefined;\n        }\n        targetTag.onBeforeChange = function(ev, val) {\n          return tag.onBeforeChange.call(tag, ev, val);\n        };\n      }\n      if (tag.radiogroup) {\n        this.baseApply(arguments);\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        targetTag = tag.targetTag,\n        props = tagCtx.props,\n        arg0 = tag.cvtArgs()[0];\n\n      if (targetTag) {\n        targetTag.updateValue(arg0);\n      }\n\n      if (props.preventInvalidData !== undefined) {\n        tag.preventInvalidData = props.preventInvalidData;\n      } else if (tag.parents.validation) {\n        tag.preventInvalidData = tag.parents.validation.tagCtx.props.preventInvalidData;\n      }\n      if (!tag.messageElem || !tag.messageElem.parentNode) {\n        if (tag.radiogroup) {\n          // messageElem is the div which wraps the group of radio buttons and/or labels\n          tag.messageElem = tag._.inline ? tagCtx.contents("div") : $(linkCtx.elem);\n          tag.messageElem.addClass("radiogroup");\n        } else {\n          if (!tag._.inline && (targetTag = $.views.sub._glt(linkCtx.elem)[0])) {\n            // Scenario with data-link="{targetTag ...}{validate ...}" (both tags data-linked on same linkedElem)\n            tag.targetTag = targetTag;\n          }\n          tag.messageElem = targetTag && (targetTag.displayElem || targetTag.linkedElem)\n            || tag.displayElem || tag.linkedElem;\n        }\n        tag.messageElem.addClass("val-msg");\n      }\n\n      if (!tag.label || !tag.label.parentNode) {\n        tag.label = $("<label class=\\"error\\"></label><br/>").insertAfter(tag.messageElem)[0];\n      }\n      tag.validate(arg0); // Validate initial data\n    },\n    onUpdate: function(ev, eventArgs, tagCtxs) {\n      this.clearMessage();\n      return false; // don\'t rerender\n    },\n    onBeforeChange: function(ev, eventArgs) {\n      if (this.preventInvalidData) {\n        this.validate(eventArgs.value);\n        return this.isValid;\n        // Allow data to be updated to invalid values - unless preventInvalidData set to true\n      }\n    },\n    onDispose: function() {\n      if (this.validationGroup) {\n        this.validationGroup.removeChild(this);\n      }\n    },\n    validate: function(val) {\n      var message, linkedElem, testName, condition,\n        tag = this,\n        props = tag.tagCtx.props,\n        linkedElems = tag.linkedElem;\n\n      if (val === undefined) {\n        // If no val passed in, get current value from linkedElem, and validate that\n        if (tag._.radio && linkedElems) {\n          linkedElems = linkedElems.find("input:checked");\n        }\n        linkedElem = linkedElems && linkedElems[0];\n        val = "";\n        if (linkedElem) {\n          val = linkedElem.type === "checkbox" ? linkedElem.checked : linkedElem.value;\n        } else if (tag.targetTag) {\n          val = tag.targetTag.bndArgs()[0];\n        }\n        val = val || "";\n      }\n      tag.clearMessage();\n\n      // Test the validation conditions, one after the other.\n      this.isValid = true;\n      for (var validator in this.validators) {\n        condition = props[validator];\n        if (condition !== undefined && this.validators[validator].test(condition, val)) {\n          testName = validator;\n          this.isValid = false;\n          break;\n        }\n      }\n      if (!this.isValid) {// A test failed. Show message for first failed test.\n        message = props["msg_" + testName] || this.validators[testName].message;\n        if ($.isFunction(message)) {\n          message = message(condition, val);\n        }\n        message = message.replace(/%cond%/g, condition).replace(/%val%/g, val)\n        if (tag.label.textContent !== undefined) {\n          tag.label.textContent = message;\n        } else {\n          tag.label.innerText = message; // Older IE does not support textContent\n        }\n        tag.messageElem.addClass("invalid");\n      }\n      if (this.validationGroup) {\n        this.validationGroup.onChildValidate();\n      }\n      return this.isValid;\n    },\n    validators: function(validators) {\n      for (var validator in validators) {\n        this.validators[validator] = validators[validator];\n      }\n    },\n    clearMessage: function() {\n      // Clear previous message.\n      var tag = this,\n        label = tag.label;\n      if (tag.messageElem) {\n        tag.messageElem.removeClass("invalid");\n        if (label.textContent !== undefined) {\n          label.textContent = "";\n        } else {\n          label.innerText = ""; // Older IE does not support textContent\n        }\n      }\n    }\n}\n});\n\n$.views.tags.validate.validators({\n  required: {\n    message: "Please provide a value",\n    test: function(condition, val) {\n      return condition && val === "";\n    }\n  },\n  equal: {\n    message: "Value must be %cond%",\n    test: function(condition, val) {\n      return val !== "" + condition;\n    }\n  },\n  checked: {\n    message: function(condition, val) {\n      return "Must be " + (condition ? "checked" : "unchecked");\n    },\n    test: function(condition, val) {\n      return (val && val !== "false") !== condition;\n    }\n  },\n  min: {\n    message: "Minimum: %cond%",\n    test: function(condition, val) {\n      return val < condition;\n    }\n  },\n  max: {\n    message: "Maximum:  %cond%",\n    test: function(condition, val) {\n      return val > condition;\n    }\n  },\n  maxLength: {\n    message: "Maximum length: %cond%",\n    test: function(condition, val) {\n      return val.length > condition;\n    }\n  },\n  minLength: {\n    message: "Minimum length: %cond%",\n    test: function(condition, val) {\n      return val.length < condition;\n    }\n  },\n  regex: {\n    message: "Invalid string format",\n    test: function(condition, val) {\n      var regex = condition.test ? condition : new RegExp(condition);\n      return !regex.test(val);\n    }\n  }\n});\n\n})(this.jQuery);\n\n"use strict";\n$.views.converters({\n  upper:function(val) {\n    val = "" + val;\n    return val && val.toUpperCase();\n  },\n  lower:function(val) {\n    val = "" + val;\n    return val && val.toLowerCase();\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  pageOptions = {\n    noInvalidData: false\n  },\n  model = {\n    agree: false,\n    person: "Jo",\n    people: [\n      {name: "Jo"},\n      {name: "Mary"},\n      {name: "Xavier"}\n    ]\n  };\n\npageTmpl.link("#page", model, {\n  page: pageOptions,\n  upper: $.views.converters.upper,\n  lower: $.views.converters.lower\n})\n  .on("click", "#validate", function() {\n    validation.validate();\n  })\n  .on("click", "#clear", function() {\n    validation.clearMessage();\n  })\n  .on("click", "#refresh-outer", function() {\n    validation.refresh();\n  })\n  .on("click", "#refresh", function() {\n    validation.refreshValidates();\n  });\n  var validation = $.view("#validate").ctx.tag;\n<h3>JsViews \'validate\' and \'validation\' tag controls: The {{validate}} and {{validation}} tags</h3>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n{^{validation ^preventInvalidData=~page.noInvalidData}}\r\n  <p>\r\n    <button id="validate">Validate</button>\r\n    <button id="clear">Clear Messages</button>\r\n    <button id="refresh-outer">Refresh validation container</button>\r\n    <button id="refresh">Refresh validated controls</button>\r\n  </p>\r\n  <label>Prevent invalid data <input type="checkbox" data-link="~page.noInvalidData" /></label><br/>\r\n\r\n  Chosen person: <input data-link="person" /><br/>\r\n\r\n  <label>Agree <input type="checkbox" data-link="agree" /></label><br/>\r\n\r\n  <p>There are\r\n    {^{if ~tag.isValid}}\r\n      <span class="val-title">no errors</span>\r\n    {{else}}\r\n      <span class="val-title-error">VALIDATION ERRORS</span>\r\n    {{/if}}\r\n    on this page!\r\n  </p>\r\n\r\n  <h3>Data-linked tags</h3>\r\n\r\n  {^{validate person\r\n    minLength=3\r\n    convert="upper"\r\n    convertBack=~lower\r\n  }}\r\n    <input/>\r\n  {{/validate}}\r\n\r\n  <label>Agree {^{validate agree\r\n    checked=true\r\n  }}\r\n    <input type="checkbox" /> \r\n  {{/validate}}</label>\r\n\r\n  {^{validate person\r\n    minLength=3\r\n    convert="upper"\r\n    convertBack=~lower\r\n    msg_minLength=\'Select a name of at least %cond% characters\'\r\n  }}\r\n    <select size="3">\r\n      <option value="JO">Jo</option>\r\n      <option value="MARY">Mary</option>\r\n      <option value="XAVIER">Xavier</option>\r\n    </select>\r\n  {{/validate}}\r\n\r\n  {^{validate person\r\n    radiogroup=true\r\n    minLength=3\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }}\r\n    <label><input type="radio" value="JO" /> Jo</label><br/>\r\n    <label><input type="radio" value="MARY" /> Mary</label><br/>\r\n    <label><input type="radio" value="XAVIER" /> Xavier</label><br/>\r\n  {{/validate}}\r\n\r\n  {^{validate person\r\n    minLength=3\r\n    convert="upper"\r\n    convertBack=~lower\r\n  }}\r\n    <textarea></textarea>\r\n  {{/validate}}\r\n\r\n  <h3>Data-linked elements</h3>\r\n\r\n  <input data-link="{validate person\r\n    minLength=3\r\n    msg_minLength=\'The name must have at least %cond% characters\'\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }"/>\r\n\r\n  <label>Agree <input type="checkbox" data-link="{validate agree\r\n    checked=true\r\n  }"/></label> \r\n\r\n  <select size="3" data-link="{validate person\r\n    minLength=3\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }">\r\n    <option value="JO">Jo</option>\r\n    <option value="MARY">Mary</option>\r\n    <option value="XAVIER">Xavier</option>\r\n  </select>\r\n\r\n  <div data-link="{validate person\r\n    radiogroup=true\r\n    minLength=3\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }">\r\n    <label><input type="radio" value="JO" /> Jo</label><br/>\r\n    <label><input type="radio" value="MARY" /> Mary</label><br/>\r\n    <label><input type="radio" value="XAVIER" /> Xavier</label><br/>\r\n  </div>\r\n\r\n  <textarea data-link="{validate person\r\n    minLength=3\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }"></textarea>\r\n\r\n{{/validation}}\r\n</script>\r\n\r\n<div id="page"></div>\n'}]},"samples/form-els/simple":{sections:[{_type:"code",title:"Top-level form element binding",text:'Top-level form element binding\n$("#amountPickers").link(true, data);\n'},{_type:"sample",url:"samples/form-els/simple/top-level",text:'This version of the sample uses top-level data-linking. An HTML container element in the page is data-linked as follows:\n$("#amountPickers").link(true, data);\n\nand elements within the data-linked container are linked to the data using element-based data-linking syntax:\n<div id="amountPickers">\n  ...\n  <span data-link="amount"></span>\n  ...\n  <input type="checkbox" data-link="listbox" />\n  ...\n  <input data-link="amount" />\n  ...\n  <select data-link="amount">\n    <option>0</option>\n    ...  \n  </select>\n  ...\n  <div data-link="{radiogroup amount}">\n    <label><input type="radio" value="0" /> 0</label>\n    ...\n  </div>\n  ...\n  <textarea data-link="amount"></textarea>\n  ...\n</div>\n\nNote the above examples use compact data-linking syntax:\ndata-link="amount"\n\nwhich is equivalent to the following full syntax:\ndata-link="{:amount:}".\n\nUse the full syntax if you need to specify converters, data-linking targets other than the default, or if you need to data-link to more than one target on the same element. For example the following targets both the default binding for <select> and also the size attribute:\n<select data-link="{:amount:} size{:listbox ? 4 : null}">\n\n\n"use strict";\nvar data = {\n  amount: "3",\n  listbox: false\n};\n\n$("#amountPickers").link(true, data);\n\n<h3>JsViews data-linking to form elements - top-level binding</h3>\r\n<div class="subhead">Binding string values to UI elements\r\n  (without converters)</div>\r\n\r\n<div id="amountPickers">\r\n  Note that <em>amount</em> is a string - so here is <em>amount + 1</em>:\r\n  <b data-link="amount+1"></b><br/><br/>\r\n\r\n  <div class="box">\r\n    <b>Amount: <em>span</em><br/><br/>\r\n    <span data-link="amount"></span></b><br/><br/>\r\n  </div>\r\n\r\n  <div class="box">\r\n    <b>Choose listbox/dropdown: <em>checkbox:</em></b><br/><br/>\r\n    <label><input type="checkbox" data-link="listbox" /> Show as listbox</label><br/>\r\n  </div>\r\n\r\n  <div class="box">\r\n    <b>Amount: <em>text box</em></b><br/><br/>\r\n    <input data-link="amount" /><br/><br/>\r\n\r\n    <b>Amount: <em>dropdown or listbox</em></b><br/><br/>\r\n    <select data-link="{:amount:} size{:listbox ? 4 : null}">\r\n      <option>0</option>\r\n      <option>1</option>\r\n      <option>2</option>\r\n      <option>3</option>\r\n    </select><br/><br/>\r\n\r\n\r\n    <b>Amount: <em>radio buttons</em></b><br/><br/>\r\n    <div data-link="{radiogroup amount}">\r\n      <label><input type="radio" value="0" /> 0</label><br/>\r\n      <label><input type="radio" value="1" /> 1</label><br/>\r\n      <label><input type="radio" value="2" /> 2</label><br/>\r\n      <label><input type="radio" value="3" /> 3</label><br/>\r\n    </div><br/>\r\n\r\n<!-- Alternative syntax, without {{radiogroup}} tag\r\n    <label><input type="radio" name="amt" value="0" data-link="amount" />\r\n      0</label><br/>\r\n    <label><input type="radio" name="amt" value="1" data-link="amount" />\r\n      1</label><br/>\r\n    <label><input type="radio" name="amt" value="2" data-link="amount" />\r\n      2</label><br/>\r\n    <label><input type="radio" name="amt" value="3" data-link="amount" />\r\n      3</label><br/><br/>\r\n-->\r\n\r\n    <b>Amount: <em>text area</em></b><br/><br/>\r\n    <textarea data-link="amount" rows="2" cols="10"></textarea><br/><br/>\r\n  </div>\r\n</div>\n'
},{_type:"code",title:"Form element binding within a template",text:'Form element binding within a template\n$.templates("#tmpl").link("#amountPickers", data);\n'},{_type:"sample",url:"samples/form-els/simple/template",text:'This version of the sample uses data-linking within a template. The template is rendered and data-linked within an HTML container element as follows:\n$.templates("#tmpl").link("#amountPickers", data);\n\nand elements within the template are linked to the data using either element-based data-linking syntax or JsViews tag-based data-linking syntax:\n<script id="tmpl" type="text/x-jsrender">\n  ...\n  <b data-link="amount+1"></b>\n  ...\n  {^{:amount}}\n  ...\n  <input type="checkbox" data-link="listbox" />\n  ...\n  <input data-link="amount" />\n  ...\n  <select data-link="{:amount:} size{:listbox ? 4 : null}">\n    <option>0</option>\n    ...  \n  </select>\n  ...\n  <div data-link="{radiogroup amount}">\n    <label><input type="radio" value="0" /> 0</label>\n    ...\n  </div>\n  ...\n  <textarea data-link="amount"></textarea>\n  ...\n</script>\n\n<div id="amountPickers"></div>\n\n\n"use strict";\nvar data = {\n  amount: "3",\n  listbox: false\n};\n\n$.templates("#tmpl").link("#amountPickers", data);\n\n<h3>JsViews data-linking to form elements - within a rendered template</h3>\r\n<div class="subhead">Binding string values to UI elements\r\n  (without converters)</div>\r\n\r\n<script id="tmpl" type="text/x-jsrender">\r\n  Note that <em>amount</em> is a string - so here is <em>amount + 1</em>:\r\n  <b data-link="amount+1"></b><br/><br/>\r\n\r\n  <div class="box">\r\n    <b>Amount: <em>span</em><br/><br/>\r\n    {^{:amount}}</b><br/><br/>\r\n  </div>\r\n\r\n  <div class="box">\r\n    <b>Choose listbox/dropdown: <em>checkbox:</em></b><br/><br/>\r\n    <label><input type="checkbox" data-link="listbox" /> Show as listbox</label><br/>\r\n  </div>\r\n\r\n  <div class="box">\r\n    <b>Amount: <em>text box</em></b><br/><br/>\r\n    <input data-link="amount" /><br/><br/>\r\n\r\n    <b>Amount: <em>dropdown or listbox</em></b><br/><br/>\r\n    <select data-link="{:amount:} size{:listbox ? 4 : null}">\r\n      <option>0</option>\r\n      <option>1</option>\r\n      <option>2</option>\r\n      <option>3</option>\r\n    </select><br/><br/>\r\n\r\n    <b>Amount: <em>radio buttons</em></b><br/><br/>\r\n    {^{radiogroup amount}}\r\n      <label><input type="radio" value="0" /> 0</label><br/>\r\n      <label><input type="radio" value="1" /> 1</label><br/>\r\n      <label><input type="radio" value="2" /> 2</label><br/>\r\n      <label><input type="radio" value="3" /> 3</label><br/>\r\n    {{/radiogroup}}\r\n    <b>Amount: <em>text area</em></b><br/><br/>\r\n    <textarea data-link="amount" rows="2" cols="10"></textarea><br/><br/>\r\n  </div>\r\n</script>\r\n\r\n<div id="amountPickers"></div>\n'}]},"samples/form-els/converters":{sections:[{_type:"sample",url:"samples/form-els/converters/sample",text:'Different convert and convertBack converters are registered, and then used in the form element data-binding as follows:\n\nBinding  "base 0" data values to "base 1" values in UI:\n$.views.converters({\n  minus1: function(val) { return val-1; },\n  plus1: function(val) { return 1+val; },\n  ...\n});\n\n<input data-link="{plus1:amount:minus1}" />\n<span data-link="{plus1:amount}"></span>\n\n\nBinding inverted boolean data values to UI:\nnot: function(val) { return !val; }\n\n<input type="checkbox" data-link="{not:listbox:not}" />\n\n\nBinding number data values to string values in UI:\nintToStr: function(value) { return ... "" + value ... },\nstrToInt: function (value) { return ... parseInt(value) ... }\n\n<input data-link="{intToStr:amount:strToInt}"/>...\n<select data-link="{intToStr:amount:strToInt} ...">...\n{^{radiogroup amount convert="intToStr" convertBack="strToInt"}}\n<input type="radio" name="amt" value="0" data-link="{intToStr:amount:strToInt}" />...\n<textarea data-link="{intToStr:amount:strToInt}" ...></textarea>...\n\n\nBinding number data values to UI elements using bit-masks:\nsetBit: function(value) {\n  ...\n  // Use the mask to set or unset that bit on the data, and return the modified value\n  return value ? (dataValue | mask) : (dataValue & ~mask);\n},\ngetBit: function (value) {\n  // "Convert": Get the bit from the data, and check or uncheck the checkbox\n  return (value >> this.linkCtx.elem.getAttribute("data-bit") & 1) === 1;\n}\n\n<input type="checkbox" data-bit="0" data-link="{getBit:amount:setBit}" />\n\n\n"use strict";\n$.views.converters({\n  minus1: function(value) {\n    return isNaN(value) || value === \'\' ? null : value-1;\n  },\n  plus1: function(value) {\n    return 1+value;\n  },\n  not: function(val) {\n    return !val;\n  },\n  intToStr: function(value) {\n    return "" + value;\n  },\n  strToInt: function(value) {\n    return isNaN(value) || value === \'\' ? null : parseInt(value);\n  },\n  setBit: function(value) {\n    // "Convert Back": If checked, set this bit on the data,\n    // or if unchecked, unset this bit on the data\n    var mask = 1 << this.linkCtx.elem.getAttribute("data-bit"),\n      // Shift first bit, 0, 1 or 2 bits to the left,\n      // to create a mask\n      dataValue = this.tagCtx.args[0];\n      // Take the current data value\n    return value ? (dataValue | mask) : (dataValue & ~mask);\n    // Use the mask to set or unset that bit on the data,\n    // and return the modified value\n  },\n  getBit: function(value) {\n    // "Convert": Get the bit from the data,\n    // and check or uncheck the checkbox\n    return (value >>\n      this.linkCtx.elem.getAttribute("data-bit") & 1) === 1;\n    // Shift 0, 1 or 2 bits to the right,\n    // and see if the first bit is set.\n  }\n});\n\nvar data = {\n  group: "Group ONE",\n  amount: 3,\n  listbox: false\n};\n\n$.templates("#tmpl").link("#amountPickers", data);\n\n<h3>Data-linking to form elements, using two-way converters\r\n    (<em>convert</em> and <em>convert back</em>)</h3>\r\n\r\n<script id="tmpl" type="text/x-jsrender">\r\n  <div class="box">\r\n    <b>Using converters to convert between <em>"base 0"</em> data values and\r\n    <em>"base 1"</em> UI values: <em>"{plus1:listbox:minus1}"</em></b><br/><br/>\r\n\r\n    <input data-link="{plus1:amount:minus1}" />\r\n    <span data-link="{plus1:amount}" class="calculated"></span>\r\n    <span data-link="{:amount}" class="calculated"></span><br/><br/>\r\n  </div>\r\n\r\n  <div class="box">\r\n    <b>Using converters to invert a <em>boolean</em> data value:\r\n    <em>"{not:listbox:not}"</em></b><br/><br/>\r\n    <label><input type="checkbox" data-link="listbox" /> Show as listbox</label><br/>\r\n    <label><input type="checkbox" data-link="{not:listbox:not}" /> Show as dropdown</label><br/>\r\n  </div>\r\n\r\n  <div class="box">\r\n    <b>Using converters to bind <em>number</em> data values to <em>string</em>\r\n    values in UI elements: <em>"{intToStr:listbox:strToInt}"</em></b><br/><br/>\r\n    <input data-link="{intToStr:amount:strToInt}"/><br/><br/>\r\n\r\n    <select data-link="{intToStr:amount:strToInt} size{:listbox ? 4 : null}">\r\n      <option>0</option>\r\n      <option>1</option>\r\n      <option>2</option>\r\n      <option>3</option>\r\n    </select><br/><br/>\r\n\r\n    {^{radiogroup amount convert="intToStr" convertBack="strToInt"}}\r\n      <label><input type="radio" value="0" /> 0</label><br/>\r\n      <label><input type="radio" value="1" /> 1</label><br/>\r\n      <label><input type="radio" value="2" /> 2</label><br/>\r\n      <label><input type="radio" value="3" /> 3</label><br/>\r\n    {{/radiogroup}}<br/>\r\n\r\n    <textarea data-link="{intToStr:amount:strToInt}"\r\n      rows="2" cols="10"></textarea><br/><br/>\r\n  </div>\r\n\r\n  <div class="box">\r\n    <b>Using converters to bind <em>number</em> data values to UI elements,\r\n      using bit-masks: <em>"{getBit:amount:setBit}"</em></b><br/><br/>\r\n    <label><input type="checkbox" data-bit="0"\r\n      data-link="{getBit:amount:setBit}" /> bit 0</label><br/>\r\n    <label><input type="checkbox" data-bit="1"\r\n      data-link="{getBit:amount:setBit}" /> bit 1</label><br/>\r\n  </div>\r\n\r\n</script>\r\n\r\n<div id="amountPickers"></div>\n'},{_type:"sample",url:"samples/form-els/converters/day-to-int",text:'Using converters for tag rendering\nHTML encoding, no custom converter:\n<td>{{>dayOff}}</td>\n\nRender from data, convert to display name:\n<td>{{intToDay:dayOff}}</td>\n\n\nUsing convert and convertBack with data-linking\nLink from data value, no converter:\n<td data-link="dayOff"></td>\n\nLink from data, converted to display name:\n<td data-link="{intToDay:dayOff}"></td>\n\nTwo-way data linking with convert and convertBack between data format (integer) and display name (text).Also show data value as tooltip:\n<td><input data-link="{intToDay:dayOff:dayToInt} title{:dayOff}" /></td>\n\n\n"use strict";\nvar days = [ "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" ],\n  myWeek = {\n    dayOff: 1\n  };\n\n$.views.converters({\n  dayToInt: function(val) {\n    var dayOff = parseInt(val);\n    if (isNaN(dayOff)) {\n      for (var i = 0; i < 7; i++) {\n        if (days[ i ].toLowerCase().slice(0, val.length) === val.toLowerCase()) {\n          dayOff = i;\n          break;\n        }\n      }\n    }\n    if (isNaN(dayOff)) {\n      dayOff = val;\n    } else {\n      this.linkCtx.elem.value = days[dayOff]; // Set the text box value to the Day Off name\n    }\n    return dayOff;\n  },\n  intToDay: function(val) {\n    return days[val] || val;\n  }\n});\n\n// Observable property change\n$("#changeDay").on("click", function() {\n  var dayOff = myWeek.dayOff;\n  $.observable(myWeek).setProperty("dayOff", dayOff < 6 ? dayOff + 1 : 0);\n});\n\nvar myTmpl = $.templates("#linkedTmpl")\n\nmyTmpl.link("#linked", myWeek);\n\n<b>Using converters to bind <em>integer</em> data values (index of day in week) to\r\n <em>string</em> in UI (name of day): <em>"{intToDay:dayOff:dayToInt}"</em></b><br/><br/>\r\n\r\n<table>\r\n  <thead><tr><th>Data</th><th>DayOff</th><th>Choose day off</th></tr></thead>\r\n  <tbody id="linked"></tbody>\r\n</table>\r\n<div><em>To edit, enter part of the name, or the number, or click here:</em>\r\n<button id="changeDay">Change day</button></div>\r\n\r\n<script id="linkedTmpl" type="text/x-jsrender">\r\n  <tr>\r\n    <td data-link="dayOff"></td>\r\n    <td data-link="{intToDay:dayOff}"></td>\r\n    <td><input data-link="{intToDay:dayOff:dayToInt} title{:dayOff}" /></td>\r\n  </tr>\r\n</script>\n'}]},"samples/form-els/array-binding":{sections:[{_type:"sample",title:'Data-linking &lt;option> collections and &ltinput type="radio"> collections to arrays',url:"samples/form-els/array-binding/sample",text:'Data-linking <option> collections and <input type="radio"> collections to arrays\nThis sample is similar to the previous converters sample – but here the amount can be selected from a range of integers that is chosen by the user (by choosing the number of bits!).\nThe array of possible integers is then generated from code:\nfunction setData() {\n  ...\n  newAmounts = [];\n  ...\n  var maxAmount = Math.pow(2, bitCount);\n  for(var i = 0; i < maxAmount ; i++) {\n    newAmounts.push(i);\n  }\n  ...\n  $.observable(amounts).refresh(newAmounts);\n}\n\nThe collection of <input type="radio"> elements, and the collection of <option> elements under the <select> are dynamically driven by data-linking to the amounts array:\n{^{radiogroup amount convert=\'intToStr\' convertBack=\'strToInt\'}}\n  {^{for amounts}}\n    <label><input type="radio" value="{{:#data}}" /> {{:#data}}</label>\n    ...\n  {{/for}}\n{{/radiogroup}}\n\n<select data-link="{intToStr:amount:strToInt} size{:listbox ? amounts.length : null}">\n  {^{for amounts}}\n    <option data-link="value{:#data}">{{:#data}}</option>\n  {{/for}}\n</select>\n\n\n"use strict";\n$.views.converters({\n  intToStr: function(value) {\n    return "" + value;\n  },\n  strToInt: function(value) {\n    return isNaN(value) || value === \'\' ? null : parseInt(value);\n  },\n  setBit: function(value) {\n    // "Convert Back": If checked, set this bit on the data,\n    // or if unchecked, unset this bit on the data\n    var mask = 1 << this.linkCtx.elem.getAttribute("data-bit"),\n    // Shift first bit, 0, 1 or 2 bits to the left, to create a mask\n      dataValue = this.tagCtx.args[0];\n      // Take the current data value\n    return value ? (dataValue | mask) : (dataValue & ~mask);\n    // Use the mask to set or unset that bit on the data, and return the modified value\n  },\n  getBit: function(value) {\n    // "Convert": Get the bit from the data, and check or uncheck the checkbox\n    return (value >> this.linkCtx.elem.getAttribute("data-bit") & 1) === 1;\n    // Shift 0, 1 or 2 bits to the right, and see if the first bit is set.\n  }\n});\n\nvar newBits, newAmounts,\n  bits = [],\n  amounts = [],\n  bitCount = 3,\n  data = {\n    amount: 3,\n    amounts: amounts,\n    bits: bits,\n    listbox: true\n  };\n\nfunction setData() {\n  newBits = [];\n  newAmounts = [];\n  var maxAmount = Math.pow(2, bitCount);\n  for(var i = 0; i < bitCount; i++) {\n    newBits.push(i);\n  }\n  for(var i = 0; i < maxAmount ; i++) {\n    newAmounts.push(i);\n  }\n  $.observable(bits).refresh(newBits);\n  $.observable(amounts).refresh(newAmounts);\n}\n\nsetData();\n\n$.templates("#tmpl").link("#amountPickers", data);\n\n$("#more").on("click", function() {\n  bitCount++;\n  setData();\n});\n$("#less").on("click", function() {\n  bitCount--;\n  setData();\n});\n\n<script id="tmpl" type="text/x-jsrender">\r\n  <div class="box">\r\n    <b>Choose the range of amounts:</b>\r\n    <button id="more">more</button>\r\n    <button id="less" data-link="disabled{:amounts.length<3}">less</button>\r\n  </div>\r\n\r\n  <div class="box">\r\n    <b>Choose amount:</b><br/><br/>\r\n\r\n    <input data-link="{intToStr:amount:strToInt}"/><br/><br/>\r\n\r\n    {^{radiogroup amount convert=\'intToStr\' convertBack=\'strToInt\'}}\r\n      {^{for amounts}}\r\n        <label><input type="radio" value="{{:#data}}" />\r\n         {{:#data}}</label><br/>\r\n      {{/for}}\r\n    {{/radiogroup}}<br/>\r\n\r\n{{!-- Alternative syntax without using {{radiogroup}} tag:\r\n    {^{for amounts}}\r\n      <label><input type="radio" name="amt" value="{{:#data}}"\r\n        data-link="{intToStr:~root.amount:strToInt}" />\r\n      {{:#data}}</label><br/>\r\n    {{/for}}<br/>\r\n--}}\r\n\r\n    <label><input type="checkbox" data-link="listbox" /> Show as listbox</label><br/>\r\n    <select data-link="{intToStr:amount:strToInt} size{:listbox ? amounts.length : null}">\r\n      {^{for amounts}}\r\n        <option data-link="value{:#data}">{{:#data}}</option>\r\n      {{/for}}\r\n    </select>\r\n  </div>\r\n\r\n  <div class="box">\r\n    <b>Choose amount (by setting bits!):</b><br/><br/>\r\n\r\n    {^{for bits}}\r\n      <label><input type="checkbox" data-bit="{{:#data}}"\r\n        data-link="{getBit:~root.amount:setBit}" />\r\n      bit {{:#data}}</label><br/>\r\n    {{/for}}\r\n  </div>\r\n</script>\r\n\r\n<div id="amountPickers"></div>\n'}]},"samples/form-els/visible-binding":{sections:[{_type:"para",title:"",text:"This sample shows data-linked visibility, and also shows data-linked textbox, checkbox, textarea, radio button and select elements.\nEnter values in text boxes etc. and gradually the successive steps will be made visible through data-binding:\n"},{_type:"sample",url:"samples/form-els/visible-binding/sample",text:'<div data-link="visible{:name}">\n...\n<div data-link="visible{:name && selectedMovie!==\'none\'}">\n...\n<div data-link="visible{:request}">\n\n<select data-link="selectedMovie">\n  <option value="none">Choose...</option>\n  {{for ~movies}}\n    <option value="{{:#index}}">{{>title}}</option>\n  {{/for}}\n</select>\n\n<textarea data-link="request" ...></textarea>\n\n<input type="checkbox" data-link="~app.chooseCurrency" />\n\n{^{radiogroup selectedCurrency}}\n  {{for ~currencies}}\n    <label><input type="radio" value="{{:#index}}" /> {{:label}}</label>\n  {{/for}}\n{{/radiogroup}}\n\n\n"use strict";\nvar currencies = [\n    { name:"US", label:"US Dollar", rate: 1.0, symbol: "$" },\n    { name:"EUR", label:"Euro", rate: 0.95, symbol: "Euros: " },\n    { name:"GB", label:"Pound", rate: 0.63, symbol: "Pounds: " }\n  ],\n\n  orderDetails = {\n    name: "",\n    selectedMovie: "none",\n    selectedCurrency: "1",\n    request: ""\n  },\n\n  movies = [\n    {\n      title: "The Red Violin",\n      ticketPrice: 18\n    },\n    {\n      title: "The Inheritance",\n      ticketPrice: 16.5\n    },\n    {\n      title: "The Incredible Hulk",\n      ticketPrice: 21.99\n    }\n  ],\n\n  contextHelpers = {\n    app: {},\n    movies: movies,\n    convertedPrice: function(selectedMovie, selectedCurrency) {\n      var currency = currencies[selectedCurrency];\n      if (selectedMovie !== "none") {\n        return currency.symbol\n          + parseFloat(movies[selectedMovie].ticketPrice * currency.rate)\n            .toFixed(2);\n      }\n    },\n    currencies: currencies,\n    selectedTitle: function(selectedMovie) {\n      return (selectedMovie!=="none") ? movies[selectedMovie].title : "";\n    }\n  };\n\n$.templates("moviePurchaseTemplate", "#moviePurchaseTemplate");\n\n$.link.moviePurchaseTemplate("#moviePurchase", orderDetails, contextHelpers);\n\n$("#submitOrder").on("click", function() {\n  alert("You ordered a movie ticket as follows:\\n"\n    + (window.JSON\n    ? JSON.stringify(orderDetails, null, 1).slice(1,-1)\n    : orderDetails.selectedMovie));\n});\n\n<h4>Purchase a movie ticket</h4>\r\n\r\n<script id="moviePurchaseTemplate" type="text/x-jsrender">\r\n  <div class="box">\r\n    <div class="subhead"\r\n      data-link="~selectedTitle(selectedMovie) || \'Choose a movie\'"\r\n    ></div>\r\n\r\n    <select data-link="selectedMovie" class="full">\r\n      <option value="none">Choose...</option>\r\n      {{for ~movies}}\r\n        <option value="{{:#index}}">{{>title}}</option>\r\n      {{/for}}\r\n    </select>\r\n\r\n    <div data-link="visible{:selectedMovie!==\'none\' }">\r\n\r\n      <div class="subhead"\r\n        data-link="{:name ? \'Name:\' : \'Type your name here:\'}"\r\n      ></div>\r\n      <div>\r\n        <input\r\n          data-link="name"\r\n          placeholder="Enter your name..."\r\n        /></div>\r\n\r\n      <div data-link="visible{:name}">\r\n        <div class="subhead"\r\n          data-link="{:request\r\n            ? \'Special requests:\'\r\n            : \'Type special requests here:\'}\r\n          visible{:name}"\r\n        ></div>\r\n        <div>\r\n          <textarea\r\n            data-link="request"\r\n            rows="4" cols="25"\r\n            placeholder="Enter any special requests..."\r\n          ></textarea>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <div data-link="visible{:name && selectedMovie!==\'none\'}">\r\n\r\n    <h3>Ticket order form</h3>\r\n\r\n    <div class="box" data-link="visible{:~app.chooseCurrency}">\r\n      <div class="subhead">Choose Currency:</div>\r\n      {^{radiogroup selectedCurrency}}\r\n        {{for ~currencies}}\r\n          <label><input type="radio" value="{{:#index}}" /> {{:label}}</label><br/>\r\n        {{/for}}\r\n      {{/radiogroup}}\r\n    </div>\r\n\r\n    <div class="box">\r\n      <div>Ticket for <em data-link="name" ></em> to movie:\r\n        <em data-link="~selectedTitle(selectedMovie)" ></em>\r\n      </div>\r\n      <div data-link="visible{:request}">\r\n        <em>Your special request:</em>\r\n        <pre data-link="request" ></pre>\r\n      </div>\r\n      <div>\r\n        <b>Ticket Price:</b>\r\n        <span\r\n          data-link="~convertedPrice(selectedMovie, selectedCurrency)"\r\n        ></span>\r\n        <div><label>Choose currency for payment:\r\n          <input type="checkbox" data-link="~app.chooseCurrency" /></label>\r\n        </div>\r\n      </div>\r\n      <div>\r\n        <button id="submitOrder">Submit order</button>\r\n      </div>\r\n    </div>\r\n\r\n  </div>\r\n</script>\r\n\r\n<div id="moviePurchase"></div>\n'}]},"samples/form-elems":{sections:[{_type:"links",title:"",text:""}]},"samples/tag-controls/validate/array-binding":{sections:[{_type:"sample",title:'The  {{validate}} tag with &lt;option> collections or &ltinput type=\\"radio\\"> collections data-linked to arrays',url:"samples/tag-controls/validate/array-binding/sample",text:'The  {{validate}} tag with <option> collections or <input type=\\"radio\\"> collections data-linked to arrays\nThis sample is similar to the previous validation group sample – but here the people array can be modified – by adding or removing people, or changing their name property.\n.on("click", "#add", function() {\n  $.observable(model.people).insert({name: "new"...});\n})\n.on("click", ".remove", function() {\n  var view = $.view(this);\n  $.observable(model.people).remove(view.index);\n  validation.validate();\n});\n\nThe collection of <option> elements or <input type="radio"> elements is dynamically driven by data-linking to the people array:\n{^{validate person ...}}\n  <select>\n    {^{for people}}\n      <option data-link="value{upper:name} {:name:}"></option>\n    {{/for}}\n  </select>\n{{/validate}}\n\n{^{validate person radiogroup=true ...}}\n  {^{for people}}\n    <label><input type="radio" data-link="value{upper:name}"/> {^{:name}}</label>\n  {{/for}}\n{{/validate}}\n\n\n/*! Sample JsViews tag control: {{validate}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n  $.views.tags({\n  validation: {\n    init: function() {\n      this.childValidates = [];\n    },\n    validate: function() {\n      var l = this.childValidates.length,\n          result = true;\n      while (l-- && result !== false) {\n        result = this.childValidates[l].validate();\n      }\n      return result;\n    },\n    clearMessage: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].clearMessage();\n      }\n    },\n    refreshValidates: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].refresh();\n      }\n    },\n    addChild: function(child) {\n      this.childValidates.push(child);\n    },\n    removeChild: function(child) {\n      var l = this.childValidates.length;\n      while (l--) {\n        if (this.childValidates[l] === child) {\n          this.childValidates.splice(l, 1);\n          this.updateIsValid();\n          break;\n        }\n      }\n    },\n    onChildValidate: function() {\n      this.updateIsValid();\n    },\n    updateIsValid: function() {\n      var groupIsValid = true,\n        l = this.childValidates.length;\n      while (l--) {\n        if (!this.childValidates[l].isValid) {\n          groupIsValid = false;\n          break;\n        }\n      }\n      $.observable(this).setProperty("isValid", groupIsValid);\n    },\n    isValid: true,\n    dataBoundOnly: true\n  },\n  validate: {\n    baseTag: "radiogroup",\n    linkedElement: "select,textarea,input",\n    boundProps: ["preventInvalidData"],\n    init: function(tagCtx, linkCtx) {\n      var tag = this;\n      if (tag.radiogroup = tagCtx.props.radiogroup) {\n        tag.baseApply(arguments);\n      } else if (tag._.inline && !tagCtx.content) {\n        tag.template = "<input/>";\n      }\n      tag.validationGroup = this.parents.validation;\n      if (tag.validationGroup) {\n        tag.validationGroup.addChild(this);\n      }\n    },\n    render: function(val) {\n      var ret,\n        tag = this,\n        tagCtx = this.tagCtx;\n      if (tag._.inline) {\n         // Keep same data context for content\n        ret = tagCtx.render(tagCtx.view, true);\n        // For radio buttons provide wrapper for validation messages\n        ret = tag.radiogroup ? ("<div>" + ret + "</div>") : ret;\n        return ret;\n      }\n    },\n    onBind: function(tagCtx, linkCtx) {\n      var targetTag,\n        tag = this,\n        target = tag.linkedElem && tag.linkedElem[0];\n\n      if (targetTag = tag.childTags()[0]) {\n        // {{validate}} may wrap another tag, such as {{slider}}\n        // or {{datepicker}} rather than an element such as <input/>\n        tag.targetTag = targetTag;\n        if (target && $.view(target).tag === targetTag) {\n          tag.linkedElem = undefined;\n        }\n        targetTag.onBeforeChange = function(ev, val) {\n          return tag.onBeforeChange.call(tag, ev, val);\n        };\n      }\n      if (tag.radiogroup) {\n        this.baseApply(arguments);\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        targetTag = tag.targetTag,\n        props = tagCtx.props,\n        arg0 = tag.cvtArgs()[0];\n\n      if (targetTag) {\n        targetTag.updateValue(arg0);\n      }\n\n      if (props.preventInvalidData !== undefined) {\n        tag.preventInvalidData = props.preventInvalidData;\n      } else if (tag.parents.validation) {\n        tag.preventInvalidData = tag.parents.validation.tagCtx.props.preventInvalidData;\n      }\n      if (!tag.messageElem || !tag.messageElem.parentNode) {\n        if (tag.radiogroup) {\n          // messageElem is the div which wraps the group of radio buttons and/or labels\n          tag.messageElem = tag._.inline ? tagCtx.contents("div") : $(linkCtx.elem);\n          tag.messageElem.addClass("radiogroup");\n        } else {\n          if (!tag._.inline && (targetTag = $.views.sub._glt(linkCtx.elem)[0])) {\n            // Scenario with data-link="{targetTag ...}{validate ...}" (both tags data-linked on same linkedElem)\n            tag.targetTag = targetTag;\n          }\n          tag.messageElem = targetTag && (targetTag.displayElem || targetTag.linkedElem)\n            || tag.displayElem || tag.linkedElem;\n        }\n        tag.messageElem.addClass("val-msg");\n      }\n\n      if (!tag.label || !tag.label.parentNode) {\n        tag.label = $("<label class=\\"error\\"></label><br/>").insertAfter(tag.messageElem)[0];\n      }\n      tag.validate(arg0); // Validate initial data\n    },\n    onUpdate: function(ev, eventArgs, tagCtxs) {\n      this.clearMessage();\n      return false; // don\'t rerender\n    },\n    onBeforeChange: function(ev, eventArgs) {\n      if (this.preventInvalidData) {\n        this.validate(eventArgs.value);\n        return this.isValid;\n        // Allow data to be updated to invalid values - unless preventInvalidData set to true\n      }\n    },\n    onDispose: function() {\n      if (this.validationGroup) {\n        this.validationGroup.removeChild(this);\n      }\n    },\n    validate: function(val) {\n      var message, linkedElem, testName, condition,\n        tag = this,\n        props = tag.tagCtx.props,\n        linkedElems = tag.linkedElem;\n\n      if (val === undefined) {\n        // If no val passed in, get current value from linkedElem, and validate that\n        if (tag._.radio && linkedElems) {\n          linkedElems = linkedElems.find("input:checked");\n        }\n        linkedElem = linkedElems && linkedElems[0];\n        val = "";\n        if (linkedElem) {\n          val = linkedElem.type === "checkbox" ? linkedElem.checked : linkedElem.value;\n        } else if (tag.targetTag) {\n          val = tag.targetTag.bndArgs()[0];\n        }\n        val = val || "";\n      }\n      tag.clearMessage();\n\n      // Test the validation conditions, one after the other.\n      this.isValid = true;\n      for (var validator in this.validators) {\n        condition = props[validator];\n        if (condition !== undefined && this.validators[validator].test(condition, val)) {\n          testName = validator;\n          this.isValid = false;\n          break;\n        }\n      }\n      if (!this.isValid) {// A test failed. Show message for first failed test.\n        message = props["msg_" + testName] || this.validators[testName].message;\n        if ($.isFunction(message)) {\n          message = message(condition, val);\n        }\n        message = message.replace(/%cond%/g, condition).replace(/%val%/g, val)\n        if (tag.label.textContent !== undefined) {\n          tag.label.textContent = message;\n        } else {\n          tag.label.innerText = message; // Older IE does not support textContent\n        }\n        tag.messageElem.addClass("invalid");\n      }\n      if (this.validationGroup) {\n        this.validationGroup.onChildValidate();\n      }\n      return this.isValid;\n    },\n    validators: function(validators) {\n      for (var validator in validators) {\n        this.validators[validator] = validators[validator];\n      }\n    },\n    clearMessage: function() {\n      // Clear previous message.\n      var tag = this,\n        label = tag.label;\n      if (tag.messageElem) {\n        tag.messageElem.removeClass("invalid");\n        if (label.textContent !== undefined) {\n          label.textContent = "";\n        } else {\n          label.innerText = ""; // Older IE does not support textContent\n        }\n      }\n    }\n}\n});\n\n$.views.tags.validate.validators({\n  required: {\n    message: "Please provide a value",\n    test: function(condition, val) {\n      return condition && val === "";\n    }\n  },\n  equal: {\n    message: "Value must be %cond%",\n    test: function(condition, val) {\n      return val !== "" + condition;\n    }\n  },\n  checked: {\n    message: function(condition, val) {\n      return "Must be " + (condition ? "checked" : "unchecked");\n    },\n    test: function(condition, val) {\n      return (val && val !== "false") !== condition;\n    }\n  },\n  min: {\n    message: "Minimum: %cond%",\n    test: function(condition, val) {\n      return val < condition;\n    }\n  },\n  max: {\n    message: "Maximum:  %cond%",\n    test: function(condition, val) {\n      return val > condition;\n    }\n  },\n  maxLength: {\n    message: "Maximum length: %cond%",\n    test: function(condition, val) {\n      return val.length > condition;\n    }\n  },\n  minLength: {\n    message: "Minimum length: %cond%",\n    test: function(condition, val) {\n      return val.length < condition;\n    }\n  },\n  regex: {\n    message: "Invalid string format",\n    test: function(condition, val) {\n      var regex = condition.test ? condition : new RegExp(condition);\n      return !regex.test(val);\n    }\n  }\n});\n\n})(this.jQuery);\n\n"use strict";\n$.views.converters({\n  upper:function(val) {\n    val = "" + val;\n    return val && val.toUpperCase();\n  },\n  lower:function(val) {\n    val = "" + val;\n    return val && val.toLowerCase();\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  count = 0,\n  pageOptions = {\n    noInvalidData: false\n  },\n  model = {\n    person: "Maria",\n    people: [\n      {name: "Jo"},\n      {name: "Maria"},\n      {name: "Xavier"}\n    ]\n  };\n\npageTmpl.link("#page", model, {\n  page: pageOptions,\n  upper: $.views.converters.upper,\n  lower: $.views.converters.lower\n})\n  .on("click", "#validate", function() {\n    validation.validate();\n  })\n  .on("click", "#clear", function() {\n    validation.clearMessage();\n  })\n  .on("click", "#refresh-outer", function() {\n    validation.refresh();\n  })\n  .on("click", "#refresh", function() {\n    validation.refreshValidates();\n  })\n  .on("click", "#add", function() {\n    $.observable(model.people).insert({name: "new" + count++});\n  })\n  .on("click", ".remove", function() {\n    var view = $.view(this);\n    $.observable(model.people).remove(view.index);\n    validation.validate();\n  });\nvar validation = $.view("#validate").ctx.tag;\n\n<h3>JsViews \'validate\' tag control: The {{validate}} tag</h3>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n{^{validation ^preventInvalidData=~page.noInvalidData}}\r\n  <p>\r\n    <button id="validate">Validate</button>\r\n    <button id="clear">Clear Messages</button>\r\n    <button id="refresh-outer">Refresh validation container</button>\r\n    <button id="refresh">Refresh validated controls</button>\r\n  </p>\r\n  <label>Prevent invalid data <input type="checkbox" data-link="~page.noInvalidData" /></label><br/>\r\n\r\n  <p>There are\r\n    {^{if ~tag.isValid}}\r\n      <span class="val-title">no errors</span>\r\n    {{else}}\r\n      <span class="val-title-error">VALIDATION ERRORS</span>\r\n    {{/if}}\r\n    on this page!\r\n  </p>\r\n\r\n  Chosen person: <input data-link="person"/><br/>\r\n\r\n  <h3>Edit names</h3>\r\n  <p>\r\n    <button id="add">add person</button>\r\n  </p>\r\n  <p>\r\n  {^{for people}}\r\n      <span class="remove"></span>\r\n      {^{validate name minLength=5 msg_minLength="Edit the name: At least %cond% letters!" /}}\r\n    {{/for}}\r\n  </p>\r\n\r\n  <h3>Choose a person with a name of at least 5 letters!</h3>\r\n\r\n  <h3>Data-linked tags</h3>\r\n\r\n  {^{validate person\r\n    minLength=5\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  /}}\r\n\r\n  {^{validate person\r\n    minLength=5\r\n    convert="upper"\r\n    convertBack=~lower\r\n  }}\r\n    <select size="5">\r\n      {^{for people}}\r\n        <option data-link="value{upper:name} {:name}"></option>\r\n      {{/for}}\r\n    </select>\r\n  {{/validate}}\r\n\r\n  {^{validate person\r\n    radiogroup=true\r\n    minLength=5\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }}\r\n    {^{for people}}\r\n      <label><input type="radio" data-link="value{upper:name}"/> {^{:name}}</label><br/>\r\n    {{/for}}\r\n  {{/validate}}\r\n\r\n  <h3>Data-linked elements</h3>\r\n\r\n  <input data-link="{validate person\r\n    minLength=5\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }"/>\r\n\r\n  <select size="5" data-link="{validate person\r\n    minLength=5\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }">\r\n    {^{for people}}\r\n      <option value="{{upper:name}}" data-link="value^{upper:name} {:name}"></option>\r\n    {{/for}}\r\n  </select>\r\n\r\n  <div data-link="{validate person\r\n    radiogroup=true\r\n    minLength=5\r\n    convert=\'upper\'\r\n    convertBack=~lower\r\n  }">\r\n    {^{for people}}\r\n      <label><input type="radio" value="{{upper:name}}" data-link="value^{upper:name}"/> {^{:name}}</label><br/>\r\n    {{/for}}\r\n  </div>\r\n{{/validation}}\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/simple-textbox":{sections:[{_type:"para",title:"",text:"This sample show a simple custom {{textbox}} tag control.\nIt can be considered as a first step towards a more advanced control.\n"},{_type:"sample",url:"samples/tag-controls/simple-textbox/sample",text:'This sample illustrates the simplest possible custom tag control supporting two-way data-binding.\nBy using a template which includes an input element:\n<input/>\n\nand then setting the linkedElement property to "input":\n$.views.tags({\n  textbox: {\n    linkedElement: "input",\n    template: "<input/>",\n    ...\n  }\n});\n\nJsViews automatically looks for a matching element (the linkedElement string being treated as a jQuery selector), which it then provides as a property on the resulting tag instance (wrapped in a jQuery object): tag.linkedElem.\nJsViews sets up two-way data-linking on that input element.\nNow you can get two-way binding to your data, simply by setting the path to the data as parameter on your {{textbox}} tag:\n{{textbox my.data.path /}}\n\nAs an optional optimization, we can set the onUpdate handler of our tag control to return false. This has the effect of preventing the control from re-rendering itself each time that data changes. (The updating of the textbox content is already assured by the data-linked input, so re-rendering is unnecessary.)\n$.views.tags({\n  textbox: {\n    linkedElement: "input",\n    template: "<input/>",\n    onUpdate: function() {\n      return false;\n    },\n    template: "<input/>"\n  }\n});\n\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    person: "Jo"\n  };\n\npageTmpl.link("#page", model);\n\n/*! Sample JsViews tag control: {{textbox}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n$.views.tags({\n  textbox: {\n    linkedElement: "input",\n    template: "<input/>",\n    onUpdate: false, // No need to re-render whole tag, when content updates.\n    dataBoundOnly: true\n  }\n});\n\n})(this.jQuery);\n\n<h3>JsViews simple \'textbox\' tag control: The {{textbox}} tag</h3>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <div class="subhead">Data-linked input</div>\r\n\r\n  <pre>&lt;input data-link="person"/&gt;</pre>\r\n\r\n  <input data-link="person"/>\r\n\r\n  <div class="subhead">Data-linked textbox tag</div>\r\n\r\n  <pre>&lcub;^{textbox person/}&rcub;</pre>\r\n\r\n  {^{textbox person/}}\r\n</script>\r\n\r\n<div id="page"></div>\n'}]},"samples/data-link/from-render-to-link":{sections:[{_type:"para",title:"",text:"This is the first page of a tutorial sequence on data-linking. We start by showing how to convert a complex JsRender template to work in JsViews, using data-linking throughout.\n"},{_type:"para",title:"The power of JsRender",text:"The power of JsRender\nJsRender tags are powerful. JsRender does pure string-based rendering. It does not use the DOM to render a template against data, and, as a pure string-based rendering engine it doesn’t even ‘have any awareness’ of the HTML markup in the template. So this means that as long as you are just using JsRender to render (and not doing data-linking, with JsViews), you can put the JsRender tags anywhere you want in relation to the HTML tags, including within the attribute content of an HTML tag, as in the following examples.\n"},{_type:"para",title:"{{if}} tags within attribute markup",text:'{{if}} tags within attribute markup\nThe first example applies a CSS class for people who play the role of "Lead". If their ‘Role description’ includes the word "Lead", then the ‘special’ CSS class is applied.\n(Click on Try it, change the role text, and hit Run code, and you will see…):\n'},{_type:"sample",title:"{{if}} tag in attribute markup",url:"samples/data-link/1_if-tag-in-attribute",text:'{{if}} tag in attribute markup\n<style>\n  ...\n  .special { color: blue; font-style: italic; }\n  ...\n</style>\n\n{{for people}}\n  <div class="person">\n    <span class="{{if role.indexOf(\'Lead\')>=0}}special{{/if}}">\n      {{:first}} ...\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing (Lead)"\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\nvar html = $.templates.peopleTmpl.render(data);\n$("#people").html(html);\n<style>\r\n  .person {padding: 3px; margin: 5px;}\r\n  .special {color: blue; font-style: italic;}\r\n  .details {color: green; border: 2px solid grey;\r\n             display: inline-block; padding: 3px; margin-left: 40px;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  {{for people}}\r\n    <div class="person">\r\n      <span class="{{if role.indexOf(\'Lead\')>=0}}special{{/if}}">\r\n        {{:first}} <b>{{:last}}</b>\r\n      </span>\r\n      <span class="details">\r\n        {{:role}}\r\n      </span>\r\n    </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"",text:'But what if we want to use data-binding to add or remove people from the collection of people. And what if we plan to allow the user to change the \'Role description’. In that case we would like to use data-binding to dynamically toggle the class ‘special’ whenever the data changes, based on whether or not it includes the term "Lead".\n'},{_type:"para",title:"The plan: add data-linking. But how?",text:"The plan: add data-linking. But how?\nHow can we convert the above sample to dynamically bind to data. Of course we will do that using JsViews data-linking, but how do we convert the JsRender template (which does not ‘have any knowledge of HTML elements’) so that elements are inserted and removed when the people collection changes, and the span element’s ‘special’ class is actually toggled when the role changes? Clearly JsViews has to have DOM awareness, even if JsRender does not.\n"},{_type:"para",title:"First let's go further with JsRender",text:"First let's go further with JsRender\nWell before we get to that, let’s first make the problem even harder, by pushing our JsRender template’s HTML ignorance to a blissful extreme. Let’s use a completely non-data-bound approach to user interactivity, by adding mouse events to hide and show the role details information when the user hovers over the person’s name. And let’s use DOM level 0 inline event code, so we are mixing code and markup!\nThen – from there – we’ll show how to move to a data-driven model, with good separation of code and markup, and well-formed templates that allow the full power of JsViews to be leveraged.\nHere is the sample with the added hover behavior:\n"},{_type:"sample",title:"Template-rendered mouse events",url:"samples/data-link/2_mouse-events-in-template",text:'Template-rendered mouse events\n\n{{for people}}\n  \n    \n      {{:first}} {{:last}}\n    \n    \n\n    \n      {{:role}}\n    \n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing (Lead)"\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\nvar html = $.templates.peopleTmpl.render(data);\n$("#people").html(html);\n<style>\r\n  .person {padding: 3px; margin: 5px; cursor: pointer;}\r\n  .special {color: blue; font-style: italic;}\r\n  .details {color: green; border: 2px solid grey;\r\n             display:none; padding: 3px; margin-left :40px;}\r\n  .question {width: 24px; vertical-align: text-bottom;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  {{for people}}\r\n    <div class="person"\r\n      onmouseover="$(\'#role_{{:#index}}\').show();"\r\n      onmouseout="$(\'#role_{{:#index}}\').hide();"\r\n    >\r\n      <span class="{{if role.indexOf(\'Lead\')>=0}}special{{/if}}">\r\n        {{:first}} <b>{{:last}}</b>\r\n      </span>\r\n      <img class="question" src="question.jpg"/>\r\n\r\n      <span class="details" id="role_{{:#index}}">\r\n        {{:role}}\r\n      </span>\r\n    </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"So how did that work? ",text:'So how did that work? \nWell first we used the JsRender #index to insert unique IDs on the role details span.\nThat may seem surprising, given that JsRender does not ‘track’ HTML entities. So it does not have an index corresponding to counting HTML elements. But it does track instances of rendered templates, or tag blocks. (They are the ‘views’ of JsViews.) – Within a {{for}}...{{/for}} section, or block, JsRender counts the ‘views’ corresponding to the rendered instances of that block. (One for each data item in the people array).\nSo here we use that #index variable to add unique IDs to HTML element markup.\n<span class="details" id="role_{{:#index}}">\n\nAnd of course we use the same IDs in our mouseover code to hide and show the role details span element.\nonmouseover="$(\'#role_{{:#index}}\').show();"\nonmouseout="$(\'#role_{{:#index}}\').hide();">\n\n'},{_type:"para",title:"Putting all the templated attribute content in an {{include}}",text:"Putting all the templated attribute content in an {{include}}\nSuppose we want to be able to reuse our mouseover behavior and conditional class rendering, as an encapsulated re-usable 'component’. Let’s use template composition to do that. We will put all of the special attribute markup into a separate template, and insert it using:\n<span {{include tmpl=\"#attributesTmpl\" ~id='role_'+#index /}} >\n\nwithin the HTML element markup for the <span>\n"},{_type:"sample",title:"{{include}} within HTML attribute content",url:"samples/data-link/3_include-tag-in-attribute",text:'{{include}} within HTML attribute content\n...\n<div class="person" {{include tmpl="#attributesTmpl" ~id=\'role_\'+#index /}} >\n...\n\n<script type="text/x-jsrender" id="attributesTmpl">\n  onmouseover="$(\'#{{:~id}}\').show();"\n  onmouseout="$(\'#{{:~id}}\').hide();"\n</script>\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing (Lead)"\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\nvar html = $.templates.peopleTmpl.render(data);\n$("#people").html(html);\n<style>\r\n  .person {padding: 3px; margin: 5px; cursor: pointer;}\r\n  .special {color: blue; font-style: italic;}\r\n  .details {color: green; border: 2px solid grey;\r\n             display:none; padding: 3px; margin-left :40px;}\r\n  .question {width: 24px; vertical-align: text-bottom;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  {{for people}}\r\n    <div\r\n      class="person"\r\n      {{include tmpl="#attributesTmpl" ~id=\'role_\'+#index /}}\r\n    >\r\n      <span class="{{if role.indexOf(\'Lead\')>=0}}special{{/if}}" >\r\n        {{:first}} <b>{{:last}}</b>\r\n      </span>\r\n      <img class="question" src="question.jpg"/>\r\n\r\n      <span class="details" id="role_{{:#index}}">\r\n        {{:role}}\r\n      </span>\r\n    </div>\r\n  {{/for}}\r\n</script>\r\n\r\n<script type="text/x-jsrender" id="attributesTmpl">\r\n  onmouseover="$(\'#{{:~id}}\').show();"\r\n  onmouseout="$(\'#{{:~id}}\').hide();"\r\n</script>\n'},{_type:"para",title:"",text:"Notice how we made the computed index, #role_{{:#index}} from the previous sample into a computed variable which we pass in to our ‘included’ template.\n~id='role_'+#index\n\nonmouseover=\"$('#{{:~id}}').show();\"\n\n"},{_type:"para",title:"Next step &ndash; convert to JsViews data-linking",text:"Next step – convert to JsViews data-linking\nSo we have reached a relatively complex JsRender template, and we are ready to convert it to use data-linking – (move ‘from render to link’)…\nThe details of adding data-linking to the above sample – and taking it forward to additional functionality – will be shown in the rest of this tutorial sequence.\n"},{_type:"para",title:"As a teaser, here is a first step:",text:'As a teaser, here is a first step:\nLet’s add support for inserting new ‘people’ in the people array. The basic idea is simply to change the syntax on the {{for ...}} to make it into a data-linked tag: {^{for ...}}. We change:\n{{for people}}\n\nto\n{^{for people}}\n\nNext, we need to replace our render() method by the corresponding link() call. Let’s change the script call from:\nvar html = $.templates.peopleTmpl.render(data);\n$("#people").html(html);\n\nto\n$.templates.peopleTmpl.link("#people", data);\n\nThen we’ll use JsObservable to allow you to add new people to the people array. Here is the updated sample:\n'},{_type:"sample",title:"Data-linked {^{for}} tag",url:"samples/data-link/4_linked-for-tag",text:'Data-linked {^{for}} tag\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    ...\n  });\n})\n\n{^{for people}}\n  <div \n    class="person"\n    {{include tmpl="#attributesTmpl" ~id=\'role_\'+#index /}}\n  >\n    <span class="{{if role.indexOf(\'Lead\')>=0}}special{{/if}}" >\n      {{:first}} <b>{{:last}}</b>\n    </span>\n    <img src=".../question.jpg"/>\n\n    <span class="details" id="role_{{:#index}}">\n      {{:role}}\n    </span>\n  </div>\n{{/for}}\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing (Lead)"\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez",\n    role: "Support"\n  });\n});\n\n<style>\r\n  .person {padding: 3px; margin: 5px; cursor: pointer;}\r\n  .special {color: blue; font-style: italic;}\r\n  .details {color: green; border: 2px solid grey;\r\n             display:none; padding: 3px; margin-left :40px;}\r\n  .question {width: 24px; vertical-align: text-bottom;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button id="add">Add person</button>\r\n  {^{for people}}\r\n    <div\r\n      class="person"\r\n      {{include tmpl="#attributesTmpl" ~id=\'role_\'+#index /}}\r\n    >\r\n      <span class="{{if role.indexOf(\'Lead\')>=0}}special{{/if}}" >\r\n        {{:first}} <b>{{:last}}</b>\r\n      </span>\r\n      <img class="question" src="question.jpg"/>\r\n\r\n      <span class="details" id="role_{{:#index}}">\r\n        {{:role}}\r\n      </span>\r\n    </div>\r\n  {{/for}}\r\n</script>\r\n\r\n<script type="text/x-jsrender" id="attributesTmpl">\r\n  class="hover {{if role.indexOf(\'Lead\')>=0}}special{{/if}}"\r\n  onmouseover="$(\'#{{:~id}}\').show();"\r\n  onmouseout="$(\'#{{:~id}}\').hide();"\r\n</script>\n'},{_type:"para",title:"Linked and unlinked tags, and element markup",text:'Linked and unlinked tags, and element markup\nBy changing the {{for}} tag to a data-linked {^{for}} tag, we have obtained dynamic data-linking (binding) of our sample to changes in the person array.\nBut we still have an {{include}} tag and an {{if}} tag – nested within the {^{for}} block. If we could change them also to be to data-linked (using {^{include}} and {^{if}}) then we could dynamically bind to changes in the role – and make our conditional toggling of the ‘special’ class and our hover behavior be data-driven.\nHowever, those tags are within the markup of HTML element tags (between the < and >):\n<div class="person" {{include .../}} >\n  <span class="{{if ...}}special{{/if}}" >\n\nJsViews does not support using a data-linked tag ({^{...}}) within HTML element tag markup. (Try it and you will get a syntax error message). Instead, it provides for data-linking HTML elements directly.\nLater pages of this tutorial sequence will show you how to use data-linked elements to add data-driven class and hover behavior to our sample.\nThe next page gives more detail on data-linking {^{for}} and {^{if}}.\n'},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/data-link/for-and-if":{sections:[{_type:"para",title:"",text:"This is the second page of a tutorial sequence on data-linking. Here we are showing how to convert a complex JsRender template to work in JsViews, using data-linking throughout.\n"},{_type:"para",title:"Data-linked {^{for ...}} tag",text:"Data-linked {^{for ...}} tag\nIn the final sample in that sequence, we saw that simply by adding the ^ character, the {^{for ...}} becomes data-linked. Here is that same sample, but in a stripped down form, in which we have removed the {{include}} tag within the element markup, and the hover behavior for role details. We will add them back in progressively in later sample, as we show how to create fully data-linked implementations of similar or improved functionality…\n"},{_type:"sample",title:"Data-linked {^{for ...}} tag",url:"samples/data-link/5_linked-for-tag",text:'Data-linked {^{for ...}} tag\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    ...\n  });\n})\n\n{^{for people}}\n  <div class="person">\n    {{:first}} <b>{{:last}}</b>\n  </div>\n{{/for}}\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams"\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez"\n  });\n});\n\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button id="add">Add person</button>\r\n  {^{for people}}\r\n    <div class="person">\r\n      {{:first}} <b>{{:last}}</b>\r\n    </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"Data-linked {^{if ...}} tag",text:"Data-linked {^{if ...}} tag\nData-linking an {{if}} tag works in just the same way, simply by adding a ^ character.\nWe’ll illustrate that by allowing the user to switch between first-last and last-first format for the name:\n"},{_type:"sample",title:"Data-linked {^{if ...}} tag",url:"samples/data-link/6_linked-if-tag",text:'Data-linked {^{if ...}} tag\n\n Reverse name\n{^{for people}}\n  \n    {^{if ~root.reverse}}\n      {{:last}}, {{:first}}\n    {{else}}\n      {{:first}} {{:last}}\n    {{/if}}\n  \n{{/for}}\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams"\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez"\n  });\n});\n\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button id="add">Add person</button><br /><br />\r\n  <label><input type="checkbox" data-link="reverse"/> Reverse name</label>\r\n  {^{for people}}\r\n    <div class="person">\r\n      {^{if ~root.reverse}}\r\n        <b>{{:last}}</b>, {{:first}}\r\n      {{else}}\r\n        {{:first}} <b>{{:last}}</b>\r\n      {{/if}}\r\n    </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"Learning points here:",text:'Learning points here:\nFirst, notice that the name reversing feature is entirely declarative. We didn’t write a single line of code. We didn’t even need to modify our data (or define a modified view model) since here we are using plain JavaScript objects, and we are taking the initial value of reverse as falsey – so undefined is fine. If we want to have an initial setting of last-first, we can add it to the data, like this:\nvar data = {\n  reverse: true,\n  people: [\n    {\n      first:"Jeff",\n      ...\n\nClick on Try it and test it out…\nNext, notice that we are binding our if to the reverse at the root level of the data. But the context of the {{if}} is the view for a person – corresponding to the content of the {{for}} tag. So the current data item is a person. To bind to the reverse property on the top-level data object rather than on the person object, we use the syntax {^{if ~root.reverse}}.\n'},{_type:"para",title:"Data-linking class",text:"Data-linking class\nIn the previous page – From rendering to linking – we also used {{if}} to conditionally set a ‘special’ class on a span, as follows:\n<span class=\"{{if role.indexOf('Lead')>=0}}special{{/if}}\">\n\nThe next page shows how we can convert that using data-linked element syntax, so as to dynamically data-link class.\n"},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/data-link/hover":{sections:[{_type:"para",title:"",text:"This is the page seven of a tutorial sequence on data-linking. We show how to link to all the possible targets on an HTML element, such as attributes, styles and class.\nIn the JsRender template on the first page of this tutorial, From rendering to linking, we used DOM level 0 mouse event handlers to show and hide the ‘role details’:\n<span ...\n  onmouseover=\"$('#role_{{:#index}}').show();\"\n  onmouseout=\"$('#role_{{:#index}}').hide();\"\n>\n  ...\n</span>\n\nOn this tutorial page we will convert that feature to use data-linking, and successively show three ways to improve the original approach:\n\nUse a converter to provide the inline code, so as to provide separation of code and markup\nUse attached event handlers, rather than inline code – and use JsViews to find the associated ‘role details’ element without needing to insert IDs into the HTML\nUse data-binding to trigger the hiding/showing from the mouse events\n\n"},{_type:"para",title:"Using a converter to return inline event code",text:"Using a converter to return inline event code\nWe replace the previous inline code by a converter – which actually returns the same code string as in the original version:\n"},{_type:"sample",title:"",url:"samples/data-link/11_linked-hover",text:'<div class="person"\n  onmouseover="{{over:#index}}"\n  onmouseout="{{out:#index}}"\n>\n\n$.views.converters({\n    over: function(id) {\n      return "$(\'#role_" + id + "\').show();"\n    },\n    out: function(id) {\n      return "$(\'#role_" + id + "\').hide();"\n    }\n  }, peopleTmpl);\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing"\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\nvar peopleTmpl = $.templates("#peopleTemplate");\n\n$.views.converters({\n    over: function(id) {\n      return "$(\'#role_" + id + "\').show();"\n    },\n    out: function(id) {\n      return "$(\'#role_" + id + "\').hide();"\n    }\n  }, peopleTmpl);\n\n\npeopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez",\n    role: "Support"\n  });\n});\n<style>\r\n  .person {padding: 3px; margin: 5px;}\r\n  .red-border {border: 1px solid red; display: inline-block; padding: 3px;}\r\n  .details {color: green; border: 2px solid grey; display: none;\r\n             padding: 3px; margin-left :40px;}\r\n  .question {width: 24px; vertical-align: text-bottom;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button id="add">Add person</button>\r\n  {^{for people}}\r\n    <div class="person"\r\n      onmouseover="{{over:#index}}"\r\n      onmouseout="{{out:#index}}"\r\n    >\r\n      <span class="red-border">\r\n        {{:first}} <b>{{:last}}</b>\r\n      </span>\r\n      <img class="question" src="question.jpg"/>\r\n\r\n      <span data-link="role"\r\n        class="details"\r\n        id="role_{{:#index}}" ></span>\r\n    </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"",text:"Notice that we declared our converters just for this peopleTmpl, by passing in the template as the last parameter. See Registering converters.\n"},{_type:"para",title:"Attaching event handlers &ndash; and using $.view(this) to find the associated \"role details' element",text:'Attaching event handlers – and using $.view(this) to find the associated "role details\' element\nFor the second approach, we use attached event handlers, rather than inline code.\nWe don’t need to insert IDs into the rendered HTML elements, since we can get the view for this person we moused over, and find the target element in the context of that view…:\n$.view(this)\n\n$.view(this)\n  .contents(true, ".details")\n  .show()\n\n'},{_type:"sample",url:"samples/data-link/11b_linked-hover",text:'\npeopleTmpl.link("#people", data)\n  .on("mouseover", ".person", function() {\n    // Get the view for this person (the one we moused over...)\n    $.view(this) \n      // Find the element with class "details" within this view\n      .contents(true, ".details") \n      // Make it visible\n      .show();\n  })\n  ...\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing"\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\nvar peopleTmpl = $.templates("#peopleTemplate");\n\npeopleTmpl.link("#people", data)\n  .on("mouseover", ".person", function() {\n    // Get the view for this person (the one we moused over...)\n    $.view(this)\n      // Find the element with class "details" within this view\n      .contents(true, ".details")\n      // Make it visible\n      .show();\n  })\n  .on("mouseout", ".person", function() {\n    $.view(this)\n      .contents(true, ".details")\n      .hide();\n  });\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez",\n    role: "Support"\n  });\n});\n<style>\r\n  .person {padding: 3px; margin: 5px;}\r\n  .red-border {border: 1px solid red; display: inline-block; padding: 3px;}\r\n  .details {color: green; border: 2px solid grey; display: none;\r\n             padding: 3px; margin-left :40px;}\r\n  .question {width: 24px; vertical-align: text-bottom;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button id="add">Add person</button>\r\n  {^{for people}}\r\n    <div class="person">\r\n      <span class="red-border">\r\n        {{:first}} <b>{{:last}}</b>\r\n      </span>\r\n      <img class="question" src="question.jpg"/>\r\n\r\n      <span\r\n        data-link="role"\r\n        class="details"\r\n      ></span>\r\n    </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"Use data-binding to trigger the hiding/showing",text:"Use data-binding to trigger the hiding/showing\nFinally, we’ll replace the code in the mouse handlers which was directly showing/hiding the target HTML element. Instead, we will set a boolean property _show on the data to true/false, and we’ll bind visible of the element to that property:\n"},{_type:"sample",url:"samples/data-link/11c_linked-hover",text:'.on("mouseover", ".person", function() {\n  // Get the person object (the current data item on the view)\n  var person = $.view(this).data;\n\n  // Set the boolean property that we bind "visible" to:\n  $.observable(person).setProperty("_show", true);\n})\n\n<span \n  data-link="\n    {:role}\n    visible{:_show}\n  "\n  class="details"\n></span>\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing"\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\nvar peopleTmpl = $.templates("#peopleTemplate");\n\npeopleTmpl.link("#people", data)\n  .on("mouseover", ".person", function() {\n    // Get the person object (the current data item on the view)\n    var person = $.view(this).data;\n\n    // Set the boolean property that we bind "visible" to:\n    $.observable(person).setProperty("_show", true);\n  })\n  .on("mouseout", ".person", function() {\n    var person = $.view(this).data;\n\n    $.observable(person).setProperty("_show", false);\n  });\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez",\n    role: "Support"\n  });\n});\n<style>\r\n  .person {padding: 3px; margin: 5px;}\r\n  .red-border {border: 1px solid red; display: inline-block; padding: 3px;}\r\n  .details {color: green; border: 2px solid grey; display: none;\r\n             padding: 3px; margin-left :40px;}\r\n  .question {width: 24px; vertical-align: text-bottom;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button id="add">Add person</button>\r\n  {^{for people}}\r\n    <div class="person">\r\n      <span class="red-border">\r\n        {{:first}} <b>{{:last}}</b>\r\n      </span>\r\n      <img class="question" src="question.jpg"/>\r\n\r\n      <span\r\n        data-link="\r\n          {:role}\r\n          visible{:_show}\r\n        "\r\n        class="details"\r\n      ></span>\r\n    </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"",text:"On the next page we move to showing how to data-link CSS styles or attributes.\n"},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/data-link/toggle":{sections:[{_type:"para",title:"",text:"This is the fourth page of a tutorial sequence on data-linking. We show how to convert a complex JsRender template to work in JsViews, using data-linking throughout, and how to link to all the possible targets on an HTML element, such as attributes, styles and class.\nIn the previous page we used data-linking to data-bind the value of the className property of an element to our data.\n"},{_type:"para",title:"Data-linking to toggle <b>one class</b> in a className list",text:"Data-linking to toggle one class in a className list\nIn this page of the tutorial we will show how to use data-link to toggle a class.\nFirst let’s add another class to the <span>, and see what happens to it when we data-link:\n"},{_type:"sample",text:'\n  .person { padding: 3px; margin: 5px; }\n  .special { color: blue; font-style: italic; }\n  .red-border { border: 1px solid red; padding: 3px; }\n\n\n\n\n\n  <button id="add">Add person</button><br /><br />\n  <label><input type="checkbox" data-link="reverse"/> Reverse name</label>\n  {^{for people}}\n    <div class="person">\n      <label><input type="checkbox" data-link="isLead"/> Lead: </label>\n      <span class="red-border"\n        data-link="class{:isLead?\'special\':\'\'}">\n        {^{if ~root.reverse}}\n          <b>{{:last}}</b>, {{:first}}\n        {{else}}\n          {{:first}} <b>{{:last}}</b>\n        {{/if}}\n      </span>\n    </div>\n  {{/for}}\n\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      isLead: true\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak"\n    }\n  ]\n};\n\n$.templates({ \n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez"\n  });\n})\n.red-border { border: 1px solid red; }\n\n<span class="red-border"\n  data-link="class{:isLead?\'special\':\'\'}">\n\n\n'},{_type:"para",title:"",text:'As you see, the red border does not show up, because our data-linking removes the red-border class, and replaces it with "" or "special".\nA simple fix would be to return all of the classes in the data-binding expression. But that assumes we know those classes:\n<span class="red-border"\n  data-link="class{:isLead?\'red-border special\':\'red-border\'}">\n\nAnother fix is to write your own converter, which looks at the element’s className, and computes the return value:\n<span class="red-border"\n  data-link="class{mySmartConverter:isLead?\'special\':\'\'}">\n\nThat is completely possible. But there is an easier way. There is a built-in converter called merge which you can use, which automatically toggles values in a white-space separated list:\n'
},{_type:"para",title:"Using the <b>merge</b> converter to toggle the class",text:"Using the merge converter to toggle the class\nYou just data-link the target (such as class) to a boolean value, add the {merge: converter, and then set the toggle='...' named parameter to the string (the name of your class) that you want to toggle. When the boolean is true, the toggle term will get added to the current value of the target (such as class), treated as a white-space-separated list. When false, it will get removed…:\n<span class=\"red-border\"\n  data-link=\"someTarget{merge:some.boolean.value toggle='someTermInWhiteSpaceSeparatedList'}\">\n\nLet’s use that to toggle our special class within the className list (which includes red-border):\n"},{_type:"sample",text:'\n  .person { padding: 3px; margin: 5px; }\n  .special { color: blue; font-style: italic; }\n  .red-border { border: 1px solid red; padding: 3px; }\n\n\n\n\n\n  <button id="add">Add person</button><br /><br />\n  <label><input type="checkbox" data-link="reverse"/> Reverse name</label>\n  {^{for people}}\n    <div class="person">\n      <label><input type="checkbox" data-link="isLead"/> Lead: </label>\n      <span class="red-border"\n        data-link="class{merge:isLead toggle=\'special\'}">\n        {^{if ~root.reverse}}\n          <b>{{:last}}</b>, {{:first}}\n        {{else}}\n          {{:first}} <b>{{:last}}</b>\n        {{/if}}\n      </span>\n    </div>\n  {{/for}}\n\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      isLead: true\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak"\n    }\n  ]\n};\n\n$.templates({ \n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez"\n  });\n})\n.red-border { border: 1px solid red; }\n\n<span class="red-border"\n  data-link="class{merge:isLead toggle=\'special\'}">\n\n\n'},{_type:"para",title:"",text:"Now the red-border is correctly preserved.\n"},{_type:"para",title:"Using the <b>merge</b> converter to toggle the <b>'- (Lead)'</b> term in the role",text:'Using the merge converter to toggle the \'- (Lead)\' term in the role\nWe can actually use the built-in merge converter also to add and remove the "- (Lead)" string from the role, too.\nThe first thing we do is link the role to the innerText:\n<span data-link="{:role}"></span>\n\n(Note since innerText is the default target of data-link expressions on elements other than form elements – such as <input /> – the above is actually equivalent to writing <span data-link="text{:role}"></span>).\nThen we add to the data-link an additional binding expression to toggle the "- (Lead)" string:\n<span data-link="\n  {:role}\n  {merge:isLead toggle=\'- (Lead)\'}\n"></span>\n\nHere is our ongoing sample with that added in too:\n'},{_type:"sample",text:'\n  .person { padding: 3px; margin: 5px; }\n  .special { color: blue; font-style: italic; }\n  .red-border { border: 1px solid red; padding: 3px; }\n  .details { color: green; border: 2px solid grey;\n             padding: 3px; margin-left :40px; }\n\n\n\n\n\n  <button id="add">Add person</button><br /><br />\n  <label><input type="checkbox" data-link="reverse"/> Reverse name</label>\n  {^{for people}}\n    <div class="person">\n      <label><input type="checkbox" data-link="isLead"/> Lead: </label>\n      <span class="red-border"\n        data-link="class{merge:isLead toggle=\'special\'}">\n        {^{if ~root.reverse}}\n          <b>{{:last}}</b>, {{:first}}\n        {{else}}\n          {{:first}} <b>{{:last}}</b>\n        {{/if}}\n      </span>\n      <span data-link="\n          {:role}\n          {merge:isLead toggle=\'- (Lead)\'}\n        "\n        class="details"\n      ></span>\n  </div>\n  {{/for}}\n\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing",\n      isLead: true\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\n$.templates({ \n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez",\n    role: "Support"\n  });\n})\n\npeople: [\n  {\n    first:"Jeff",\n    last: "Adams",\n    role: "Marketing",\n    isLead: true\n  },\n  {\n    first:"Eugenia",\n    last: "Tyzak",\n    role: "Visiting member"\n  }\n\nLead: <input type="checkbox" data-link="isLead"/>\n<span class="red-border"\n  data-link="class{merge:isLead toggle=\'special\'}">\n  ...\n</span>\n<span data-link="\n    {:role}\n    {merge:isLead toggle=\'- (Lead)\'}\n  "\n  ...\n></span>\n\n\n'},{_type:"para",title:"Toggle multiple classes at the same time",text:"Toggle multiple classes at the same time\nAnd we can even have multiple simultaneous data-link bindings targeting the same list, but toggling different items in the list. Let’s toggle two more classes on the same span, based in whether the reverse boolean (already used for swapping the name order) is true, or false. Set “Reverse name” to true and we will apply a different class for the border color. Set it to false and we will remove that class and add a different one…:\n"},{_type:"sample",url:"samples/data-link/8_toggle-class",text:'\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing",\n      isLead: true\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez",\n    role: "Support"\n  });\n});\n\n<style>\r\n  .person {padding: 3px; margin: 5px;}\r\n  .special {color: blue; font-style: italic;}\r\n  .red-border {border: 1px solid red; padding: 3px;}\r\n  .green-border {border: 2px solid green; padding: 3px;}\r\n  .details {color: green; border: 2px solid grey;\r\n             padding: 3px; margin-left :40px;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button id="add">Add person</button><br /><br />\r\n  <label><input type="checkbox" data-link="reverse"/> Reverse name</label>\r\n  {^{for people}}\r\n    <div class="person">\r\n      <label><input type="checkbox" data-link="isLead"/> Lead: </label>\r\n      <span class="red-border"\r\n        data-link="\r\n          class{merge:isLead toggle=\'special\'}\r\n          class{merge:~root.reverse toggle=\'red-border\'}\r\n          class{merge:!~root.reverse toggle=\'green-border\'}\r\n        ">\r\n        {^{if ~root.reverse}}\r\n          <b>{{:last}}</b>, {{:first}}\r\n        {{else}}\r\n          {{:first}} <b>{{:last}}</b>\r\n        {{/if}}\r\n      </span>\r\n      <span data-link="\r\n          {:role}\r\n          {merge:isLead toggle=\'- (Lead)\'}\r\n        "\r\n        class="details"></span>\r\n  </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"",text:"Here we have covered data-linking the class attribute. You can similarly data-link other attributes.\nThe next page – Data-linking HTML attributes – illustrates that with the title and disabled attributes.\n"},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/data-link/attributes":{sections:[{_type:"para",title:"",text:"This is page five of a tutorial sequence on data-linking. We show how to link to all the possible targets on an HTML element, such as attributes, styles and class.\nIn the previous two pages we explored data-linking the className attribute. Data-linking other HTML attributes is similar.\nWe’ll illustrate that by adding data-linking on the Add person button on our ongoing sample. We’ll data-link the disabled property to disable the button so as to limit to three people in the members list:\n"},{_type:"para",title:"Data-linking the <b>disabled</b> and <b>title</b> attributes",text:"Data-linking the disabled and title attributes\nFirst a really simple sample, to show the data-linking:\n"},{_type:"sample",title:"",text:"\n\n\n\n"},{_type:"para",title:"",text:'Now let’s use that in our ongoing sample. We’ll write:\ndata-link="disabled{:people.length > 2}           \n\nAnd we’ll data-link the title to show a message when it is disabled. Here is the updated sample (which we have simplified by removing the reverse name feature for now, for clarity):\nAdd a person, then mouse over the disabled Add person button to see the title message…\n'},{_type:"sample",url:"samples/data-link/9_linked-attributes",text:'\n\n  Add person\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing",\n      isLead: true\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez",\n    role: "Support"\n  });\n});\n$("#remove").on("click", function() {\n  $.observable(data.people).remove();\n});\n<style>\r\n  .person {padding: 3px; margin: 5px;}\r\n  .special {color: blue; font-style: italic;}\r\n  .red-border {border: 1px solid red; padding: 3px;}\r\n  .details {color: green; border: 2px solid grey;\r\n             padding: 3px; margin-left :40px;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button data-link="\r\n      disabled{:people.length > 2}\r\n      title{:people.length > 2 ? \'The team is complete!\' : null}\r\n    "\r\n    id="add"\r\n  >\r\n    Add person\r\n  </button>\r\n  <button id="remove">Remove last person</button><br />\r\n<br />\r\n  {^{for people}}\r\n    <div class="person">\r\n      <label><input type="checkbox" data-link="isLead"/> Lead:</label>\r\n      <span class="red-border"\r\n        data-link="class{merge:isLead toggle=\'special\'}"\r\n      >\r\n        {{:first}} <b>{{:last}}</b>\r\n      </span>\r\n      <span data-link="\r\n          {:role}\r\n          {merge:isLead toggle=\'- (Lead)\'}\r\n        "\r\n        class="details"\r\n      ></span>\r\n  </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"",text:"On the next page we will make the message more discoverable, by data-linking visibility:\n"},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/data-link/css":{sections:[{_type:"para",title:"",text:"This is page eight of a tutorial sequence on data-linking. We show how to link to all the possible targets on an HTML element, such as attributes, styles and class. Here we show how to data-link CSS styles.\n"},{_type:"para",title:'Data-linking to style is easy: - prepend the name with <b>"css-"</b>',text:'Data-linking to style is easy: - prepend the name with "css-"\nFor example to data-link to the CSS background-color use css-background-color as data-link target:\ndata-link="css-background-color{:dataPathOrExpression}"\n\n'},{_type:"para",title:"Here is a sample showing several examples of CSS attribute binding:",text:"Here is a sample showing several examples of CSS attribute binding:\n"},{_type:"sample",url:"samples/data-link/12_linked-css",text:'Using data-link to bind to CSS attributes on DOM elements:\n<div data-link="\n    css-background-color{:color}\n    css-width{:width}\n    css-height{:height}\n    css-border-width{:thickness}\n    css-border-color{:border}\n  "\n></div>\n\n\n"use strict";\nvar data = {\n  color: "yellow",\n  border: "blue",\n  width: 100,\n  height: 50,\n  thickness: 3\n};\n\nvar svgTmpl = $.templates("#svgTemplate");\n\nsvgTmpl.link("#result", data);\n<div id="result"></div>\r\n\r\n<script id="svgTemplate" type="text/x-jsrender">\r\n  <p>\r\n    Color: <input data-link="color" /><br/>\r\n    Width: <input data-link="width" /><br/>\r\n    Height: <input data-link="height" /><br/>\r\n    Border color: <input data-link="border" /><br/>\r\n    Border thickness: <input data-link="thickness" />\r\n  </p>\r\n  <div style="border-style: solid;"\r\n    data-link="\r\n      css-background-color{:color}\r\n      css-width{:width}\r\n      css-height{:height}\r\n      css-border-width{:thickness}\r\n      css-border-color{:border}\r\n    "\r\n  ></div>\r\n</script>\n'},{_type:"para",title:"",text:"On the next page we will show data-linking SVG elements.\n"},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/data-link/class":{sections:[{_type:"para",title:"",text:"This is the third page of a tutorial sequence on data-linking. We show how to convert a complex JsRender template to work in JsViews, using data-linking throughout, and how to link to all the possible targets on an HTML element, such as attributes, styles and class.\n"},{_type:"para",title:"Data-linking to HTML attributes",text:"Data-linking to HTML attributes\nIn the JsRender template on the first page of this tutorial, From rendering to linking, we had an {{if}} tag inside an HTML attribute:\n<span class=\"{{if role.indexOf('Lead')>=0}}special{{/if}}\">\n\n"},{_type:"para",title:"Rules for a well-formed JsViews template",text:"Rules for a well-formed JsViews template\nYou might think you can convert that to JsViews data-linking by simply adding a ^, like we did elsewhere in the previous page:\n<span class=\"{^{if role.indexOf('Lead')>=0}}special{{/if}}\">\n\nIf you try that (using the Try it button, for example) you will see that it renders incorrectly. Putting JsRender tags like {{if}} within an HTML element tag, including within an attribute value is an example of invalid JsViews template markup. For details on the rules for what is valid, or invalid, within a JsViews template see the JsViews API topic: JsViews template tags.\n"},{_type:"para",title:'Data-linking to "class"',text:'Data-linking to "class"\nThe right way to data-link to class is using data-linked element syntax to link directly to the class attribute as target. (And similarly for linking to the attributes – see Data-linking HTML attributes.)\nHere’s a simple example:\n'},{_type:"sample",text:"\n  .regular { padding 5px; margin: 5px; display: inline-block; }\n  .special { color: green; display: inline-block; border: 2px solid red; padding 15px; margin: 5px; }\n\n\n\n\n\n  <input type=\"checkbox\" data-link=\"isSpecial\" />\n  <div data-link=\"\n      {:isSpecial?'special':'regular'}\n      class{:isSpecial?'special':'regular'}\n    \"></div>\n\nvar data = {\n  isSpecial: false\n};\n\nvar myTmpl = $.templates(\"#myTemplate\");\n\nmyTmpl.link(\"#result\", data);\nWe’ll provide a boolean property in our data:\nvar data = {\n  isSpecial: false\n};\n\n<input type=\"checkbox\" data-link=\"isSpecial\" />\n\nNow we provide a <div>, and bind the innerText:\n<div data-link=\"{:isSpecial?'special':'regular'}\"></div>\n\nThen we add a second data-link expression to bind to class:\n<div data-link=\"\n  {:isSpecial?'special':'regular'}\n  class{:isSpecial?'special':'regular'}\n\"></div>\n\n\n"},{_type:"para",title:"",text:"Note that we get the conditional behavior of the {{if}} simply by using a ternary expression in the data-link tag:\nisLead?'special':'regular'\n\n"},{_type:"para",title:"Back to our ongoing sample...",text:'Back to our ongoing sample...\nLet’s use that approach in our ongoing sample to provide the feature where we can add or remove the “Lead” role and have the class update automatically.\nWe’ll bind to a boolean isLead property on the person object.\npeople: [\n  {\n    first:"Jeff",\n    last: "Adams",\n    role: "Marketing (Lead)",\n    isLead: true\n  },\n  ...\n\nAnd instead of using a data-linked {^{if}} tag, we’ll replace that by direct data-linking on the element, like in our sample above:\n<span data-link="class{:isLead?\'special\':\'\'}">\n\nHere is the sample:\n'},{_type:"sample",title:"Data-linked class attribute",url:"samples/data-link/7_link-to-class",text:'Data-linked class attribute\n\n Lead:\n\n  ...\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      isLead: true\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez"\n  });\n});\n\n<style>\r\n  .person {padding: 3px; margin: 5px;}\r\n  .special {color: blue; font-style: italic;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button id="add">Add person</button><br /><br />\r\n  <label><input type="checkbox" data-link="reverse"/> Reverse name</label>\r\n  {^{for people}}\r\n    <div class="person">\r\n      <label><input type="checkbox" data-link="isLead"/> Lead:</label>\r\n      <span data-link="class{:isLead?\'special\':\'\'}">\r\n        {^{if ~root.reverse}}\r\n          <b>{{:last}}</b>, {{:first}}\r\n        {{else}}\r\n          {{:first}} <b>{{:last}}</b>\r\n        {{/if}}\r\n      </span>\r\n    </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"",text:'In data-linking to class as target, we are actually linking to the HTML className property of the element, which is of course generally a white-space-separated list of class names.\nSo in our current sample we are toggling the value of className between "" and "special", depending on the value of our isLead data property.\nWhat if there are other classes set on the element? Clearly we would like to have our data-linking toggle just one class (the special class) within that list.\nThe next page takes up shows how to use data-linking to toggle a term in a list, and applies that to the class, to achieve that scenario.\n'},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/data-link/visibility":{sections:[{_type:"para",title:"",text:"This is page six of a tutorial sequence on data-linking. We show how to link to all the possible targets on an HTML element, such as attributes, styles and class.\nIn the previous sample, we data-linked the disabled and title attributes.\nTo make the message we displayed through data-linking the title more discoverable to the user, let’s  put it in a span on which we will data-link the visibility.\nThe visible data-link target is a special built-in target in JsViews, which works through the CSS display property. It works by data-linking directly to a boolean property:\n"},{_type:"sample",url:"samples/data-link/10_linked-visibility",text:'Add a person, and you will see this message:\n<span data-link="visible{:people.length > 2}" class="status">\n  The team is complete!\n</span>\n\n\n"use strict";\nvar data = {\n  people: [\n    {\n      first:"Jeff",\n      last: "Adams",\n      role: "Marketing",\n      isLead: true\n    },\n    {\n      first:"Eugenia",\n      last: "Tyzak",\n      role: "Visiting member"\n    }\n  ]\n};\n\n$.templates({\n  peopleTmpl: "#peopleTemplate"\n});\n\n$.templates.peopleTmpl.link("#people", data);\n\n$("#add").on("click", function() {\n  $.observable(data.people).insert({\n    first:"Amos",\n    last: "Sanchez",\n    role: "Support"\n  });\n});\n\n$("#remove").on("click", function() {\n  $.observable(data.people).remove();\n});\n<style>\r\n  .person {padding: 3px; margin: 5px;}\r\n  .special {color: blue; font-style: italic;}\r\n  .red-border {border: 1px solid red; padding: 3px;}\r\n  .details {color: green; border: 2px solid grey;\r\n             padding: 3px; margin-left :40px;}\r\n  .status {color: red; font-style: italic;}\r\n</style>\r\n\r\n<div id="people"></div>\r\n\r\n<script id="peopleTemplate" type="text/x-jsrender">\r\n  <button id="add"\r\n    data-link="\r\n      disabled{:people.length > 2}\r\n      title{:people.length > 2 ? \'The team is complete!\' : null}\r\n    "\r\n  >\r\n    Add person\r\n  </button>\r\n  <button id="remove">Remove last person</button>\r\n  <span data-link="visible{:people.length > 2}" class="status">\r\n    The team is complete!\r\n  </span>\r\n<br /><br />\r\n  {^{for people}}\r\n    <div class="person">\r\n      <label><input type="checkbox" data-link="isLead"/> Lead:</label>\r\n      <span class="red-border"\r\n        data-link="class{merge:isLead toggle=\'special\'}">\r\n          {{:first}} <b>{{:last}}</b>\r\n      </span>\r\n      <span data-link="\r\n          {:role}\r\n          {merge:isLead toggle=\'- (Lead)\'}\r\n        "\r\n        class="details"></span>\r\n  </div>\r\n  {{/for}}\r\n</script>\n'},{_type:"para",title:"",text:"Now, here are two more samples using data-linked visibility:\n\nThe Form elements and data-linked visibility sample\nThe Tree with ‘visible’ binding sample\n\nBut let’s also use visible data-linking to hide and show the details blocks when the user hovers over the name – following the feature used in the original JsRender template version. The next page explores three different approaches to doing just that.\n"},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/data-link/svg":{sections:[{_type:"para",title:"",text:"This is page nine of a tutorial sequence on data-linking. We show how to link to all the possible targets on an HTML element, such as attributes, styles and class. Here we show how to data-link different properties of SVG elements.\n"},{_type:"sample",url:"samples/data-link/13_linked-svg",text:'Using data-link to bind to svg elements:\n<svg class="svg">\n  <ellipse stroke-width="2" rx="140" ry="50"\n    data-link="\n      cx{:x}\n      cy{:y}\n      fill{:color}\n      stroke{:textcolor}\n      transform{:\'rotate(\' + angle + \' \' + x + \' \' + y + \')\'}\n    "\n  ></ellipse>\n  <text data-link="\n      x{:x}\n      y{:y}\n      fill{:textcolor}\n      text{:text}\n      transform{:\'rotate(\' + angle + \' \' + x + \' \' + y + \')\'}\n    "\n  ></text>\n</svg>\n\n\n"use strict";\nvar data = {\n  x: 300,\n  y: 140,\n  text: "An SVG spin",\n  color: "yellow",\n  textcolor: "blue",\n  angle: 30\n};\n\nvar svgTmpl = $.templates("#svgTemplate");\n\nsvgTmpl.link("#result", data);\n<div id="result"></div>\r\n\r\n<script id="svgTemplate" type="text/x-jsrender">\r\n  <p>\r\n    Text: <input data-link="text" /><br/>\r\n    x: <input data-link="x" /><br/>\r\n    y: <input data-link="y" /><br/>\r\n    Text color: <input data-link="textcolor" /><br/>\r\n    Color: <input data-link="color" /><br/>\r\n    Rotate: <input data-link="angle" />\r\n  </p>\r\n\r\n  <svg class="svg">\r\n    <ellipse stroke-width="2" rx="140" ry="50"\r\n      data-link="\r\n        cx{:x}\r\n        cy{:y}\r\n        fill{:color}\r\n        stroke{:textcolor}\r\n        transform{:\'rotate(\' + angle + \' \' + x + \' \' + y + \')\'}\r\n      "\r\n    ></ellipse>\r\n    <text data-link="\r\n        x{:x}\r\n        y{:y}\r\n        fill{:textcolor}\r\n        text{:text}\r\n        transform{:\'rotate(\' + angle + \' \' + x + \' \' + y + \')\'}\r\n      "\r\n    ></text>\r\n  </svg>\r\n</script>\n'},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/data-link":{sections:[{_type:"para",title:"",text:"This sequence of sample pages is a tutorial showing the multiple possibilities of data-linking. We start with showing how to convert a complex JsRender template to work in JsViews, using data-linking throughout.\n"},{_type:"links",title:"",text:""},{_type:"para",title:"See also the JsViews API topics:",text:"See also the JsViews API topics:\nData-linked tagsData-linked elements"},{_type:"links",title:"See also:",text:"See also:\n"}]},"samples/tag-controls/range":{sections:[{_type:"para",title:"",text:"This sample takes the {{range}} tag from the JsRender Extending the {{for}} tag sample, and adds data-linking to it.\n"},{_type:"sample",url:"samples/tag-controls/range/sample",text:'We use the {{range}} custom tag to create a drop-down to select an integer between 1 and 10 as the start integer (…and similarly for the end integer):\n<select data-link="{:start:strToInt}">\n  {^{range start=1 end=10}}\n    <option>{{:#data}}</option>\n  {{/range}}\n</select>\n\nThen we again use the {{range}} tag to show a partial list of team members:\n<ul>\n  {^{range members start=start-1 end=end}}\n    <li>\n      {^{:#index + ~root.start}}. {^{:name}}\n    </li>\n  {{else}}\n    <li>No items</li>\n  {{/range}}\n</ul>\n\nNote that by default, named properties like start=start-1 are not data-bound. (This is made ‘opt-in’ for perf optimization reasons.) However in this case, our {{range}} tag implementation has start and end specified as bound properties:\n$.views.tags({\n  range: {\n    boundProps: ["start", "end"],\n    baseTag: "for",\n    ...\n\nSo observable changes to the start and end properties automatically trigger updates.\n(If not declared as boundProps we would have needed to use the syntax: ^start=start-1.)\n\n/*! Sample JsViews tag control: {{range}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n// An extended {{for}} tag: {{range}} inherits from {{for}}, and adds\n// support for iterating over a range (start to end) of items within an array,\n// or for iterating directly over integers from start integer to end integer\n\n$.views.tags({\n  range: {\n    boundProps: ["start", "end"],\n\n    // Inherit from {{for}} tag\n    baseTag: "for",\n\n    // Override the render method of {{for}}\n    render: function(val) {\n      var array = val,\n        tagCtx = this.tagCtx,\n        start = tagCtx.props.start || 0,\n        end = tagCtx.props.end,\n        props = tagCtx.params.props;\n\n      if (start || end) {\n        if (!tagCtx.args.length) { // No array argument passed from tag, so create\n                                   // a computed array of integers from start to end\n\n          array = [];\n          end = end || 0;\n          for (var i = start; i <= end; i++) {\n            array.push(i);\n          }\n        } else if ($.isArray(array)) { // There is an array argument and start and end\n                 // properties,so render using the array truncated to the chosen range\n          array = array.slice(start, end);\n        }\n      }\n\n      // Call the {{for}} baseTag render method\n      return arguments.length || props && (props.start || props.end)\n        ? this.base(array)\n        : this.base(); // Final {{else}} tag, so call base() without arguments, for\n                       // final {{else}} of base {{for}} tag\n    },\n\n    // override onArrayChange of the {{for}} tag implementation\n    onArrayChange: function(ev, eventArgs) {\n      this.refresh();\n    }\n  }\n});\n\n})(this.jQuery);\n\n"use strict";\n$.views.converters({\n    strToInt: function(value) {\n      return parseInt(value);\n    }\n  });\n\nvar team = {\n  start: 2,\n  end: 4,\n  members: [\n    {name: "Robert"},\n    {name: "Sarah"},\n    {name: "Xavier"},\n    {name: "Adriana"}\n  ]\n},\ncnt = 1;\n\n$.templates("#teamTemplate").link("#team", team)\n  .on("click", ".remove", function() {\n    var view = $.view(this);\n    $.observable(team.members).remove(view.index);\n  })\n  .on("click", "#add", function() {\n    $.observable(team.members).insert(0, {name: "new" + cnt++})\n  });\n<div id="team"></div>\r\n\r\n<script id="teamTemplate" type="text/x-jsrender">\r\n\r\n<div class="left">\r\n  <b>Choose the range</b><br/><br/>\r\n\r\n  Start:\r\n  <select data-link="{:start:strToInt}">\r\n    {^{range start=1 end=10}}\r\n      <option>{{:#data}}</option>\r\n    {{/range}}\r\n  </select>\r\n\r\n  End:\r\n  <select data-link="{:end:strToInt}">\r\n    {^{range start=1 end=10}}\r\n      <option>{{:#data}}</option>\r\n    {{/range}}\r\n  </select>\r\n\r\n  <ul>\r\n    {^{range members start=start-1 end=end}}\r\n      <li>\r\n        {^{:#index + ~root.start}}. {^{:name}}\r\n      </li>\r\n    {{else}}\r\n      <li>No items</li>\r\n    {{/range}}\r\n  </ul>\r\n</div>\r\n\r\n<div class="left">\r\n  <b>Edit the list</b><br/><br/>\r\n  <div class="buttons">\r\n    <button id="add">Add</button>\r\n  </div>\r\n\r\n  <ol>\r\n    {^{for members}}\r\n      <li>\r\n        <input data-link="name" />\r\n        <span class="remove"></span>\r\n      </li>\r\n    {{/for}}\r\n  </ol>\r\n</div>\r\n\r\n</script>\n'}]},"samples/computed":{sections:[{_type:"links",title:"",text:""}]},"samples/computed/fullname":{sections:[{_type:"para",title:"",text:"This sample consists of three variants of the same sample - with a fullName() computed observable.\n\nUsing plain JavaScript objects as instance data - with the computed fullName() as a computed property\nUsing a View Model approach, with the computed fullName() as a computed property on the prototype\nUsing plain JavaScript objects as instance data – with the computed fullName() as a helper function\n\n"},{_type:"sample",title:"Computed data properties (declared on plain object instance)",url:"samples/computed/fullname/data",text:'Computed data properties (declared on plain object instance)\nvar person = {\n  ...\n  fullName: fullName\n};\n\n// Parameterized computed observable\nfunction fullName(reversed) { ... }\n\nfullName.depends = "*"; // Listen to changes to ANY property of the object (person)\n\n// Two-way binding: provide a setter\nfullName.set = function(val) {\n  val = val.split(" ");\n  // Make observable change to dependent properties\n  $.observable(this).setProperty({\n    lastName: val.pop(),\n    firstName: val.join(" ")\n  });\n};\n\n\n"use strict";\n//====================== Data ======================\nvar person = {\n  firstName: "Jeff",\n  lastName: "Friedman",\n  fullName: fullName // Computed fullName\n};\n\n// Parameterized computed observable\nfunction fullName(reversed) {\n  // We will declare dependencies (below) for any values that\n  // may change observably, and are not passed in as parameters\n  return reversed\n    ? this.lastName + " " + this.firstName\n    : this.firstName + " " + this.lastName;\n}\n\n// Declare dependencies, except for any values passed in as parameters\nfullName.depends = "*"; // Listen to changes to ANY property of the object (person)\n\n// Setter for fullName - for two-way binding\nfullName.set = function(val) {\n  val = val.split(" ");\n  // Make observable change to dependent properties\n  $.observable(this).setProperty({\n    lastName: val.pop(),\n    firstName: val.join(" ")\n  });\n};\n\nvar tmpl = $.templates("#personTmpl");\ntmpl.link("#details", person);\n\n//================ Observable property change ================\n$("#changeName").on("click", function() {\n  $.observable(person).setProperty({\n    firstName: person.firstName + "x",\n    lastName: person.lastName + "y"\n  });\n});\n\n<p><button id="changeName">Change name</button></p>\r\n\r\n<!--====== Container ======-->\r\n<div id="details"></div>\r\n\r\n<!--====== Template ======-->\r\n<script id="personTmpl" type="text/x-jsrender">\r\n<div class="box">\r\n  <div class="subhead">Data-linking to a computed observable:</div>\r\n\r\n  <table><tbody>\r\n    <tr>\r\n      <td>first:</td>\r\n      <td data-link="firstName"></td>\r\n      <td><input data-link="firstName" /></td>\r\n    </tr>\r\n    <tr>\r\n      <td>last:</td>\r\n      <td data-link="lastName"></td>\r\n      <td><input data-link="lastName" /></td>\r\n    </tr>\r\n    <tr>\r\n      <td>full name:</td>\r\n      <td data-link="fullName()"></td>\r\n      <td><input data-link="fullName()" /></td>\r\n    </tr>\r\n    <tr>\r\n      <td>reversed full name:</td>\r\n      <td colspan="2" data-link="fullName(true)"></td>\r\n    {{!-- Parameterized setter not supported\r\n      <td><input data-link="fullName(true)" /></td>\r\n    --}}\r\n    </tr>\r\n  </tbody></table>\r\n</div>\r\n\r\n<div class="box">\r\n  <div class="subhead">Data-bound tag &mdash; bound to a computed observable:</div>\r\n  {{!-- data-bound tag--}}\r\n  {^{>fullName(true)}}\r\n</div>\r\n</script>\n'
},{_type:"sample",title:"Computed data properties (declared on prototype) &ndash; View Model approach",url:"samples/computed/fullname/prototype",text:'Computed data properties (declared on prototype) – View Model approach\n// Constructor\nfunction Person(first, last) {\n  this.firstName = first;\n  this.lastName = last;\n}\n\n// Prototype\nPerson.prototype = {\n  fullName: fullName // Computed fullName\n};\n\nvar person = new Person("Jeff", "Friedman");\n\n// Parameterized computed observable\nfunction fullName(reversed) { ... }\n\nfullName.depends = "*"; // Listen to changes to ANY property of the object (person)\n\n// Two-way binding: provide a setter\nfullName.set = function(val) { ... };\n\n\n"use strict";\n//====================== Data ======================\n// Constructor\nfunction Person(first, last) {\n  this.firstName = first;\n  this.lastName = last;\n}\n\n// Prototype\nPerson.prototype = {\n  fullName: fullName // Computed fullName\n};\n\nvar person = new Person("Jeff", "Friedman");\n\n// Parameterized computed observable\nfunction fullName(reversed) {\n  // We will declare dependencies (below) for any values that\n  // may change observably, and are not passed in as parameters\n  return reversed\n    ? this.lastName + " " + this.firstName\n    : this.firstName + " " + this.lastName;\n}\n\nfullName.depends = "*"; // Listen to changes to ANY property of the object (person)\n\n// Setter for fullName - for two-way binding\nfullName.set = function(val) {\n  val = val.split(" ");\n  // Make observable change to dependent properties\n  $.observable(this).setProperty({\n    lastName: val.pop(),\n    firstName: val.join(" ")\n  });\n};\n\nvar tmpl = $.templates("#personTmpl");\ntmpl.link("#details", person);\n\n//================ Observable property change ================\n$("#changeName").on("click", function() {\n  $.observable(person).setProperty({\n    firstName: person.firstName + "x",\n    lastName: person.lastName + "y"\n  });\n});\n\n<p><button id="changeName">Change name</button></p>\r\n\r\n<!--====== Container ======-->\r\n<div id="details"></div>\r\n\r\n<!--====== Template ======-->\r\n<script id="personTmpl" type="text/x-jsrender">\r\n<div class="box">\r\n  <div class="subhead">Data-linking to a computed observable:</div>\r\n\r\n  <table><tbody>\r\n    <tr>\r\n      <td>first:</td>\r\n      <td data-link="firstName"></td>\r\n      <td><input data-link="firstName" /></td>\r\n    </tr>\r\n    <tr>\r\n      <td>last:</td>\r\n      <td data-link="lastName"></td>\r\n      <td><input data-link="lastName" /></td>\r\n    </tr>\r\n    <tr>\r\n      <td>full name:</td>\r\n      <td data-link="fullName()"></td>\r\n      <td><input data-link="fullName()" /></td>\r\n    </tr>\r\n    <tr>\r\n      <td>reversed full name:</td>\r\n      <td colspan="2" data-link="fullName(true)"></td>\r\n    {{!-- Parameterized setter not supported\r\n      <td><input data-link="fullName(true)" /></td>\r\n    --}}\r\n    </tr>\r\n  </tbody></table>\r\n</div>\r\n\r\n<div class="box">\r\n  <div class="subhead">Data-bound tag &mdash; bound to a computed observable:</div>\r\n  {{!-- data-bound tag--}}\r\n  {^{>fullName(true)}}\r\n</div>\r\n</script>\n'},{_type:"sample",title:"Computed data properties (using computed helper)",url:"samples/computed/fullname/helper",text:'Computed data properties (using computed helper)\nvar people = [\n  {firstName: "Jeff", lastName: "Friedman"},\n  ...\n];\n\n// Parameterized computed observable - passed in as a helper\nfunction fullName(reverse) {\n  // \'this\' for a helper is the view object - and view.data gives\n  // us the appropriate instance of \'person\' in the people array\n  var view = this, person = view.data;\n  return reverse ? ... : ...;\n}\nfullName.depends = "*"; // Listen to changes to ANY property of the object (person)\n\n// Setter for fullName - for two-way binding\nfullName.set = function(val) {\n  // \'this\' for the setter on a helper is the view object - and view.data\n  // gives us the appropriate instance of \'person\' in the people array\n  var view = this, person = view.data;\n  val = val.split(" ");\n  // Make observable change to dependent properties\n  $.observable(person).setProperty({ ... });\n};\n\nvar tmpl = $.templates("#personTmpl");\n\n// Pass in computed observable fullName as a helper\ntmpl.link("#details", people, {fullName: fullName});\n\n\n"use strict";\nvar people = [\n  {\n    firstName: "Jeff",\n    lastName: "Friedman"\n  },\n  {\n    firstName: "Henrietta",\n    lastName: "Hawks"\n  }\n];\n\n// Parameterized computed observable - passed in as a helper\nfunction fullName(reverse) {\n  // We will declare dependencies (below) for any values that\n  // may change observably, and are not passed in as parameters\n\n  // \'this\' for a helper is the view object - and view.data gives\n  // us the appropriate instance of \'person\' in the people array\n  var view = this, person = view.data;\n  return reverse\n    ? person.lastName + " " + person.firstName\n    : person.firstName + " " + person.lastName;\n}\n\nfullName.depends = "*"; // Listen to changes to ANY property of the object (person)\n\n// Setter for fullName - for two-way binding\nfullName.set = function(val) {\n  // \'this\' for the setter on a helper is the view object - and view.data\n  // gives us the appropriate instance of \'person\' in the people array\n  var view = this, person = view.data;\n  val = val.split(" ");\n  // Make observable change to dependent properties\n  $.observable(person).setProperty({\n    lastName: val.pop(),\n    firstName: val.join(" ")\n  });\n};\n\nvar tmpl = $.templates("#personTmpl");\n\n// Pass in computed observable fullName as a helper\ntmpl.link("#details", people, {fullName: fullName});\n\n//================ Observable property change ================\n$("#changeNames").on("click", function() {\n  $.observable(people[0]).setProperty({\n    firstName: people[0].firstName + "x",\n    lastName: people[0].lastName + "y"\n  });\n  $.observable(people[1]).setProperty({\n    firstName: people[1].firstName + "w",\n    lastName: people[1].lastName + "z"\n  });\n});\n\n<p><button id="changeNames">Change names</button></p>\r\n\r\n<!--====== Container ======-->\r\n<div id="details"></div>\r\n\r\n<!--====== Template ======-->\r\n<script id="personTmpl" type="text/x-jsrender">\r\n<div class="box">\r\n  <div class="subhead">Data-linking to a computed observable:</div>\r\n\r\n  <table><tbody>\r\n    <tr>\r\n      <td>first:</td>\r\n      <td data-link="firstName"></td>\r\n      <td><input data-link="firstName" /></td>\r\n    </tr>\r\n    <tr>\r\n      <td>last:</td>\r\n      <td data-link="lastName"></td>\r\n      <td><input data-link="lastName" /></td>\r\n    </tr>\r\n    <tr>\r\n      <td>full name:</td>\r\n      <td data-link="~fullName()"></td>\r\n      <td><input data-link="~fullName()" /></td>\r\n    </tr>\r\n    <tr>\r\n      <td>reversed full name:</td>\r\n      <td colspan="2" data-link="~fullName(true)"></td>\r\n    {{!-- Parameterized setter not supported\r\n      <td><input data-link="~fullName(true)" /></td>\r\n    --}}\r\n    </tr>\r\n  </tbody></table>\r\n</div>\r\n\r\n<div class="box">\r\n  <div class="subhead">Data-bound tag &mdash; bound to a computed observable:</div>\r\n  {{!-- data-bound tag--}}\r\n  {^{>~fullName(true)}}\r\n</div>\r\n</script>\n'}]},"samples/computed/shopping-cart":{sections:[{_type:"para",title:"",text:'This sample illustrates:\n\nComputed observables (totalAmount() with dependency "items.**" – see additional discussion)\nDeclarative events\n\nIt has two versions:\n\nThe first uses top-level data-linking\nThe second uses the usual linked templates approach\n\n'},{_type:"sample",title:"Shopping cart (top-level data-linking)",url:"samples/computed/shopping-cart/top-level",text:'Shopping cart (top-level data-linking)\nThe totalAmount() computed observable has the ** all wild card in its depends path – to indicate dependency on any changes under the items array:\ntotalAmount.depends = "items.**";\n\nTop-level data-linking is used for:\n\nlinked template binding using data-link="{for items tmpl=\'#itemTmpl\'}"\ncomputed observable binding: data-link="total()"\ndeclarative event binding: data-link="{on add}", data-link="{on ~root.remove}"\n\nHTML:\n<table>\n  ...\n  <tbody data-link="{for items tmpl=\'#itemTmpl\'}"></tbody>\n  ...\n  <span data-link="items.length"></span>\n  ...\n  <td class="add" data-link="{on add}">Add</td>\n  ...\n  <span colspan="2" data-link="total()"></span>\n  ...\n</table>\n\n<script id="itemTmpl" type="text/x-jsrender">\n  ...\n  <span data-link="price*quantity"></span>\n  <span class="remove" data-link="{on ~root.remove}"></span>\n  ...\n</script>\n\nCode:\nvar shoppingCart = {\n  add: addItem,\n  remove: removeItem,\n  total: totalAmount,\n  items: [...]\n};\n\nfunction addItem() { ... }\nfunction removeItem() { ... }\nfunction totalAmount() { ... }\n\ntotalAmount.depends = "items.**"; // totalAmount depends on any changes under the items array \n\n$.link(true, "#shoppingcart", shoppingCart); // Top-level data-linking\n\n\n"use strict";\nvar shoppingCart = {\n  add: addItem,\n  remove: removeItem,\n  total: totalAmount,\n  items: [\n    {product: "Pot", price:  10, quantity: 3},\n    {product: "Kettle", price:  15.5, quantity: 23}\n  ],\n  show: true\n};\n\nfunction addItem() {\n  $.observable(this.items).insert({\n    product: "new",\n    price:  1,\n    quantity: 1\n    });\n}\n\t\nfunction removeItem(ev, eventArgs) {\n  $.observable(this.items).remove(eventArgs.view.index);\n}\n\nfunction totalAmount() {\n  var amount = 0,\n    l = this.items.length;\n  while (l--) {\n    amount += this.items[l].price * this.items[l].quantity;\n  }\n  return amount;\n}\n\ntotalAmount.depends = "items.**";\n// totalAmount depends on any changes under the items array\n\n$.link(true, "#shoppingcart", shoppingCart);\n\n<title>Computed observable - Shopping cart</title>\r\n\r\n<table id="shoppingcart" class="nowidth" style="display:none" data-link="visible{:show}">\r\n<thead>\r\n  <tr><td>Product</td><td>Price</td><td>Quantity</td><td>Amount</td></tr>\r\n</thead>\r\n<tbody data-link="{for items tmpl=\'#itemTmpl\'}"></tbody>\r\n<tfoot>\r\n  <tr><td colspan="3">No. of items:\r\n    <span data-link="items.length"></span>\r\n  </td>\r\n  <td class="add" data-link="{on add}">Add</td></tr>\r\n  <tr><td colspan="4">Total amount:\r\n    <span colspan="2" data-link="total()"></span>\r\n  </td></tr>\r\n</tfoot>\r\n</table>\r\n\r\n<script id="itemTmpl" type="text/x-jsrender">\r\n  <tr>\r\n    <td><input data-link="product" /></td>\r\n    <td><input data-link="price" /></td>\r\n    <td><input data-link="quantity" /></td>\r\n    <td >\r\n      <span class="floatleft" data-link="price*quantity"></span>\r\n      <span class="remove" data-link="{on ~root.remove}"></span>\r\n    </td>\r\n  </tr>\r\n</script>\n'},{_type:"para",title:"",text:"The second version is identical in behavior, but it uses a linked template, rather than top-level data linking:\n"},{_type:"sample",title:"Shopping cart (linked template)",url:"samples/computed/shopping-cart/tmpl",text:'Shopping cart (linked template)\nThe totalAmount() computed observable has the ** all wild card in its depends path – to indicate dependency on any changes under the items array:\ntotalAmount.depends = "items.**";\n\nThe sample uses a linked template, which includes:\n\ncomputed observable binding: data-link="total()"\ndeclarative event binding: data-link="{on add}", data-link="{on ~root.remove}"\n\nTemplate:\n<table>\n  ...\n  {^{for items}}\n    ...\n    <span data-link="price*quantity"></span>\n    <span class="remove" data-link="{on ~root.remove}"></span>\n    ...\n  {{/for}}\n  ...\n  <span data-link="items.length"></span>\n  ...\n  <td class="add" data-link="{on add}">Add</td>\n  ...\n  <span colspan="2" data-link="total()"></span>\n  ...\n</table>\n\nCode:\nvar shoppingCart = {\n  add: addItem,\n  remove: removeItem,\n  total: totalAmount,\n  items: [...]\n};\n\nfunction addItem() { ... }\nfunction removeItem() { ... }\nfunction totalAmount() { ... }\n\ntotalAmount.depends = "items.**"; // totalAmount depends on any changes under the items array \n\nvar tmpl = $.templates("#cartTmpl");\ntmpl.link("#shoppingcart", shoppingCart);\n\n\n"use strict";\nvar shoppingCart = {\n  add: addItem,\n  remove: removeItem,\n  total: totalAmount,\n  items: [\n    {product: "Pot", price:  10, quantity: 3},\n    {product: "Kettle", price:  15.5, quantity: 23}\n  ],\n  show: true\n};\n\nfunction addItem() {\n  $.observable(this.items).insert({\n    product: "new",\n    price:  1,\n    quantity: 1\n    });\n}\n\t\nfunction removeItem(ev, eventArgs) {\n  $.observable(this.items).remove(eventArgs.view.index);\n}\n\nfunction totalAmount() {\n  var amount = 0,\n    l = this.items.length;\n  while (l--) {\n    amount += this.items[l].price * this.items[l].quantity;\n  }\n  return amount;\n}\n\ntotalAmount.depends = "items.**";\n// totalAmount depends on any changes under the items array\n\nvar tmpl = $.templates("#cartTmpl");\ntmpl.link("#shoppingcart", shoppingCart);\n\n<title>Computed observable - Shopping cart</title>\r\n\r\n<div  id="shoppingcart"></div>\r\n\r\n<script id="cartTmpl" type="text/x-jsrender">\r\n  <table class="nowidth">\r\n  <thead>\r\n    <tr><td>Product</td><td>Price</td><td>Quantity</td><td>Amount</td></tr>\r\n  </thead>\r\n  <tbody>\r\n    {^{for items}}\r\n      <tr>\r\n        <td><input data-link="product" /></td>\r\n        <td><input data-link="price" /></td>\r\n        <td><input data-link="quantity" /></td>\r\n        <td >\r\n          <span class="floatleft" data-link="price*quantity"></span>\r\n          <span class="remove" data-link="{on ~root.remove}"></span>\r\n        </td>\r\n      </tr>\r\n    {{/for}}\r\n  </tbody>\r\n  <tfoot>\r\n    <tr><td colspan="3">No. of items:\r\n      <span data-link="items.length"></span>\r\n    </td>\r\n    <td class="add" data-link="{on add}">Add</td></tr>\r\n    <tr><td colspan="4">Total amount:\r\n      <span colspan="2" data-link="total()"></span>\r\n    </td></tr>\r\n  </tfoot>\r\n  </table>\r\n</script>\n'}]},"samples/tag-controls/jsonview":{sections:[{_type:"para",title:"",text:"This sample shows the {{jsonview/}} control, which is available from downloads/tag-controls.\nThe {{jsonview}} tag control can be included in any JsViews page, to show the contextual data at that place in the page, or to show given data returned by an expression {^{jsonview someExpression /}}. Changes to the data will then update dynamically.\nThe following sample (shown also in the Data-linked template tag: {^{props …}} topic) illustrates the use of {{jsonview}}:\n"},{_type:"sample",url:"samples/tag-controls/jsonview/sample",text:'Template:\n...\n<ul>\n  {^{props members}}\n    <li>\n      ...\n      <input data-link="key"/>\n      {^{>key}}\n      <input data-link="prop^name"/>\n      {^{>prop^name}}\n      ...\n    </li>\n  {{else}}\n    ...\n  {{/props}}\n</ul>\n...\n{^{jsonview/}}\n...\n\n\n"use strict";\nvar team = {\n  members: {\n    m1: {name: "Robert"},\n    m2: {name: "Sarah"}\n  },\n  addMember: function() {\n    $.observable(this.members).setProperty("n" + cnt, {name: "new" + cnt++});\n  }, \n  removeMember: function(key) {\n    $.observable(this.members).removeProperty(key);\n  },\n  replaceMembers: function() {\n    $.observable(this).setProperty("members", {m1: {name: "Peter"}, m2: {name: "Octavia"}, m3: {name: "Xavier"}});\n  },\n  changeMembers: function() {\n    for (var property in this.members) {\n      if (property !== $.expando) {\n        $.observable(this.members).setProperty(property, {name: this.members[property].name + cnt++});\n      }\n    }\n  }\n},\ncnt = 1;\n\n$.templates("#teamTemplate").link("#team", team);\n\n/*! Sample JsViews tag control: {{jsonview}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n*/\n\n(function($) {\n  "use strict";\n\n  function isObject(val) {\n    return val && typeof val === "object";\n  }\n\n  function notEmpty(val) {\n    return $.views.tags.props.dataMap.getTgt(val).length;\n  }\n\n  notEmpty.depends = "*";\n\n  $.views.tags("jsonview", {\n    template: {\n      markup:\n        \'{{if ~isArray(#data)}}\'\n        + \'<span class="jsonview"><span class="brace">[</span>{^{if length}}\'\n          + \'<ul class="jsonview">\'\n            + \'{^{for}}\'\n              + \'<li>{^{jsonview/}}{^{if #index < #parent.data.length-1}},{{/if}}</li>\'\n            + \'{{/for}}\'\n          + \'</ul>\'\n        + \'{{/if}}<span class="brace">]</span></span>\'\n      + \'{{else ~isObject(#data)}}\'\n        + \'<span class="jsonview"><span class="brace">{</span>{^{if ~notEmpty(#data)}}\'\n          + \'<ul class="jsonview">\'\n            + \'{^{props}}\'\n              + \'<li>\'\n                + \'<label>{^{>key}}: </label>\'\n                + \'{^{jsonview prop/}}{^{if #index < #parent.data.length-1}},{{/if}}\'\n              + \'</li>\'\n            + \'{{/props}}\'\n          + \'</ul>\'\n        + \'{{/if}}<span class="brace">}</span></span>\'\n      + \'{{else #data+""===#data}}\'\n        + \'"{^{>#data}}"\'\n      + \'{{else}}\'\n        + \'{^{>#data+""}}\'\n      + \'{{/if}}\',\n      helpers: {\n        isObject: isObject,\n        notEmpty: notEmpty,\n        isArray: $.isArray\n      }\n    }\n  });\n})(this.jQuery);\n\n<div id="team"></div>\r\n\r\n<script id="teamTemplate" type="text/x-jsrender">\r\n  <div class="left">\r\n    <button data-link="{on addMember}">Add</button>\r\n    <button data-link="{on replaceMembers}">Replace</button>\r\n    <button data-link="{on changeMembers}">Change</button>\r\n    <ul>\r\n      {^{props members}}\r\n        <li>\r\n          {^{:#index+1}}.\r\n          <input data-link="key"/>\r\n          {^{>key}}\r\n          <input data-link="prop^name"/>\r\n          {^{>prop^name}}\r\n          <span class="remove" data-link="{on ~root.removeMember key}"></span>\r\n        </li>\r\n      {{else}}\r\n        <li>No members...</li>\r\n      {{/props}}\r\n    </ul>\r\n  </div>\r\n  <div class="right">\r\n    <em><b>Data:</b></em><br/>{^{jsonview/}}\r\n  </div>\r\n</script>\n'}]},"samples/tag-controls/jqui/accordion":{sections:[{_type:"para",title:"",text:'The {{accordion}} tag control integrates the jQuery UI accordion widget (api).\nWhen using tag syntax, the tag wraps directly the container element (which wraps the markup for the panels):\n{^{accordion ...}}\n  <div>\n    <h3>Section 1</h3>\n    <div>Panel 1 content</div>\n    ...    ...\n  </div>\n{{/accordion}}\n\nThe tag can also be used wrapping the panel elements directly, and with the elem=... property specifying a container element. (The tag will render the container element):\n{^{accordion ... elem="div"}}\n  <h3>Section 1</h3>\n  <div>Panel 1 content</div>\n  ...    ...\n{{/accordion}}\n\nAlternatively, the accordion tag binding can be used with a data-linked wrapper element:\n<div data-link="{accordion ...}">\n  <h3>Section 1</h3>\n  <div>Panel 1 content</div>\n  ...    ...\n</div>\n\nThe following sample shows two accordions – one using tag syntax, and the other using element syntax, and is a declarative data-driven version of the jQuery UI Accordion – Collapse content demo.\n'},{_type:"sample",title:"Collapsible accordion",text:'Collapsible accordion\n\n\n<h4>Tag syntax:</h4>\n\n<pre>\n&lcub;^{accordion ...}&rcub;...&lcub;^{/accordion}&rcub;\n</pre>\n\n<!--tag syntax-->\n{^{accordion _collapsible=true elem="div"}}\n  <h3>Section 1</h3>\n  <div>\n    <p><em>Click header again to close panel.</em></p>\n    <p>Mauris mauris ante, blandit et, ultrices a, suscipit eget, quam.</p>\n  </div>\n  <h3>Section 2</h3>\n  <div>\n    <p><em>Click header again to close panel.</em></p>\n    <p>Sed non urna. Donec et ante.</p>\n  </div>\n  <h3>Section 3</h3>\n  <div>\n    <p><em>Click header again to close panel.</em></p>\n    <ul>\n      <li>List item one</li>\n      <li>List item two</li>\n    </ul>\n  </div>\n{{/accordion}}\n\n<h4>Element-based data-link syntax:</h4>\n\n<pre>\n&lt;div data-link="{accordion _collapsible=true}">...&lt;/div>\n</pre>\n\n<!--alternative data-linked element syntax-->\n<div data-link="{accordion _collapsible=true}">\n  <h3>Not latin</h3>\n  <div>\n    <p><em>Click header to close.</em></p>\n    <p>First non-latin text.</p>\n  </div>\n  <h3>Section two</h3>\n  <div>\n    <p><em>Click header to close.</em></p>\n    <p>Second text.</p>\n  </div>\n  <h3>Section three</h3>\n  <div>\n    <p><em>Click header to close.</em></p>\n    <p>Further content.</p>\n  </div>\n</div>\n\n\n\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {};\n\npageTmpl.link("#page", model);\nTag syntax:\n{^{accordion _collapsible=true elem="div"}}\n  <h3>Section 1</h3>\n  <div>...</div>\n  <h3>Section 2</h3>\n  <div>...</div>\n  ...\n{{/accordion}}\n\nData-linked element syntax:\n<div data-link="{accordion _collapsible=true}">\n  <h3>Not latin</h3>\n  <div>...</div>\n  <h3>Section two</h3>\n  <div>...</div>\n  ...\n</div>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n'
},{_type:"para",title:"Initializing the selected panel",text:'Initializing the selected panel\nBy default the first panel is selected initially as open (active) panel.\nTo specify different initial panel selection, pass an integer as argument.\n{^{accordion 2 _collapsible=true}}...\n\nor\n<div data-link="{accordion 2 _collapsible=true}">...\n\nTo initialize with all panels collapsed, pass the argument false.\n'},{_type:"para",title:"Data-linking the selected panel",text:"Data-linking the selected panel\nThe ‘selected panel’ argument can of course be provided by an expression or data path:\n{^{panel selectedPanel _collapsible=true}}...\n\nIn  this case, the {{accordion}} control provides two-way data-binding on the corresponding data property (selectedPanel).\nThis is illustrated in the following sample, which is the same as the sample above except that both accordions are data-linked to the same selectedPanel property. As a result, the two accordions stay in sync: changing (or collapsing) a panel on one will trigger the corresponding change on the other.\n"},{_type:"sample",title:"Data-linking the selected panel",url:"samples/tag-controls/jqui/accordion/collapsible",text:'Data-linking the selected panel\nTag syntax:\n{^{accordion selectedPanel _collapsible=true}}\n  ...\n\nData-linked element syntax:\n<div data-link="{accordion selectedPanel _collapsible=true}">\n  ...\n\nCode:\nvar model = {selectedPanel: 1};\n\npageTmpl.link("#page", model);\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {selectedPanel: 1};\n\npageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<b>Selected panel:</b> {^{:selectedPanel}}\r\n\r\n<h4>Tag syntax:</h4>\r\n\r\n<pre>\r\n&lcub;^{accordion ...}&rcub;...&lcub;^{/accordion}&rcub;\r\n</pre>\r\n\r\n<!--tag syntax-->\r\n{^{accordion selectedPanel _collapsible=true elem="div"}}\r\n  <h3>Section 1</h3>\r\n  <div>\r\n    <p><em>Click header again to close panel.</em></p>\r\n    <p>Mauris mauris ante, blandit et, ultrices a, suscipit eget, quam.</p>\r\n  </div>\r\n  <h3>Section 2</h3>\r\n  <div>\r\n    <p><em>Click header again to close panel.</em></p>\r\n    <p>Sed non urna. Donec et ante.</p>\r\n  </div>\r\n  <h3>Section 3</h3>\r\n  <div>\r\n    <p><em>Click header again to close panel.</em></p>\r\n    <ul>\r\n      <li>List item one</li>\r\n      <li>List item two</li>\r\n    </ul>\r\n  </div>\r\n{{/accordion}}\r\n\r\n<h4>Element-based data-link syntax:</h4>\r\n\r\n<pre>\r\n&lt;div data-link="{accordion _collapsible=true}">...&lt;/div>\r\n</pre>\r\n\r\n<!--alternative data-linked element syntax-->\r\n<div data-link="{accordion selectedPanel _collapsible=true}">\r\n  <h3>Not latin</h3>\r\n  <div>\r\n    <p><em>Click header to close.</em></p>\r\n    <p>First non-latin text.</p>\r\n  </div>\r\n  <h3>Section two</h3>\r\n  <div>\r\n    <p><em>Click header to close.</em></p>\r\n    <p>Second text.</p>\r\n  </div>\r\n  <h3>Section three</h3>\r\n  <div>\r\n    <p><em>Click header to close.</em></p>\r\n    <p>Further content.</p>\r\n  </div>\r\n</div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Sortable accordion",text:"Sortable accordion\nThe {{accordion}} has some similarities to the {{tabs}} control (and widget) – and in both    cases a ‘sortable’ variant is possible. However from a user point of view the idea of dragging accordion panel probably makes less sense.\nSortable accordion panels are obtained by wrapping the panel markup in a {{sortable}} tag, within the {{accordion}} tag. However it is better for the header and panel markup to be contained in a single <div> element, so that the whole div can be dragged during sorting:\nThe following sample is a declarative data-driven version of the jQuery UI Accordion – Sortable demo, using tag syntax.\n"},{_type:"sample",title:"Sortable accordion",url:"samples/tag-controls/jqui/accordion/sortable",text:'Sortable accordion\nTag syntax:\n{^{accordion selectedPanel _header=\'>div>h3\'}}\n  {^{sortable _axis="y" _handle=\'h3\' elem=\'div\' _stop=~stop}}\n    <div>\n      <h3>Section 1</h3>\n      <div>Panel 1 content</div>\n    </div>\n    ...\n  {{/sortable}}\n{{/accordion}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nfunction stop( event, ui ) {\n  // IE doesn\'t register the blur when sorting\n  //// so trigger focusout handlers to remove .ui-state-focus\n  ui.item.children( "h3" ).triggerHandler( "focusout" );\n}\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {selectedPanel: false};\n\npageTmpl.link("#page", model, {stop: stop});\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<h4>Drag headers to sort...</h4>\r\n\r\n{^{accordion selectedPanel _header=\'>div>h3\' _collapsible=true}}\r\n  {^{sortable elem=\'div\' _axis=\'y\' _handle=\'h3\' _stop=~stop}}\r\n    <div>\r\n      <h3>Section 1</h3>\r\n      <div>Panel 1 content</div>\r\n    </div>\r\n    <div>\r\n      <h3>Section 2</h3>\r\n      <div>Panel 2 content</div>\r\n    </div>\r\n    <div>\r\n      <h3>Section 3</h3>\r\n      <div>Panel 3 content</div>\r\n    </div>\r\n  {{/sortable}}<br/><br/><br/>\r\n{{/accordion}}\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Using {{accordion}} with a data-linked array",text:"Using {{accordion}} with a data-linked array\nA data-driven approach can be used, with the header text and panel contents rendered from a data array:\n{^{accordion ... elem='div'}}\n  {^{for panelData}}\n    <h3>{^{:header}}</h3>\n    <div>{^{:content}}</div>\n  {{/for}}\n{{/accordion}}\n\n\n"},{_type:"para",title:"Sortable accordion with  a data-linked array",text:"Sortable accordion with  a data-linked array\nIf an {{accordion}} tag control with content coming from a data-driven array is also sortable, then sorting the tabs will sort the underlying data array – and raise corresponding observable events.\nThis is the same behavior as is obtained with the {{sortable}} tag used alone, without {{accordion}}. To opt out of the observable binding on the array, set {^{sortable _bindArray=false ...}}.\nThe following sample shows data-linking to the underlying array, with a sortable {{accordion}} tag control:\n"},{_type:"sample",url:"samples/tag-controls/jqui/accordion/sortablearray",text:'{^{accordion selectedPanel _header=\'>div>h3\' _collapsible=true}}\n  {^{sortable _axis="y" _handle=\'h3\' elem=\'div\'}}\n    {^{for panelData}}\n      <div>\n        <h3>{^{:header}}</h3>\n        <div>{^{:content}}</div>\n      </div>\n    {{/for}}\n  {{/sortable}}\n{{/accordion}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar cnt = 2,\n  pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    selectedPanel: false,\n    panelData: [\n      {\n        header: "First tab",\n        content: "First tab content"\n      },\n      {\n        header: "Another tab",\n        content: "More content"\n      },\n      {\n        header: "Third tab",\n        content: "Even more content"\n      }\n    ]\n  };\n\npageTmpl.link("#page", model, {\n  remove: function(index) {\n    $.observable(model.panelData).remove(index);\n  },\n  append: function() {\n    cnt++;\n    $.observable(model.panelData).insert({\n      header: "Added" + cnt,\n      content: "Added content "  + cnt\n    });\n  }\n});\n\n<style>\r\n  ul {margin: 0; padding-left: 0;} \r\n  li {list-style: none;}\r\n  li a {color: red; cursor:pointer; padding: 3px;}\r\n  li input {width: 200px;}\r\n</style>\r\n\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n<h4>Drag headers to sort...</h4>\r\n\r\n{^{accordion selectedPanel _header=\'>div>h3\' _collapsible=true}}\r\n  {^{sortable elem=\'div\' _axis=\'y\' _handle=\'h3\'}}\r\n    {^{for panelData}}\r\n      <div>\r\n        <h3>{^{:header}}</h3>\r\n        <div>{^{:content}}</div>\r\n      </div>\r\n    {{/for}}\r\n  {{/sortable}}\r\n{{/accordion}}\r\n\r\n<h4>Selected panel:</h4>\r\n\r\n<input data-link="selectedPanel" />\r\n\r\n<h4>Panel data (edit or sort):</h4>\r\n\r\n{^{on ~append}}Add panel{{/on}}<br/><br/>\r\n\r\n{^{sortable elem="ul" _axis="y"}}\r\n  {^{for panelData}}\r\n    <li>\r\n      <a data-link="{on ~remove #index}">x</a>\r\n      <input data-link="header" /> <input data-link="content" />\r\n      {^{if ~root.selectedPanel===#index}}\r\n        (selected)\r\n      {{/if}}\r\n  </li>\r\n  {{/for}}\r\n{{/sortable}}\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Sortable accordion with  a data-linked array &ndash; top-level data-linking",text:"Sortable accordion with  a data-linked array – top-level data-linking\nFinally, here is the same sample as above, but achieved entirely through top-level data linking:\n"},{_type:"sample",url:"samples/tag-controls/jqui/accordion/sortablearray-toplevel",text:'<script id="panelMarkup" type="text/x-jsrender">\n  <div>\n    <h3>{^{:header}}</h3>\n    <div>{^{:content}}</div>\n  </div>\n</script>\n\nTop-level data-linked element:\n<div class="linkedUI" data-link="\n  {for panelData tmpl=\'#panelMarkup\'}\n  {sortable _axis=\'y\' _handle=\'h3\'}\n  {accordion selectedPanel _header=\'>div>h3\' _collapsible=true}\n"></div>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar cnt = 2,\n  pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    selectedPanel: false,\n    panelData: [\n      {\n        header: "First tab",\n        content: "First tab content"\n      },\n      {\n        header: "Another tab",\n        content: "More content"\n      },\n      {\n        header: "Third tab",\n        content: "Even more content"\n      }\n    ]\n  };\n\n$.link(true, ".linkedUI", model, {\n  remove: function(index) {\n    $.observable(model.panelData).remove(index);\n  },\n  append: function() {\n    cnt++;\n    $.observable(model.panelData).insert({\n      header: "Added" + cnt,\n      content: "Added content "  + cnt\n    });\n  }\n});\n\n<script id="panelMarkup" type="text/x-jsrender">\r\n  <div>\r\n    <h3>{^{:header}}</h3>\r\n    <div>{^{:content}}</div>\r\n  </div>\r\n</script>\r\n\r\n<script id="dataList" type="text/x-jsrender">\r\n  <li>\r\n    <a data-link="{on ~remove #index}">x</a>\r\n    <input data-link="header" /> <input data-link="content" />\r\n    {^{if ~root.selectedPanel===#index}}\r\n      (selected)\r\n    {{/if}}\r\n  </li>\r\n</script>\r\n\r\n<h4>Drag headers to sort...</h4>\r\n\r\n<div class="linkedUI" data-link="\r\n  {for panelData tmpl=\'#panelMarkup\'}\r\n  {sortable _axis=\'y\' _handle=\'h3\'}\r\n  {accordion selectedPanel _header=\'>div>h3\' _collapsible=true}\r\n"></div>\r\n\r\n<h4>Selected panel:</h4>\r\n\r\n<input class="linkedUI" data-link="selectedPanel" />\r\n\r\n<h4>Panel data (edit or sort):</h4>\r\n\r\n<button class="linkedUI" data-link="{on ~append}">Add panel</button><br/><br/>\r\n\r\n<ul class="linkedUI" data-link="{for panelData tmpl=\'#dataList\'}"></ul>\n'
}]},"samples/tag-controls/jqui/slider/color-picker":{sections:[{_type:"sample",url:"samples/tag-controls/jqui/slider/colorpicker/sample",text:'Three sliders each data-linked to a color variable (red, green, blue):\n{^{slider red class="red" ... /}}\n{^{slider green class="green" ... /}}\n{^{slider blue class="blue" ... /}}\n\nand a <div> data-linked to three color arguments – with a converter producing a single resulting background color:\n<div class="swatch" data-link="css-background-color{toHex:red green blue}"></div>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n$.views.converters("toHex", function(r, g, b) {\n  var hex = [\n    r.toString(16),\n    g.toString(16),\n    b.toString(16)\n  ];\n\n  $.each(hex, function(nr, val) {\n    if (val.length === 1) {\n      hex[nr] = "0" + val;\n    }\n  });\n\n  return "#" + hex.join("");\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    red: 255,\n    green: 140,\n    blue: 60\n  };\n\npageTmpl.link("#page", model);\n<h3>Three JsViews \'slider\' tag controls (using jQuery UI slider) as simple RGB color picker</h3>\r\n\r\n<style>\r\n  .ui-slider {float: left; clear: left; width: 300px; margin: 15px;}\r\n  .swatch {width: 140px; height: 140px; margin-left: 350px;}\r\n\r\n  .red .ui-slider-range, .red .ui-slider-handle {background: #ef2929;}\r\n  .green .ui-slider-range, .green .ui-slider-handle {background: #8ae234;}\r\n  .blue .ui-slider-range, .blue .ui-slider-handle {background: #729fcf;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n  {^{slider red class="red" _range=\'min\' _max=255 /}}\r\n  {^{slider green class="green" _range=\'min\' _max=255 /}}\r\n  {^{slider blue class="blue" _range=\'min\' _max=255 /}}\r\n\r\n  <div class="swatch" data-link="css-background-color{toHex:red green blue}"></div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/jqui":{sections:[{_type:"para",title:"",text:"The jQuery UI tag controls library is a set of tag controls based on jQuery UI widgets.\nIt provides the following tag controls:\n\n{{autocomplete/}} – based on jQuery UI autocomplete\n(api)\n\nused in the autocomplete sample\n\n{{accordion/}} – based on jQuery UI accordion\n(api)\n\nused in the accordion samples\n\n{{button/}} – based on jQuery UI button\n(api)\n\nused in the Toolbar\nand progressbar samples\n\n{{checkbox/}} – based on jQuery UI checkboxradio\n(api)\n(requires jQuery UI version 1.12.1 or later)\n\nused in the Toolbar\nand Accessing widget APIs samples\n\n{{radio/}} – based on jQuery UI checkboxradio\n(api)\n(requires jQuery UI version 1.12.1 or later)\n\nused in the Toolbar sample\n\n{{controlgroup/}} – based on jQuery UI controlgroup\n(api)\n(requires jQuery UI version 1.12.1 or later)\n\nused in the Toolbar sample\n\n{{buttonset}} – deprecated and available only if using jQuery UI 1.11.4\n{{datepicker/}} – based on jQuery UI datepicker\n(api)\n\nused in the simple datepicker,\ndatepicker variants,\ndatepicker with validation\nand datepicker with validation wizard samples\n\n{{draggable/}} – based on jQuery UI draggable\n(api)\n\nused in the draggable - droppable samples\n\n{{droppable/}} – based on jQuery UI droppable\n(api)\n\nused in the draggable - droppable samples\n\n{{menu/}} – based on jQuery UI menu\n(api)\n\nused in the menu samples\n\n{{progressbar/}} – based on jQuery UI progressbar\n(api)\n\nused in the Toolbar\nand progressbar samples\n\n{{resizable/}} – based on jQuery UI resizable\n(api)\n\nused in the resizable samples\n\n{{selectable/}} – based on jQuery UI selectable\n(api)\n\nused in the selectable samples\n\n{{selectmenu/}} – based on jQuery UI selectmenu\n(api)\n\nused in the selectmenu samples\n\n{{slider/}} – based on jQueryUI slider\n(api)\n\nused in the simple slider,\nslider variants,\nslider with validation,\nsliders as color picker,\nToolbar,\nresizable,\ndraggable - droppable,\nspinner and\nprogressbar samples\n\n{{sortable/}} – based on jQuery UI sortable\n(api)\n\nused in the sortable samples\n\n{{spinner/}} – based on jQuery UI spinner\n(api)\n\nused in the spinner\nand resizable samples\n\n{{timespinner/}} – also based on jQuery UI spinner\n(api)\n\nused in the timespinner samples\n\n{{tabs/}} – based on jQuery UI tabs\n(api)\n\nused in the tabs samples\n\n\n"},{_type:"para",title:"",text:'To use the above tag controls simply include the library after loading  jQuery UI (recommended version 1.12.1 or later) and JsViews:\n...\n<script src="//code.jquery.com/jquery-1.12.4.js"></script>\n<script src="//code.jquery.com/ui/1.12.1/jquery-ui.js"></script>\n...\n<script src="//www.jsviews.com/download/jsviews.js"></script>\n<script src="//www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js"></script>\n...\n\nIn addition, include an appropriate an jQuery UI css class library, such as the default theme:\n<link href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css" rel="stylesheet">\n\n'},{_type:"links",title:"See:",text:"See:\n"}]},"samples/computed/team-manager":{sections:[{_type:"para",title:"",text:"This sample shows two-way binding to compiled View Model properties get/set properties, as well as to an additional custom Person.isManager() get/set property. The same sample is shown here in the JsViews Compiled View Models topic.\n"},{_type:"sample",url:"samples/computed/team-manager/sample",text:'See the same sample in the JsViews Compiled View Models topic, for details and discussion.\n\n"use strict";\n// Compile template\nvar tmpl = $.templates("#teamTmpl");\n\n// Custom function for Person.isManager get/set property\nfunction myIsManager(val) {\n  if (!arguments.length) {\n    return this === team.manager(); // If there is no argument, use as a getter\n  }\n  if (val) {\n    // Setting this.isManager() to true\n    // So make this team member manager\n    team.manager(this);\n  } else if (this.isManager()) {\n    // Setting this.isManager to false, and this team member is currently manager.\n    // So set team manager to null\n    team.manager(null);\n  }\n}\n\n// Compile View Models\n$.views.viewModels({\n  Team: {\n    getters: [\n      {\n        getter: "manager",\n        type: "Person"\n      },\n      {\n        getter: "members",\n        type: "Person"\n      }\n    ]\n  },\n  Person: {\n    getters: [\n      "name",\n      {\n        getter: "address",\n        type: "Address"\n      }\n    ],\n    extend: {\n      isManager: myIsManager // use custom function\n    }\n  },\n  Address: {\n    getters: ["street", "ZIP"]\n  }\n});\n\n// Specify that the same function is a setter - for two-way data-linking\nmyIsManager.set = true;\n\n// Specify dependency: if team.manager() changes, manager.isManger() should update\nmyIsManager.depends = function() {\n  return [team, "manager"];\n}\n// Alternatively - more declarative approach: use ~manager contextual parameter:\n// myIsManager.depends = "~manager"\n\n// Initial data\nvar teamData = {\n    manager: null,\n    members: [{\n      name: "Pete",\n      address: {\n        street: "1st Ave",\n        ZIP: "12345"\n      }\n    },{\n      name: "Bess",\n      address: {\n        street: "Central Way",\n        ZIP: "98765"\n      }\n    },\n    {\n      name: "Henry",\n      address: {\n        street: "Main St",\n        ZIP: "54321"\n      }\n    }]\n  };\n\n// Instantiate View Models\nvar team = $.views.viewModels.Team.map(teamData);\n\n//Initialize second team member to be manager.\nvar manager = team.members()[1];\nmanager.isManager(true);\n\ntmpl.link("#result", team, {setManager: function(index) {\n  if (arguments.length === 3) {\n    team.members()[index].isManager(true);\n  } else if (team.manager()) {\n    team.manager().isManager(false);\n  }\n}});\n<title>Computed observables:- Compiled View Model and two-way binding</title>\r\n\r\n<div id="result"></div>\r\n\r\n<script id="teamTmpl" type="text/x-jsrender">\r\n{^{on ~setManager}}No Manager{{/on}}\r\n{^{on ~setManager 0}}Set Manager 0{{/on}}\r\n{^{on ~setManager 1}}Set Manager 1{{/on}}\r\n{^{on ~setManager 2}}Set Manager 2{{/on}}\r\n<h4>Team members:</h4>\r\n\r\n<table>\r\n  <thead><tr><td>Is&nbsp;Manager</td><td>Name</td><td>Street</td><td>ZIP</td></tr></thead>\r\n  <tbody>\r\n    {^{for members() ~manager=manager}}\r\n      <tr><td><input data-link="isManager()" type="checkbox"/></td>\r\n      <td><input data-link="name()" /></td>\r\n      <td><input data-link="address().street()" /></td>\r\n      <td><input data-link="address().ZIP()" /></td>\r\n      </tr>\r\n    {{/for}}\r\n  </tbody>\r\n</table>\r\n\r\n{^{if manager()}}\r\n  <h4>Manager:</h4>\r\n  <table><tbody><tr>\r\n    <td><input data-link="manager()^name()" /></td>\r\n    <td><input data-link="manager()^address().street()" /></td>\r\n    <td><input data-link="manager()^address().ZIP()" /></td>\r\n  </tr></tbody></table>\r\n{{else}}\r\n  <h4>No manager</h4>\r\n{{/if}}\r\n</script>\n'}]},"samples/tag-controls/jqui/toolbar":{sections:[{_type:"para",title:"",text:"The following sample is a more advanced example of using multiple jQuery UI based JsViews tag controls:\n\n{{controlgroup}} – based on the jQuery UI controlgroup widget (api)\n{{button}} – based on the jQuery UI button widget (api)\n{{radio}} – based on the jQuery UI checkboxradio widget (api)\n{{checkbox}} – based on the jQuery UI checkboxradio widget (api)\n{{progressbar}} – based on the jQuery UI progressbar widget (api)\n{{slider}} – based on the jQuery UI slider widget (api)\n\n"},{_type:"sample",title:"Toolbar",url:"samples/tag-controls/jqui/toolbar/toolbar",text:'Toolbar\n{^{controlgroup class=...}}\n  {^{on toStart}}\n    {^{button _icon=... .../}}\n  {{/on}}\n  ...\n{{/controlgroup}}\n{^{checkbox reverse label="Reverse" .../}}\n{^{controlgroup _classes=...}}\n  {^{radiogroup mode}}\n    {^{radio label="Once" value="once"/}}\n    ...\n  {{/radiogroup}}\n{{/controlgroup}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    mode: "return",\n    reverse: false,\n    playing: false,\n    time: 1500,\n\n    play: function() {\n      $.observable(this).setProperty("playing", true);\n    },\n    stop: function() {\n      $.observable(this).setProperty("playing", false);\n    },\n    toStart: function() {\n      $.observable(this).setProperty("time", 0);\n    },\n    toPrev: function() {\n      if (this.time > 300) {\n        $.observable(this).setProperty("time", this.time - 300);\n      }\n    },\n    toNext: function() {\n      if (this.time < 2700) {\n        $.observable(this).setProperty("time", this.time + 300);\n      }\n    }\n  },\n  uiOverrides = {\n    "ui-controlgroup": "mygroup ui-corner-all",\n    "ui-controlgroup-item": "myuibutton",\n    "ui-button": "myuibutton"\n  };\n\npageTmpl.link("#page", model, {\n  not: function(val) {\n    return !val;\n  },\n  toHex: function(num) {\n    num = parseInt(255-num).toString(16);\n    if (num.length === 1) {\n      num = "0" + num;\n    }\n    return "#" + num + "cc" + num;\n  },\n  myUiOverrides: uiOverrides\n});\n\nvar stepTimer, randomTimer;\n\n$.observe(model, "playing", function(ev, eventArgs) {\n  if (eventArgs.value) {\n    stepTimer = setInterval(\n      function step() {\n        if (model.time < 0 || model.time > 3000) {\n          $.observable(model).setProperty("time", model.reverse ? 0 : 3000);\n          if (model.mode === "once") {\n            $.observable(model).setProperty("playing", false);\n          } else {\n            $.observable(model).setProperty("reverse", !model.reverse);\n          }\n        } else {\n          $.observable(model).setProperty("time", model.time + (model.reverse ? -1 : 1));\n        }\n      },\n      7\n    );\n  } else {\n    clearInterval(stepTimer);\n  }\n});\n\n$.observe(model, "mode", "playing", function(ev, eventArgs) {\n  if (model.playing && model.mode === "random") {\n    randomTimer = setInterval(\n      function() {\n        $.observable(model).setProperty({\n          reverse: !model.reverse,\n          time: Math.floor(Math.random()*3001)\n        });\n      },\n      1300\n    );\n  } else {\n    clearInterval(randomTimer);\n  }\n});\n\n<style>\r\n.mygroup {border: #888888 solid 1px; margin: 2px;}\r\n.tb {border: #b42e2e solid 1px; margin: 2px;}\r\n.play {border-left: #b42e2e solid 1px; border-right: #b42e2e solid 1px;}\r\n.rvrs, .myuibutton {padding: 8px 5px; font-size: 8pt; line-height: 14px;}\r\n.rvrs {border: #888888 solid 1px; padding: 9px 5px; margin: 2px; line-height: 14px;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n<div id="toolbar" class="ui-widget-header ui-corner-all">\r\n  {^{controlgroup class="tb ui-corner-all"}}\r\n<!--\r\n  Alternative data-linked element syntax: <button data-link="{on toStart}{button\r\n   _icon=\'ui-icon-seek-start\' class=\'ui-button-icon-only\'}"></button>\r\n-->\r\n    {^{on toStart}}\r\n      {^{button _icon="ui-icon-seek-start" class="ui-button-icon-only"/}}\r\n    {{/on}}\r\n    {^{on toPrev}}\r\n      {^{button _icon="ui-icon-seek-prev" class="ui-button-icon-only"/}}\r\n    {{/on}}\r\n    {^{on play}}\r\n      {^{button _icon="ui-icon-play" class="ui-button-icon-only play" ^_disabled=playing/}}\r\n    {{/on}}\r\n    {^{on stop}}\r\n      {^{button _icon="ui-icon-stop" class="ui-button-icon-only" ^_disabled=!playing/}}\r\n    {{/on}}\r\n    {^{on toNext}}\r\n      {^{button _icon="ui-icon-seek-next" class="ui-button-icon-only"/}}\r\n    {{/on}}\r\n  {{/controlgroup}}\r\n  {^{checkbox reverse ^label=reverse?"Forward":"Reverse" class="ui-corner-all rvrs"/}}\r\n  {^{controlgroup _classes=~myUiOverrides}}\r\n    {^{radiogroup mode}}\r\n      {^{radio label="Once" value="once"/}}\r\n      {^{radio label="Return" value="return"/}}\r\n      {^{radio label="Random" value="random"/}}\r\n    {{/radiogroup}}\r\n  {{/controlgroup}}\r\n</div>\r\n\r\n<svg data-link="css-width{:2 + time*.2} css-background-color{:~toHex(time*51/600)}"\r\n  class="svg-circles">\r\n  <circle data-link="r{:time*.1} cx{:time*.1 + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="green"></circle>\r\n  <circle data-link="r{:time*.075} cx{:time*.1 + 1} cy{:102 - time*.075}"\r\n    class="svg-circle" stroke="#b42e2e"></circle>\r\n  <circle data-link="r{:time*.05} cx{:time*.1 + 1} cy{:time*.05}"\r\n    class="svg-circle" stroke="#ffb"></circle>\r\n  <circle data-link="r{:time*.025} cx{:time*.1 + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="blue"></circle>\r\n</svg>\r\n\r\n{^{progressbar time _max=3000 width=600 height=15/}}\r\n\r\n{^{slider class=\'slider\' time _range=\'min\' _min=1 _max=3000 width=600 /}}\r\n\r\n<div>\r\nTime: <input data-link="{:time:tonum}" /><br/>\r\nMode: {^{:mode}}<br/>\r\n<label>Reverse: <input type="checkbox" data-link="reverse" /></label><br/>\r\n<label>Playing: <input type="checkbox" data-link="playing" /></label>\r\n</div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"",text:"The following modified  version of the Toolbar sample includes dynamically-driven radio button groups:\n"},{_type:"sample",title:"Toolbar with dynamic {{radio}} array",url:"samples/tag-controls/jqui/toolbar/toolbararray",text:'Toolbar with dynamic {{radio}} array\nThe model includes a model.modes and a model.speeds array:\nmodel = {\n  mode: "return",\n  speed: "2",\n  modes: [\n      {action: "once", label: "Once"},\n      ...\n    ],\n    speeds: [\n      {speedFactor: "1", label: "Speed 1"},\n      ...\n    ],\n    ...\n\nThe UI includes data-driven {^{for}} tags within the {^{radiogroup}} tags.\n{^{controlgroup _classes=...}}\n  {^{radiogroup mode}}\n    {^{for modes}}\n      {^{radio label=label value=action/}}\n    {{/for}}\n  {{/radiogroup}}\n{{/controlgroup}}\n  ...\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\nvar speedFactor = 3,\n  pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    mode: "return",\n    speed: "2",\n    modes: [\n      {action: "once", label: "Once"},\n      {action: "return", label: "Return"},\n      {action: "random", label: "Random"}\n    ],\n    speeds: [\n      {speedFactor: "1", label: "Speed 1"},\n      {speedFactor: "2", label: "Speed 2"}\n    ],\n    reverse: false,\n    playing: false,\n    time: 1500,\n\n    addSpeed: function(remove) {\n      $.observable(this.speeds).insert({speedFactor: "" + speedFactor,\n        label: "Speed " + speedFactor++});\n    },\n    removeSpeed: function(remove) {\n      $.observable(this.speeds).remove();\n      speedFactor = speedFactor > 1 ? speedFactor - 1 : speedFactor;\n    },\n    play: function() {\n      $.observable(this).setProperty("playing", true);\n    },\n    stop: function() {\n      $.observable(this).setProperty("playing", false);\n    },\n    toStart: function() {\n      $.observable(this).setProperty("time", 0);\n    },\n    toPrev: function() {\n      if (this.time > 300) {\n        $.observable(this).setProperty("time", this.time - 300);\n      }\n    },\n    toNext: function() {\n      if (this.time < 2700) {\n        $.observable(this).setProperty("time", this.time + 300);\n      }\n    }\n  },\n  uiOverrides = {\n    "ui-controlgroup": "mygroup ui-corner-all",\n    "ui-controlgroup-item": "myuibutton",\n    "ui-button": "myuibutton"\n  };\n\npageTmpl.link("#page", model, {\n  not: function(val) {\n    return !val;\n  },\n  toHex: function(num) {\n    num = parseInt(255-num).toString(16);\n    if (num.length === 1) {\n      num = "0" + num;\n    }\n    return "#" + num + "cc" + num;\n  },\n  onbind: function(val) {\n    this.baseApply(arguments);\n    this.mainElem.controlgroup("option", "classes", uiOverrides);\n  },\n  myUiOverrides: uiOverrides\n});\n\nvar stepTimer, randomTimer;\n\n$.observe(model, "playing", function(ev, eventArgs) {\n  if (eventArgs.value) {\n    stepTimer = setInterval(\n      function step() {\n        if (model.time < 0 || model.time > 3000) {\n          $.observable(model).setProperty("time", model.reverse ? 0 : 3000);\n          if (model.mode === "once") {\n            $.observable(model).setProperty("playing", false);\n          } else {\n            $.observable(model).setProperty("reverse", !model.reverse);\n          }\n        } else {\n          $.observable(model).setProperty("time",\n             model.time + Math.pow(2, model.speed) * (model.reverse ? -1 : 1));\n        }\n      },\n      7\n    );\n  } else {\n    clearInterval(stepTimer);\n  }\n});\n\n$.observe(model, "mode", "playing", function(ev, eventArgs) {\n  if (model.playing && model.mode === "random") {\n    randomTimer = setInterval(\n      function() {\n        $.observable(model).setProperty({\n          reverse: !model.reverse,\n          time: Math.floor(Math.random()*3001)\n        });\n      },\n      1300\n    );\n  } else {\n    clearInterval(randomTimer);\n  }\n});\n\n// Set the \'classes\' option\n$("#reverseChkBx").checkboxradio("option", "classes", {"ui-checkboxradio-label": "ui-corner-all rvrs"});\n\n$.observe(model, "reverse", function() {\n  // Set the \'label\' option\n  $("#reverseChkBx").checkboxradio("option", "label", model.reverse ? "Forward" : "Reverse");\n});\n\n<style>\r\n.mygroup {border: #888888 solid 1px; margin: 2px;}\r\n.tb {border: #b42e2e solid 1px; margin: 2px;}\r\n.play {border-left: #b42e2e solid 1px; border-right: #b42e2e solid 1px;}\r\n.rvrs, .myuibutton {padding: 8px 5px; font-size: 8pt; line-height: 14px;}\r\n.rvrs {border: #888888 solid 1px; padding: 9px 5px; margin: 2px; line-height: 14px;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n<div id="toolbar" class="ui-widget-header ui-corner-all">\r\n  {^{controlgroup class="tb ui-corner-all"}}\r\n    {^{on toStart}}\r\n      {^{button _icon="ui-icon-seek-start" class="ui-button-icon-only"/}}\r\n    {{/on}}\r\n    {^{on toPrev}}\r\n      {^{button _icon="ui-icon-seek-prev" class="ui-button-icon-only"/}}\r\n    {{/on}}\r\n    {^{on play}}\r\n      {^{button _icon="ui-icon-play" class="ui-button-icon-only play" ^_disabled=playing/}}\r\n    {{/on}}\r\n    {^{on stop}}\r\n      {^{button _icon="ui-icon-stop" class="ui-button-icon-only" ^_disabled=!playing/}}\r\n    {{/on}}\r\n    {^{on toNext}}\r\n      {^{button _icon="ui-icon-seek-next" class="ui-button-icon-only"/}}\r\n    {{/on}}\r\n  {{/controlgroup}}\r\n  {^{checkbox reverse id="reverseChkBx" label="Reverse"/}}\r\n  {^{controlgroup _classes=~myUiOverrides}}\r\n    {^{radiogroup mode}}\r\n      {^{for modes}}\r\n        {^{radio label=label value=action/}}\r\n      {{/for}}\r\n    {{/radiogroup}}\r\n  {{/controlgroup}}\r\n  {^{controlgroup onBind=~onbind}}\r\n    {^{radiogroup speed}}\r\n      {^{on addSpeed}}\r\n        {^{button _label="+"/}}\r\n      {{/on}}\r\n      {^{on removeSpeed}}\r\n        {^{button _label="-"/}}\r\n      {{/on}}\r\n      {^{for speeds}}\r\n        {^{radio label=label value=speedFactor/}}\r\n      {{/for}}\r\n    {{/radiogroup}}\r\n  {{/controlgroup}}\r\n</div>\r\n\r\n<svg data-link="css-width{:2 + time*.2} css-background-color{:~toHex(time*51/600)}"\r\n   class="svg-circles">\r\n  <circle data-link="r{:time*.1} cx{:time*.1 + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="green"></circle>\r\n  <circle data-link="r{:time*.075} cx{:time*.1 + 1} cy{:102 - time*.075}"\r\n    class="svg-circle" stroke="#b42e2e"></circle>\r\n  <circle data-link="r{:time*.05} cx{:time*.1 + 1} cy{:time*.05}"\r\n    class="svg-circle" stroke="#ffb"></circle>\r\n  <circle data-link="r{:time*.025} cx{:time*.1 + 1}"\r\n    class="svg-circle" cy="51" stroke-width="2" stroke="blue"></circle>\r\n</svg>\r\n\r\n{^{progressbar time _max=3000 width=600 height=15/}}\r\n\r\n{^{slider class=\'slider\' time _range=\'min\' _min=1 _max=3000 width=600 /}}\r\n\r\n<div>\r\nTime: <input data-link="{:time:tonum}" /><br/>\r\nMode: {^{:mode}}<br/>\r\n<label>Reverse: <input type="checkbox" data-link="reverse" /></label><br/>\r\n<label>Playing: <input type="checkbox" data-link="playing" /></label>\r\n</div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"",text:'The second version of the sample, above, also shows alternative approaches to setting options on the jQuery UI widgets:\n\nDeclarative setting of options:\n{^{controlgroup _classes=~myUiOverrides}}\n\nProgrammatic approach, using an overridden ‘onBind’ event handler:\n{^{controlgroup onBind=~onbind}}\n\npageTmpl.link("#page", model, {\n  ...\n  onbind: function(val) {\n    this.baseApply(arguments);\n    this.mainElem.controlgroup( "option", "classes", uiOverrides);\n  },\n  ...\n});\n\nProgrammatic approach, using an id and corresponding jQuery selector:\n{^{checkbox reverse id="reverseChkBx"/}}\n\n$("#reverseChkBx").checkboxradio("option", "classes", {"ui-checkboxradio-label": ...});\n\n$.observe(model, "reverse", function() {\n  $("#reverseChkBx").checkboxradio("option", "label", model.reverse ? "Forward" : "Reverse");\n});\n\n\n'}]},"samples/tag-controls/jqui/draggable-droppable":{sections:[{_type:"para",title:"The {{droppable}} tag control ",text:'The {{droppable}} tag control \nTag syntax:\n{^{droppable ~dropInGallery ...}}\n  ...\n{{/droppable}}\n\nData-linked element syntax:\n<div data-link="{droppable ~dropInGallery ...}" ...>\n  ...\n</div>\n\nHandler for drop event:\n{{droppable}} accepts a function argument (dropInGallery, in the examples above) which is used as event handler for the jQuery UI Droppable widget drop event.\n'},{_type:"para",title:"The {{draggable}} tag control",text:'The {{draggable}} tag control\nTag syntax:\n{^{draggable ...}}\n  ...\n{{/draggable}}\n\nData-linked element syntax:\n<div data-link="{draggable ...}" ...>\n  ...\n</div>\n\n'},{_type:"para",title:"Sample: Photo Manager",text:"Sample: Photo Manager\nThe following sample uses the {{draggable}} and {{droppable}} tag controls – based on the jQuery UI draggable widget (api) and droppable widget (api).\nIt is a declarative data-driven version of the jQuery UI Photo Manager demo.\n"},{_type:"sample",url:"samples/tag-controls/jqui/draggable-droppable/photomanager",text:'Template:\n{^{droppable ~dropInGallery _accept=... _activeClass=... elem="ul" ...}}\n  {^{for items}}\n    {^{draggable _cancel=... _revert=... _containment=... _helper=... _cursor=... elem="li" ...}}\n      <h5 class="ui-widget-header">{{:title}}</h5>\n      <img src="{{:icon}}" alt="{{:description}}" .../>\n      ...\n    {{/draggable}}\n  {{/for}}\n{{/droppable}}\n\n{^{droppable ~dropInTrash _accept=... _activeClass=... elem="ul" ...}}\n  ...\n  {^{for trash}}\n    {^{draggable _cancel=... _revert=... _containment=... _helper=... _cursor=... elem="li" ...}}\n      <h5 class="ui-widget-header">{{:title}}</h5>\n      <img src="{{:icon}}" alt="{{:description}}" .../>\n      ...\n    {{/draggable}}\n  {{/for}}\n{{/droppable}}\n\nCode:\nvar data = {\n    items: [{title: "High Tatras", ...}, ...],\n    trash: [{title: "High Tatras 4", ...} ...]\n  },\n  helpers = {\n    dropInTrash: function(...) {...},\n    dropInGallery: function(...) {...},\n    ...\n  },\n  pageTmpl = $.templates("#pageTmpl");\n\npageTmpl.link("#page", data, helpers);\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar data = {\n    items: [\n      {\n        title: "High Tatras",\n        icon: "images/high_tatras_min.jpg",\n        description: "The peaks of High Tatras",\n        image: "images/high_tatras.jpg"\n      },\n      {\n        title: "High Tatras 2",\n        icon: "images/high_tatras2_min.jpg",\n        description: "The chalet at the Green mountain lake",\n        image: "images/high_tatras2.jpg"\n      },\n      {\n        title: "High Tatras 3",\n        icon: "images/high_tatras3_min.jpg",\n        description: "Planning the ascent",\n        image: "images/high_tatras3.jpg"\n      }\n    ],\n    trash: [\n      {\n        title: "High Tatras 4",\n        icon: "images/high_tatras4_min.jpg",\n        description: "On top of Kozi kopka",\n        image: "images/high_tatras4.jpg"\n      }\n    ]\n  },\n  helpers = {\n    dropInTrash: function( event, ui ) {\n      deleteImage( $.view( ui.draggable ) );\n    },\n    dropInGallery: function( event, ui ) {\n      recycleImage( $.view( ui.draggable ) );\n    },\n    deleteThis: function( event, evtArgs ) {\n      deleteImage( evtArgs.view );\n    },\n    recycleThis: function( event, evtArgs ) {\n      recycleImage( evtArgs.view );\n    },\n    showDialog: viewLargerImage\n  },\n  pageTmpl = $.templates("#pageTmpl");\n\npageTmpl.link("#page", data, helpers);\n\n// image deletion function\nfunction deleteImage(view) {\n  $.observable(data.items).remove(view.getIndex());\n  $.observable(data.trash).insert(view.data);\n}\n\n// image recycle function\nfunction recycleImage(view) {\n  $.observable(data.trash).remove(view.getIndex());\n  $.observable(data.items).insert(view.data);\n}\n\n// image preview function, demonstrating ui.dialog used as modal window\nfunction viewLargerImage(title, image) {\n  $("<img alt=\'" + title + "\' src=\'" + image\n    + "\' width=\'384\' height=\'288\' style=\'display: none; padding: 8px;\'/>")\n    .appendTo("body")\n    .dialog({title: title, width: 400, modal: true});\n  return false;\n}\n\n<h3>JsViews \'draggable\' and \'droppable\' tag controls - using jQuery UI widgets</h3>\r\n<p>\r\nYou can delete an image either by dragging it to the Trash\r\nor by clicking the trash icon.<br/>\r\nYou can "recycle" an image by dragging it back to the gallery\r\nor by clicking the recycle icon.<br/>\r\nYou can view a larger image by clicking the zoom icon.\r\n</p>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n{^{droppable ~dropInGallery _accept=".trash li" _activeClass="custom-state-active"\r\n  elem="ul" class="thegallery gallery ui-helper-reset ui-helper-clearfix"}}\r\n  {^{for items}}\r\n    {^{draggable _cancel="a.ui-icon" _revert="invalid" _containment="document"\r\n      _helper="clone" _cursor="move" elem="li" class="ui-widget-content ui-corner-tr"}}\r\n      <h5 class="ui-widget-header">{{:title}}</h5>\r\n      <img src="{{:icon}}" alt="{{:description}}" width="96" height="72" />\r\n      <a data-link="{on ~showDialog title image}" href="{{:image}}"\r\n        title="View larger image" class="ui-icon ui-icon-zoomin">View larger</a>\r\n      <a data-link="{on ~deleteThis}" href="#" title="Delete this image"\r\n        class="ui-icon ui-icon-trash">Delete image</a>\r\n    {{/draggable}}\r\n  {{/for}}\r\n{{/droppable}}\r\n\r\n{^{droppable ~dropInTrash _accept=".thegallery>li" _activeClass="ui-state-highlight"\r\n  elem="ul" class="trash ui-widget-content ui-state-default gallery ui-helper-reset"}}\r\n  <h4 class="ui-widget-header"><span class="ui-icon ui-icon-trash">Trash</span> Trash</h4>\r\n  {^{for trash}}\r\n    {^{draggable _cancel="a.ui-icon" _revert="invalid" _containment="document"\r\n      _helper="clone" _cursor="move" elem="li" class="ui-widget-content ui-corner-tr"}}\r\n      <h5 class="ui-widget-header">{{:title}}</h5>\r\n      <img src="{{:icon}}" alt="{{:description}}" width="96" height="72" />\r\n      <a data-link="{on ~showDialog title image}" href="{{:image}}"\r\n        title="View larger image" class="ui-icon ui-icon-zoomin">View larger</a>\r\n      <a data-link="{on ~recycleThis}" href="#" title="Delete this image"\r\n        class="ui-icon ui-icon-refresh">Recycle image</a>\r\n    {{/draggable}}\r\n  {{/for}}\r\n{{/droppable}}\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"The {{draggable}} tag control: Two-way data-binding to width and height",text:"The {{draggable}} tag control: Two-way data-binding to width and height\nIn addition to all the features of the jQuery UI draggable widget, the JsViews {{draggable}} tag control provides two-way data-binding on the left and top properties.\nThis permits many powerful scenarios, illustrated by the following examples.\n"},{_type:"sample",text:'\n  .orange {padding: 6px; width: 34px; height: 34px; text-align: center;\n    line-height: 34px; cursor: move; border: 1px solid #d55900;\n    background-color: #ffe5d2; z-index: 100;}\n  .smalltext {font-size: 12px; line-height: 17px;}\n  body {overflow: auto;}\n  .slider .ui-slider {margin: 2px 16px 0 5px; float: left;}\n  .slider {margin-bottom: 20px;}\n\n\n\n<h4>Drag the square:</h4>\n\n<div class="slider">\n  {^{slider cx _min=20 _max=400 _range="min" width=400/}}\n  <em>cx:</em> {^{rnd:cx}}\n</div>\n<div class="slider">\n  {^{slider cy _min=110 _max=210 _range="min" width=400/}}\n  <em>cy:</em> {^{rnd:cy}}\n</div>\n\n{^{draggable left=cx top=cy\n  _containment="document" class="orange smalltext" \n}}\n  Drag me{{/draggable}}\n\n\n\nvar i,\n  pageTmpl = $.templates("#pageTmpl"),\n  data = {cx: 210, cy: 160};\n\n$.views.converters({\n  rnd: function(val) {\n    // To string, rounded to nearest integer\n    return "" + Math.round(val);\n  }\n});\n\npageTmpl.link("#page", data);\n\n{^{slider cx ... //}}\n...\n{^{slider cy... //}}\n...\n{^{draggable left=cx top=cy ...}}Drag me{{/draggable}}\n\n\n'},{_type:"para",title:"Tag contextual parameters: ~left, ~top",text:"Tag contextual parameters: ~left, ~top\nThe {{draggable}} tag control provides two tag contextual parameters – ~left and ~top – which give access to the values of left and top from anywhere within the {{draggable}} tag’s content.\nThe next sample adds display of ~left and ~top to the previous sample:\n"},{_type:"sample",text:'\n  .orange {cursor: move; border: 1px solid #d55900;\n    background-color: #ffe5d2; padding: 6px; width: 34px; height: 34px;\n    text-align: center; line-height: 34px; z-index: 100;}\n  .smalltext {font-size: 12px; line-height: 17px;}\n  body {overflow: auto;}\n  .slider .ui-slider {margin: 2px 16px 0 5px; float: left;}\n  .slider {margin-bottom: 20px;}\n\n\n\n<h4>Drag the squares:</h4>\n\n<div class="slider">\n  {^{slider cx _min=20 _max=300 _range="min" width=400/}}\n  <em>cx:</em> {^{rnd:cx}}\n</div>\n<div class="slider">\n  {^{slider cy _min=110 _max=220 _range="min" width=400/}}\n  <em>cy:</em> {^{rnd:cy}}\n</div>\n\n{^{draggable left=cx top=cy\n  _containment="document" class="orange smalltext" \n}}\n  {^{rnd:~left}}<br/>{^{rnd:~top}}\n{{/draggable}}\n\n\nvar i,\n  pageTmpl = $.templates("#pageTmpl"),\n  data = {cx: 150, cy: 165};\n\n$.views.converters({\n  rnd: function(val) {\n    // To string, rounded to nearest integer\n    return "" + Math.round(val);\n  }\n});\n\npageTmpl.link("#page", data);\n\n\n{^{draggable left=cx top=cy}}\n  {^{:~left}} {^{:~top}}\n{{/draggable}}\n\n\n'},{_type:"para",title:"Two-way binding to tag contextual parameters",text:'Two-way binding to tag contextual parameters\nYou can even use two-way data-binding to the tag contextual parameters as in:\n{^{draggable}}\n  <input data-link="~left" />\n  {^{slider ~top ...}}\n{{/draggable}}\n\nIf the {^{draggable}} tag uses converters, then the tag contextual parameters will correspond to the values after conversion (i.e. the actual left and top position values of the {^{draggable}} control).\nThe following sample adds a second {{draggable}} – shifted to the right, and binding to the same data properties: cx and cy. It contains two <input> textboxes with two-way data-binding to the ~left and ~top tag contextual parameters:\n'},{_type:"sample",text:'\n  .orange, .inputs {cursor: move; border: 1px solid #d55900;\n    background-color: #ffe5d2; z-index: 100;}\n  .orange {padding: 5px; width: 34px; height: 34px;\n    text-align: center; line-height: 34px;}\n  .smalltext {font-size: 12px; line-height: 17px;}\n  .inputs {display:inline-block; padding: 10px;}\n  .inputs input {width: 40px; margin: 0; font-size: 12px;}\n  body {overflow: auto;}\n  .slider .ui-slider {margin: 2px 16px 0 5px; float: left;}\n  .slider {margin-bottom: 20px;}\n\n\n\n<h4>Drag the squares:</h4>\n\n<div class="slider">\n  {^{slider cx _min=20 _max=300 _range="min" width=400/}}\n  <em>cx:</em> {^{rnd:cx}}\n</div>\n<div class="slider">\n  {^{slider cy _min=110 _max=220 _range="min" width=400/}}\n  <em>cy:</em> {^{rnd:cy}}\n</div>\n\n{^{draggable left=cx top=cy\n  _containment="document" class="orange smalltext" \n}}\n  {^{rnd:~left}}<br/>{^{rnd:~top}}\n{{/draggable}}\n\n\n{^{draggable left=cx top=cy rightshift=100\n  convert="shift" convertBack="unshift"\n  _containment="document" class="inputs" \n}}\n  <input data-link="~left" /><br/>\n  <input data-link="~top" />\n{{/draggable}}\n\n\nvar i,\n  pageTmpl = $.templates("#pageTmpl"),\n  data = {cx: 150, cy: 165};\n\n$.views.converters({\n  rnd: function(val) {\n    // To string, rounded to nearest integer\n    return "" + Math.round(val);\n  },\n  shift: function(left, top) {\n    // Shift to the right, by amount rightshift\n    return [\n      (Math.round(left) + this.tagCtx.props.rightshift) || undefined,\n      (Math.round(top) - 6) || undefined\n    ];\n  },\n  unshift: function(left, top) {\n    // Shift to the left, by amount rightshift\n    return [\n      (Math.round(left) - this.tagCtx.props.rightshift) || undefined,\n      (Math.round(top) + 6) || undefined\n    ];\n  }\n});\n\npageTmpl.link("#page", data);\n\n\n{^{draggable left=cx top=cy rightshift=100\n  convert="shift" convertBack="unshift" ...\n}}\n  <input data-link="~left" />\n  <input data-link="~top" />\n{{/draggable}}\n\n\n'},{_type:"para",title:"Initialization of tag contextual parameters",text:"Initialization of tag contextual parameters\nIf the values of left or top are initialized to a static value, rather than to a data-linked expression, then there will be no external two-way binding, but within the {{draggable}} control the tag contextual parameters will still be data-bound to each other and to the current position of the tag instance as it is dragged:\n{^{draggable left=210 top=70}}\n  {^{:~left}} {^{:~top}}\n{{/draggable}}\n\nIf left and top are not initialized, then the tag contextual parameters will initialize themselves to the current positon of the tag instance:\n{^{draggable}}\n  {^{:~left}} {^{:~top}}\n{{/draggable}}\n\nThe following sample illustrates both situations:\n"},{_type:"sample",text:'\n  .orange {padding: 0; width: 34px; height: 34px; text-align: center;\n    line-height: 34px; cursor: move; border: 1px solid #d55900;\n    background-color: rgba(255, 229, 210, 0.50); margin: 8px; z-index: 100;}\n  .smalltext {font-size: 12px; line-height: 17px;}\n  body {overflow: auto;}\n  .ui-slider {margin: 0 5px 10px 5px;}\n\n\n\n<h4>Drag the squares:</h4>\n\n{^{draggable\n  _containment="document" class="orange smalltext"\n}}\n  {^{rnd:~left}}<br/>{^{rnd:~top}}\n{{/draggable}}\n\n{^{draggable\n  _containment="document" class="orange smalltext"\n}}\n  {^{rnd:~left}}<br/>{^{rnd:~top}}\n{{/draggable}}\n\n{^{draggable left=210 top=70\n  _containment="document" class="orange smalltext"\n}}\n  {^{rnd:~left}}<br/>{^{rnd:~top}}\n{{/draggable}}\n\n\n\nvar i,\n  pageTmpl = $.templates("#pageTmpl"),\n  data = {};\n\n$.views.converters({\n  rnd: function(val) {\n    // To string, rounded to nearest integer\n    return "" + Math.round(val);\n  }\n});\n\npageTmpl.link("#page", data);\n\n{^{draggable}}\n  {^{:~left}} {^{:~top}}\n{{/draggable}}\n\n{^{draggable}}\n  {^{:~left}} {^{:~top}}\n{{/draggable}}\n\n{^{draggable left=210 top=70\n  {^{:~left}} {^{:~top}}\n{{/draggable}}\n\n\n'},{_type:"para",title:"Converters as parameter transforms",text:"Converters as parameter transforms\nOur next example uses converters in effect to transform between cartesian parameters left and top, and polar parameters expand (which expands ‘radially’) and rotate:\n"},{_type:"sample",url:"samples/tag-controls/jqui/draggable-droppable/draggable",text:'{^{draggable left=cx top=cy ...}}\n  {^{:~left}} {^{:~top}}\n{{/draggable}}\n\n{^{draggable left=cx2 top=cy2 ...}}\n  {^{:~left}} {^{:~top}}\n{{/draggable}}\n\n{{for points}}\n  {^{draggable left=~root.expand top=~root.rotate\n    ^cx=~root.cx ^cy=~root.cy\n    shift=angle radius=r\n    convert="polarToXY" convertBack="XYtoPolar" ...\n  }}\n    {{:angle/30}}\n  {{/draggable}}\n\n  {^{draggable left=~root.expand top=~root.rotate\n    ^cx=~root.cx2 ^cy=~root.cy2\n    shift=angle radius=r scaleRot=-2\n    convert="polarToXY" convertBack="XYtoPolar" ...\n  }}\n    {{:angle/30}}\n  {{/draggable}}\n{{/for}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar i,\n  pageTmpl = $.templates("#pageTmpl"),\n  points = 12,\n  radDlta = Math.PI/180,\n  data = {cx: 180, cy: 250, cx2: 430, cy2: 250,\n  rotate: 0, expand: 1, points: []};\n\n$.views.converters({\n  polarToXY: function(expand, rotate) {\n    // Convert from polar coords (with center at (cx, cy) to XY coords\n    var tagCtx = this.tagCtx,\n      root = tagCtx.ctx.root,\n      props = tagCtx.props,\n      scaleRot = props.scaleRot || 1,\n      angle = 180 + props.shift + rotate*scaleRot,\n      r = props.radius*expand;\n    // Return new [x, y] coordinates\n    return [\n      props.cx - r*Math.sin((angle)*radDlta),\n      props.cy + r*Math.cos((angle)*radDlta)\n    ];\n  },\n  XYtoPolar: function(left, top) {\n    // Convert from XY coords to polar coords, with center at (cx, cy)\n    var tagCtx = this.tagCtx,\n      root = tagCtx.ctx.root,\n      props = tagCtx.props,\n      angle = props.shift,\n      scaleRot = props.scaleRot || 1,\n      // Calculate new polar coords - [expand, rotate]\n      expand = Math.sqrt(Math.pow(props.cx - left, 2)\n        + Math.pow(props.cy - top, 2))/props.radius,\n      rotate = Math.atan2(props.cx - left, top - props.cy)/radDlta\n        + 180 - props.shift;\n    return [expand, rotate/scaleRot];\n  },\n  rnd: function(val) {\n    // To string, rounded to nearest integer\n    return "" + Math.round(val);\n  },\n  rnd2: function(val) {\n    // To string, rounded to two decimal places\n    return "" + Math.round(100*val)/100;\n  },\n  toNum: function(val) {\n    // Convert to number\n    return isNaN(val) ? 0 : parseFloat(val);\n  }\n});\n\ni = points;\nwhile (i--) {\n  data.points.push({r: 100, angle: i*30});\n}\n\npageTmpl.link("#page", data);\n\n<style>\r\n  .orange, .green {padding: 0; width: 34px; height: 34px;\r\n    z-index: 100;-webkit-user-select: none; -moz-user-select: none;\r\n    -ms-user-select: none; user-select: none;\r\n    text-align: center; line-height: 34px; cursor: move;}\r\n  .orange {border: 1px solid #d55900;\r\n    background-color: rgba(255, 229, 210, 0.50);}\r\n  .green {border: 1px solid #00cc1a;\r\n    background-color: rgba(212, 255, 218, 0.50);}\r\n  .smalltext {font-size: 12px; line-height: 17px;}\r\n  .slider .ui-slider {margin: 2px 16px 0 5px; float: left;}\r\n  .slider {margin-bottom: 20px;}\r\n  h4 {margin: 12px 0;}\r\n  body {overflow: auto;}\r\n  #cont {height: 450px;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n<div id="cont">\r\n<h4>Drag any square:</h4>\r\n\r\n<div class="slider">\r\n  {^{slider expand _min=-2 _max=2 _range="min" _step=.01 width=400/}}\r\n  <em>expand:</em> {^{rnd2:expand}}\r\n</div>\r\n\r\n<div class="slider">\r\n  {^{slider rotate _min=-0 _max=360 _range="min" width=400/}}\r\n  <em>rotate:</em> {^{rnd:rotate}}\r\n</div>\r\n\r\n{^{draggable left=cx top=cy\r\n  _containment="document" class="orange smalltext" \r\n}}\r\n  {^{rnd:~left}}<br/>{^{rnd:~top}}\r\n{{/draggable}}\r\n\r\n{^{draggable left=cx2 top=cy2\r\n  _containment="document" class="green smalltext"\r\n}}\r\n  {^{rnd:~left}}<br/>{^{rnd:~top}}\r\n{{/draggable}}\r\n\r\n{{for points}}\r\n  {^{draggable left=~root.expand top=~root.rotate\r\n    ^cx=~root.cx ^cy=~root.cy\r\n    shift=angle radius=r\r\n    convert="polarToXY" convertBack="XYtoPolar"\r\n    _containment="document" class="orange"\r\n  }}\r\n    {{:angle/30}}\r\n  {{/draggable}}\r\n\r\n  {^{draggable left=~root.expand top=~root.rotate\r\n    ^cx=~root.cx2 ^cy=~root.cy2\r\n    shift=angle radius=r scaleRot=-2\r\n    convert="polarToXY" convertBack="XYtoPolar"\r\n    _containment="document" class="green"\r\n  }}\r\n    {{:angle/30}}\r\n  {{/draggable}}\r\n{{/for}}\r\n\r\n</div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Custom {{draggable}} tag (without jQuery UI)",text:"Custom {{draggable}} tag (without jQuery UI)\nFinally here is the same sample but using a custom tag (which we name {{draggable2}}) instead of the jQueryUI widget-based {{draggable}}. It illustrates how to create a JsViews custom tag using multiple parameter binding, and providing tag contextual paramters:\n"},{_type:"sample",url:"samples/tag-controls/jqui/draggable-droppable/draggable2",text:'$.views.tags("draggable2", {\n  bindTo: ["left", "top"],\n  linkedCtxParam: ["left", "top"],\n  mainElement: "div",\n  template: "<div class=\'mytag\'>{{include tmpl=#content/}}</div>",\n  onBind: function() {\n    var tag = this;\n    tag.mainElem.on("mousedown touchstart", function(ev) {\n      var offset = tag.mainElem.offset(),\n        addedLeft = offset.left - ev.clientX,\n        addedTop = offset.top - ev.clientY;\n      if (document.elementFromPoint(ev.clientX, ev.clientY) === tag.mainElem[0]) {\n        $(document).on("mousemove touchmove", function(ev2) {\n          setTimeout(function() {\n            var moveToX = ev2.clientX + addedLeft,\n              moveToY = ev2.clientY + addedTop;\n            tag.updateValues(moveToX, moveToY);\n            tag.setValues(moveToX, moveToY);\n          }, 0);\n          ev.preventDefault();\n        });\n      }\n      ev.preventDefault();\n    });\n    $(document).on("mouseup touchend", function() {\n      $(document).off("mousemove touchmove");\n    });\n  },\n  setValue: function(value, index) {\n    this.mainElem.offset(index ? {top: value || 0} : {left: value || 0});\n  },\n  getValue: function() {\n    var offset = this.mainElem.offset();\n    return [offset.left, offset.top];\n  },\n  onUpdate: false,\n  setSize: true\n});\n\n\n"use strict";\n$.views.tags("draggable2", {\n  bindTo: ["left", "top"],\n  linkedCtxParam: ["left", "top"],\n  mainElement: "div",\n  template: "<div class=\'mytag\'>{{include tmpl=#content/}}</div>",\n  onBind: function() {\n    var tag = this;\n    tag.mainElem.on("mousedown touchstart", function(ev) {\n      var offset = tag.mainElem.offset(),\n        addedLeft = offset.left - ev.clientX,\n        addedTop = offset.top - ev.clientY;\n      if (document.elementFromPoint(ev.clientX, ev.clientY) === tag.mainElem[0]) {\n        $(document).on("mousemove touchmove", function(ev2) {\n          setTimeout(function() {\n            var moveToX = ev2.clientX + addedLeft,\n              moveToY = ev2.clientY + addedTop;\n            tag.updateValues(moveToX, moveToY);\n            tag.setValues(moveToX, moveToY);\n          }, 0);\n          ev.preventDefault();\n        });\n      }\n      ev.preventDefault();\n    });\n    $(document).on("mouseup touchend", function() {\n      $(document).off("mousemove touchmove");\n    });\n  },\n  setValue: function(value, index) {\n    this.mainElem.offset(index ? {top: value || 0} : {left: value || 0});\n  },\n  getValue: function() {\n    var offset = this.mainElem.offset();\n    return [offset.left, offset.top];\n  },\n  onUpdate: false,\n  setSize: true\n});\n\nvar i,\n  pageTmpl = $.templates("#pageTmpl"),\n  points = 12,\n  radDlta = Math.PI/180,\n  data = {cx: 180, cy: 250, cx2: 430, cy2: 250,\n  rotate: 0, expand: 1, points: []};\n\n$.views.converters({\n  polarToXY: function(expand, rotate) {\n    // Convert from polar coords (with center at (cx, cy) to XY coords\n    var tagCtx = this.tagCtx,\n      root = tagCtx.ctx.root,\n      props = tagCtx.props,\n      scaleRot = props.scaleRot || 1,\n      angle = 180 + props.shift + rotate*scaleRot,\n      r = props.radius*expand;\n    // Return new [x, y] coordinates\n    return [\n      props.cx - r*Math.sin((angle)*radDlta),\n      props.cy + r*Math.cos((angle)*radDlta)\n    ];\n  },\n  XYtoPolar: function(left, top) {\n    // Convert from XY coords to polar coords, with center at (cx, cy)\n    var tagCtx = this.tagCtx,\n      root = tagCtx.ctx.root,\n      props = tagCtx.props,\n      angle = props.shift,\n      scaleRot = props.scaleRot || 1,\n      // Calculate new polar coords - [expand, rotate]\n      expand = Math.sqrt(Math.pow(props.cx - left, 2)\n        + Math.pow(props.cy - top, 2))/props.radius,\n      rotate = Math.atan2(props.cx - left, top - props.cy)/radDlta\n        + 180 - props.shift;\n    return [expand, rotate/scaleRot];\n  },\n  rnd: function(val) {\n    // To string, rounded to nearest integer\n    return "" + Math.round(val);\n  },\n  rnd2: function(val) {\n    // To string, rounded to two decimal places\n    return "" + Math.round(100*val)/100;\n  },\n  toNum: function(val) {\n    // Convert to number\n    return isNaN(val) ? 0 : parseFloat(val);\n  }\n});\n\ni = points;\nwhile (i--) {\n  data.points.push({r: 100, angle: i*30});\n}\n\npageTmpl.link("#page", data);\n\n<style>\r\n  .orange, .green {padding: 0; width: 34px; height: 34px;\r\n    z-index: 100;-webkit-user-select: none; -moz-user-select: none;\r\n    -ms-user-select: none; user-select: none;\r\n    text-align: center; line-height: 34px; cursor: move;}\r\n  .orange {border: 1px solid #d55900;\r\n    background-color: rgba(255, 229, 210, 0.50);}\r\n  .green {border: 1px solid #00cc1a;\r\n    background-color: rgba(212, 255, 218, 0.50);}\r\n  .smalltext {font-size: 12px; line-height: 17px;}\r\n  .slider .ui-slider {margin: 2px 16px 0 5px; float: left;}\r\n  .slider {margin-bottom: 20px;}\r\n  h4 {margin: 12px 0;}\r\n  body {overflow: auto;}\r\n  #cont {height: 450px;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n<div id="cont">\r\n<h4>Drag any square:</h4>\r\n\r\n<div class="slider">\r\n  {^{slider expand _min=-2 _max=2 _range="min" _step=.01 width=400/}}\r\n  <em>expand:</em> {^{rnd2:expand}}\r\n</div>\r\n\r\n<div class="slider">\r\n  {^{slider rotate _min=-0 _max=360 _range="min" width=400/}}\r\n  <em>rotate:</em> {^{rnd:rotate}}\r\n</div>\r\n\r\n{^{draggable2 left=cx top=cy\r\n  _containment="document" class="orange smalltext" \r\n}}\r\n  {^{rnd:~left}}<br/>{^{rnd:~top}}\r\n{{/draggable2}}\r\n\r\n{^{draggable2 left=cx2 top=cy2\r\n  _containment="document" class="green smalltext"\r\n}}\r\n  {^{rnd:~left}}<br/>{^{rnd:~top}}\r\n{{/draggable2}}\r\n\r\n{{for points}}\r\n  {^{draggable left=~root.expand top=~root.rotate\r\n    ^cx=~root.cx ^cy=~root.cy\r\n    shift=angle radius=r\r\n    convert="polarToXY" convertBack="XYtoPolar"\r\n    _containment="document" class="orange"\r\n  }}\r\n    {{:angle/30}}\r\n  {{/draggable}}\r\n\r\n  {^{draggable2 left=~root.expand top=~root.rotate\r\n    ^cx=~root.cx2 ^cy=~root.cy2\r\n    shift=angle radius=r scaleRot=-2\r\n    convert="polarToXY" convertBack="XYtoPolar"\r\n    _containment="document" class="green"\r\n  }}\r\n    {{:angle/30}}\r\n  {{/draggable2}}\r\n{{/for}}\r\n\r\n</div>\r\n</script>\r\n\r\n<div id="page"></div>\n'}]},"samples/tag-controls/jqui/menu":{sections:[{_type:"para",title:"",text:'The following sample uses the {{menu}} tag control – based on the jQuery UI menu widget (api).\nThe sample is a declarative data-driven version of the jQuery UI Menu – icons demo.\nThe ~menuAction helper function is assigned as event handler for the jQuery UI Menu widget select event.\n{^{menu ~menuAction}}\n  <li>\n    <div><span class="ui-icon ui-icon-disk"></span>Save</div>\n  </li>\n  ...\n{{/menu}}\n\n'},{_type:"sample",title:"Tag syntax, in a template",url:"samples/tag-controls/jqui/menu/menu",text:'Tag syntax, in a template\n{^{menu ~menuAction}}\n  <li>\n    <div><span class="ui-icon ui-icon-disk"></span>Save</div>\n  </li>\n  ...\n{{/menu}}\n\npageTmpl.link("#page", data, {\n  menuAction: function(ev, ui) {\n    ...\n    alert(ui.item.text());\n  }\n});\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar data = {},\n  pageTmpl = $.templates("#pageTmpl");\n\npageTmpl.link("#page", data, {\n  menuAction: function(ev, ui) {\n    if (!ui.item.children("ul").length) {\n      // Leaf menu item\n      alert(ui.item.text());\n    }\n  }\n});\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n{^{menu ~menuAction width=150}}\r\n  <li><div>\r\n    <span class="ui-icon ui-icon-disk"></span>\r\n    Save\r\n  </div></li>\r\n  <li><div>\r\n    <span class="ui-icon ui-icon-zoomin"></span>\r\n    Zoom In\r\n  </div></li>\r\n  <li><div>\r\n    <span class="ui-icon ui-icon-zoomout"></span>\r\n    Zoom Out\r\n  </div></li>\r\n  <li class="ui-state-disabled"><div>\r\n    <span class="ui-icon ui-icon-print"></span>\r\n    Print...\r\n  </div></li>\r\n  <li>\r\n    <div>Playback</div>\r\n    <ul>\r\n      <li><div>\r\n        <span class="ui-icon ui-icon-seek-start"></span>\r\n        Prev\r\n      </div></li>\r\n      <li><div>\r\n        <span class="ui-icon ui-icon-stop"></span>\r\n        Stop\r\n      </div></li>\r\n      <li><div>\r\n        <span class="ui-icon ui-icon-play"></span>\r\n        Play\r\n      </div></li>\r\n      <li><div>\r\n        <span class="ui-icon ui-icon-seek-end"></span>\r\n        Next\r\n      </div></li>\r\n    </ul>\r\n  </li>\r\n  <li><div>\r\n    Learn more about this menu\r\n  </div></li>\r\n{{/menu}}\r\n\r\n<div><p>Some page content.</p></div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"",text:'The same result can be obtained using element-based data-link markup:\n<ul data-link="{menu ~menuAction}">\n  <li>\n    <div><span class="ui-icon ui-icon-disk"></span>Save</div>\n  </li>\n  ...\n</ul>\n\nHere it is as top-level data-linked content:\n'},{_type:"sample",title:"Data-link syntax, top-level content",text:'Data-link syntax, top-level content\n\n\n\n\n  \n    \n    Save\n  \n  \n    \n    Zoom In\n  \n  \n    \n    Zoom Out\n  \n  \n    \n    Print...\n  \n  \n    Playback\n    \n      \n        \n        Prev\n      \n      \n        \n        Stop\n      \n      \n        \n        Play\n      \n      \n        \n        Next\n      \n    \n  \n  \n    Learn more about this menu\n  \n\n\n\nSome page content.\nvar data = {};\n\n$.link(true, "#linked", data, {\n  menuAction: function(ev, ui) {\n    if (!ui.item.children("ul").length) {\n      // Leaf menu item\n      alert(ui.item.text());\n    }\n  }\n});\n<div id="linked">\n  ...\n  <ul data-link="{menu ~menuAction}">\n    <li>\n      <div><span class="ui-icon ui-icon-disk"></span>Save</div>\n    </li>\n    ...\n  </ul>\n  ...\n\n$.link(true, "#linked", data, {\n  menuAction: function(ev, ui) {\n    ...\n    alert(ui.item.text());\n  }\n});\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n'
}]},"samples/tag-controls/jqui/progressbar":{sections:[{_type:"para",title:"",text:"The following sample uses the {{progressbar}}, {{slider}} and {{button}} tag controls – based on the jQuery UI progressbar widget (api), slider widget (api) and button widget (api).\nThe sample is a declarative data-driven version of the jQuery UI Progress Bar – custom label demo.\n"},{_type:"sample",url:"samples/tag-controls/jqui/progressbar/variants",text:'Tag syntax:\n{^{progressbar amount\n  busy=mode==="Busy"\n  _max=max\n  _change=~change\n  _complete=~complete\n  width="70%"\n  height=25\n/}}\n\nTag syntax – wrapping a <div>, to provide a custom label:\n{^{progressbar amount\n  busy=mode==="Busy"\n  _max=max\n  ...\n}}\n  <div class="proglabel" data-link="label||100*amount/max+\'%\'"></div>\n{{/progressbar}}\n\nData-linked element syntax (again wrapping a <div>, to provide a custom label):\n<div data-link="{progressbar amount\n  busy=mode===\'Busy\'\n  _max=max\n  ...\n}">\n  <div class="proglabel" ...></div>\n</div>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar data = {\n    mode: "Stop",\n    label: "",\n    amount: 0,\n    max: 1000,\n    go: function() {\n      $.observable(data).setProperty("mode", data.mode==="Go"?"Stop":"Go");\n      progress();\n    },\n    busy: function() {\n      $.observable(data).setProperty("mode", data.mode==="Busy"?"Go":"Busy");\n      progress();\n    },\n    done: function() {\n      $.observable(data).setProperty({\n        mode: "Go",\n        amount: data.max\n      });\n    },\n    restart: function() {\n      $.observable(data).setProperty({\n        mode: data.mode==="Go"?"Stop":"Go",\n        amount: data.amount >= data.max ? 0 : data.amount\n      });\n      progress();\n    }\n  },\n  pageTmpl = $.templates("#pageTmpl");\n\n  pageTmpl.link("#page", data, {\n    change: function() {\n      $.observable(data).setProperty("label", "");\n    },\n    complete: function() {\n      $.observable(data).setProperty("label", "Complete!" );\n    }\n  });\n\nfunction progress() {\n  if (data.mode==="Go") {\n    if ( data.amount < data.max ) {\n      $.observable(data).setProperty( "amount", Math.min(data.max, data.amount + 10));\n      setTimeout( progress, 50 );\n    } else {\n  $.observable(data).setProperty("mode", "Stop");\n    }\n  }\n}\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n<h4>Tag syntax:</h4>\r\n\r\n<pre>\r\n&lcub;^{progressbar amount .../}&rcub;\r\n</pre>\r\n\r\n<!--tag syntax-->\r\n{^{progressbar amount\r\n  busy=mode==="Busy"\r\n  _max=max\r\n  _change=~change\r\n  _complete=~complete\r\n  width="70%"\r\n  height=24\r\n/}}\r\n\r\n<h4>Tag syntax, wrapping element:</h4>\r\n\r\n<pre>\r\n&lcub;^{progressbar amount ...}&rcub;\r\n    &lt;div ...> ... &lt;/div>\r\n&lcub;^{/progressbar}&rcub;\r\n</pre>\r\n\r\n<!--tag syntax - with custom label-->\r\n{^{progressbar amount\r\n  busy=mode==="Busy"\r\n  _max=max\r\n  _change=~change\r\n  _complete=~complete\r\n  width="70%"\r\n  height=24\r\n}}\r\n  <div class="proglabel" data-link="label||100*amount/max+\'%\'"></div>\r\n{{/progressbar}}\r\n\r\n<h4>Element-based data-link syntax:</h4>\r\n\r\n<pre>\r\n&lt;div data-link="{progressbar amount ...}">...&lt;/div>\r\n</pre>\r\n\r\n<!--alternative data-linked element syntax-->\r\n<div data-link="{progressbar amount\r\n  busy=mode===\'Busy\'\r\n  _max=max\r\n  _change=~change\r\n  _complete=~complete\r\n  width=\'70%\'\r\n  height=25\r\n}">\r\n  <div class="proglabel" data-link="label||100*amount/max+\'%\'"></div>\r\n</div>\r\n\r\n<h4>Slider:</h4>\r\n\r\n{^{slider amount _min=0 _max=max ^_disabled=mode==\'Busy\' width="70%"/}}\r\n\r\n{^{controlgroup mode}}\r\n  {^{on restart }}\r\n    {^{button ^_disabled=mode==\'Busy\' ^_label=mode===\'Stop\'?\'Start\':\'Stop\'}}Start{{/button}}\r\n  {{/on}}\r\n  {^{on busy }}\r\n    {^{button ^_disabled=mode==\'Stop\' ^_label=mode===\'Busy\'?\'Resume\':\'Busy\'}}Busy{{/button}}\r\n  {{/on}}\r\n{{/controlgroup}}\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/jqui/api":{sections:[{_type:"para",title:"Declarative setting of options",text:"Declarative setting of options\nAny widget options can be initialized by setting a named property on the tag – using the option name preceded by _.\nFor example:\n{^{datepicker startDate\n  _changeMonth=true\n  ...\n/}}\n\nas shown in this sample.\n"},{_type:"para",title:"Data-linked option",text:"Data-linked option\nIf you want the widget option to be not only initialized, but also data-linked (to respond to “observable” changes), prepend a ^ character(see Binding to named properties), as shown in the same sample:\n{^{datepicker endDate\n  ^_minDate=startDate\n/}}\n\n"},{_type:"para",title:"Using jQuery UI widget events",text:"Using jQuery UI widget events\nNamed tag properties can also be used to set widget event handlers declaratively, as illustrated in this sample:\n{^{progressbar amount\n  ...\n  _change=~change\n  _complete=~complete\n  ...\n/}}\n\n"},{_type:"para",title:"Programmatic setting of options",text:'Programmatic setting of options\nA simple way to set widget options using the standard jQuery UI programmatic approach is to declare an id on the tag, and then use the corresponding jQuery selector, as illustrated in this toolbar sample:\n{^{checkbox reverse id="myCheckbox"/}}\n\n// Set the \'classes\' option\n$("#myCheckbox").checkboxradio("option", "classes", {"ui-checkbox...": ...});\n\n$.observe(model, "reverse", function() {\n  // Set the \'label\' option\n  $("#myCheckbox").checkboxradio("option", "label", ...);\n});\n\nAnother approach (not requiring id assignment) is to override the onBind event of the tag, and set options programmatically in the handler. This approach is also used in the same toolbar sample:\n{^{controlgroup onBind=~onbind}}\n\npageTmpl.link("#page", model, {\n  ...\n  onbind: function(val) {\n    this.baseApply(arguments);\n    this.mainElem.controlgroup("option", "classes", ...);\n  },\n  ...\n});\n\n'},{_type:"para",title:"Getting from a tag instance to the widget APIs",text:'Getting from a tag instance to the widget APIs\nAlternatively, if you have an instance, myTag, of a jQuery UI widget tag control, you can access the widget API from myTag.mainElem.widgetName(...) or  from myTag.widget(...):\n// Set the \'label\' option\ncheckboxTag.mainElem.checkboxradio("option", "label", ...);\n\nor\n// Set the \'label\' option\ncheckboxTag.widget.option("label", ...);\n\n'},{_type:"para",title:"Calling jQuery UI widget methods",text:'Calling jQuery UI widget methods\nCalling widget methods, like programmatic setting of options, can be done –\n\nusing the selector approach:\n$("#myCheckbox").checkboxradio("disable");\n\nfrom the tag instance, using tag.mainElem:\ncheckboxTag.mainElem.checkboxradio("disable");\n\nfrom the tag instance, using tag.widget:\ncheckboxTag.widget.disable();\n\n\nEach of these approaches is shown in the following sample:\n'},{_type:"sample",title:"Accessing jQuery UI widget APIs",text:'Accessing jQuery UI widget APIs\n\n  {^{on enable}}Enable{{/on}}\n  {^{on disable}}Disable{{/on}}<br/><br/>\n  {^{checkbox reverse id="myCheckbox" label="Reverse"/}}\n\n\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    reverse: false,\n    enable: function() {\n      $("#myCheckbox")\n        .checkboxradio("enable")                        // Method call\n        .checkboxradio("option", "label", "New label"); // Chaining with \'set option\' call \n    },\n    disable: function(ev) {\n      // Get parent view\n      var parentView = $.view(ev.target, "data");\n      // Find {{checkbox}} tags\n      var checkboxTag = parentView.childTags(true, "checkbox")[0];\n      checkboxTag.widget\n        .disable()                                       // Method call\n        .option("label", "New label2");                  // Chaining with \'set option\' call\n// alternatively\n//    checkboxTag.mainElem\n//      .checkboxradio("disable")                        // Method call\n//      .checkboxradio("option", "label", "New label2"); // Chaining with \'set option\' call\n    }\n  };\n\npageTmpl.link("#page", model);\n\n\nSelector:\n$("#myCheckbox")\n  .checkboxradio("enable");                       // Method call \n  .checkboxradio("option", "label", "New label"); // Chaining with \'set option\' call \n\ntag.widget:\ncheckboxTag.widget\n  .disable()                                       // Method call\n  .option("label", "New label2");                  // Chaining with \'set option\' call\n\ntag.mainElem:\ncheckboxTag.mainElem\n  .checkboxradio("disable")                        // Method call\n  .checkboxradio("option", "label", "New label2"); // Chaining with \'set option\' call\n\n\n'}]},"samples/tag-controls/jqui/tabs":{sections:[{_type:"para",title:"",text:"The following sample uses the {{tabs}} tag control – based on the jQuery UI tabs widget (api).\nThe sample is a declarative data-driven version of the jQuery UI Tabs – Collapse content demo – shown both using tag syntax and data-linked element syntax.\n"},{_type:"sample",title:"Collapsible tabs",text:'Collapsible tabs\n\n\n<h4>Tag syntax:</h4>\n\n<pre>\n&lcub;^{tabs ...}&rcub;...&lcub;^{/tabs}&rcub;\n</pre>\n\n<!--tag syntax-->\n{^{tabs _collapsible=true}}\n  <ul>\n    <li><a href="#tabs-1">Nunc tincidunt</a></li>\n    <li><a href="#tabs-2">Proin dolor</a></li>\n    <li><a href="#tabs-3">Aenean lacinia</a></li>\n  </ul>\n  <div id="tabs-1">\n    <p><em>Click tab again to close content pane.</em></p>\n    <p>Proin elit arcu, rutrum commodo, vehicula tempus, commodo a,\n    risus. Curabitur nec arcu. Donec sollicitudin mi sit amet mauris.</p>\n  </div>\n  <div id="tabs-2">\n    <p><em>Click tab again to close content pane.</em></p>\n    <p>Morbi tincidunt, dui sit amet facilisis feugiat,\n    odio metus gravida ante, ut pharetra massa metus id nunc.</p>\n  </div>\n  <div id="tabs-3">\n    <p><em>Click tab again to close content pane.</em></p>\n    <p>Duis cursus.</p>\n  </div>\n{{/tabs}}\n\n<h4>Element-based data-link syntax:</h4>\n\n<pre>\n&lt;div data-link="{tabs _collapsible=true}">...&lt;/div>\n</pre>\n\n<!--alternative data-linked element syntax-->\n<div data-link="{tabs _collapsible=true}">\n  <ul>\n    <li><a href="#tabs-1b">Not latin</a></li>\n    <li><a href="#tabs-2b">Tab2</a></li>\n    <li><a href="#tabs-3b">Tab3</a></li>\n  </ul>\n  <div id="tabs-1b">\n    <p><em>Click tab again to close content pane.</em></p>\n    <p>First non-latin text.</p>\n  </div>\n  <div id="tabs-2b">\n    <p><em>Click tab again to close content pane.</em></p>\n    <p>Second text.</p>\n  </div>\n  <div id="tabs-3b">\n    <p><em>Click tab again to close content pane.</em></p>\n    <p>Further content.</p>\n  </div>\n</div>\n\n\n\n\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {};\n\npageTmpl.link("#page", model);\nTag syntax:\n{^{tabs _collapsible=true}}\n  <ul>\n    <li><a href="#tabs-1">...</a></li>\n    <li><a href="#tabs-2">...</a></li>\n    ...\n  </ul>\n  <div id="tabs-1">...</div>\n  <div id="tabs-2">...</div>\n  ...\n{{/tabs}}\n\nData-linked element syntax:\n<div data-link="{tabs _collapsible=true}">\n  <ul>\n    <li><a href="#tabs-1">...</a></li>\n    <li><a href="#tabs-2">...</a></li>\n    ...\n  </ul>\n  <div id="tabs-1">...</div>\n  <div id="tabs-2">...</div>\n  ...\n</div>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n'
},{_type:"para",title:"Initializing the selected tab",text:'Initializing the selected tab\nBy default the first tab is selected initially.\nTo specify different initial tab selection, pass an integer as argument.\n{^{tabs 2 _collapsible=true}}...\n\nor\n<div data-link="{tabs 2 _collapsible=true}">...\n\nTo initialize with collapsed tabs, pass the argument false.\n'},{_type:"para",title:"Data-linking the selected tab",text:"Data-linking the selected tab\nThe ‘selected tab’ argument can of course be provided by an expression or data path:\n{^{tabs selectedTab _collapsible=true}}...\n\nIn  this case, the {{tabs}} control provides two-way data-binding on the corresponding data property (selectedTab).\nThis is illustrated in the following sample, which is the same as the sample above except that both sets of tabs are data-linked to the same selectedTab property. As a result, the two tabs controls stay in sync: changing (or collapsing) the tab on one will trigger the corresponding change on the other.\n"},{_type:"sample",title:"Data-linking the selected tab",url:"samples/tag-controls/jqui/tabs/collapsible",text:'Data-linking the selected tab\nTag syntax:\n{^{tabs selectedTab _collapsible=true}}\n  ...\n\nData-linked element syntax:\n<div data-link="{tabs selectedTab _collapsible=true}">\n  ...\n\nCode:\nvar model = {selectedTab: 1};\n\npageTmpl.link("#page", model);\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {selectedTab: 1};\n\npageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<b>Selected tab:</b> {^{:selectedTab}}\r\n\r\n<h4>Tag syntax:</h4>\r\n\r\n<pre>\r\n&lcub;^{tabs ...}&rcub;...&lcub;^{/tabs}&rcub;\r\n</pre>\r\n\r\n<!--tag syntax-->\r\n{^{tabs selectedTab _collapsible=true}}\r\n  <ul>\r\n    <li><a href="#tabs-1">Nunc tincidunt</a></li>\r\n    <li><a href="#tabs-2">Proin dolor</a></li>\r\n    <li><a href="#tabs-3">Aenean lacinia</a></li>\r\n  </ul>\r\n  <div id="tabs-1">\r\n    <p><em>Click tab again to close content pane.</em></p>\r\n    <p>Proin elit arcu, rutrum commodo, vehicula tempus, commodo a,\r\n    risus. Curabitur nec arcu. Donec sollicitudin mi sit amet mauris.</p>\r\n  </div>\r\n  <div id="tabs-2">\r\n    <p><em>Click tab again to close content pane.</em></p>\r\n    <p>Morbi tincidunt, dui sit amet facilisis feugiat,\r\n    odio metus gravida ante, ut pharetra massa metus id nunc.</p>\r\n  </div>\r\n  <div id="tabs-3">\r\n    <p><em>Click tab again to close content pane.</em></p>\r\n    <p>Duis cursus.</p>\r\n  </div>\r\n{{/tabs}}\r\n\r\n<h4>Element-based data-link syntax:</h4>\r\n\r\n<pre>\r\n&lt;div data-link="{tabs  _collapsible=true}">...&lt;/div>\r\n</pre>\r\n\r\n<!--alternative data-linked element syntax-->\r\n<div data-link="{tabs selectedTab _collapsible=true}">\r\n  <ul>\r\n    <li><a href="#tabs-1b">Not latin</a></li>\r\n    <li><a href="#tabs-2b">Tab2</a></li>\r\n    <li><a href="#tabs-3b">Tab3</a></li>\r\n  </ul>\r\n  <div id="tabs-1b">\r\n    <p><em>Click tab again to close content pane.</em></p>\r\n    <p>First non-latin text.</p>\r\n  </div>\r\n  <div id="tabs-2b">\r\n    <p><em>Click tab again to close content pane.</em></p>\r\n    <p>Second text.</p>\r\n  </div>\r\n  <div id="tabs-3b">\r\n    <p><em>Click tab again to close content pane.</em></p>\r\n    <p>Further content.</p>\r\n  </div>\r\n</div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Sortable tabs",text:'Sortable tabs\nSortable tabs are obtained very simply, by wrapping the <li> markup for the tabs in a {{sortable}} tag, within the {{tabs}} tag.\n{^{tabs}}\n  {^{sortable elem="ul"}}\n    <li>...\n\nThe following sample is a declarative data-driven version of the jQuery UI Tabs – Sortable demo, using tag syntax.\nThe sample also shows how (as with any of the jQuery UI based tag controls) you can specify a class or classes on the tag:\n'},{_type:"sample",title:"",url:"samples/tag-controls/jqui/tabs/sortable",text:'Tag syntax:\n{^{tabs class="red"}}\n  {^{sortable elem="ul"}}\n    <li><a href="#tabs-1">Nunc tincidunt</a></li>\n    <li><a href="#tabs-2">Proin dolor</a></li>\n    ...\n  {{/sortable}}\n  <div id="tabs-1">...</div>\n  <div id="tabs-2">...</div>\n  ...\n{{/tabs}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {};\n\npageTmpl.link("#page", model);\n\n<style>\r\n  .red {border:solid red 2px\t !important}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<h4>Drag tabs to sort...</h4>\r\n\r\n{^{tabs class="red"}}\r\n  {^{sortable elem="ul" _axis="x"}}\r\n    <li><a href="#tabs-1">Nunc tincidunt</a></li>\r\n    <li><a href="#tabs-2">Proin dolor</a></li>\r\n    <li><a href="#tabs-3">Aenean lacinia</a></li>\r\n  {{/sortable}}\r\n  <div id="tabs-1">\r\n    <p>Proin elit arcu, rutrum commodo, vehicula tempus, commodo a,\r\n    risus. Curabitur nec arcu. Donec sollicitudin mi sit amet mauris.</p>\r\n  </div>\r\n  <div id="tabs-2">\r\n    <p>Morbi tincidunt, dui sit amet facilisis feugiat,\r\n    odio metus gravida ante, ut pharetra massa metus id nunc.</p>\r\n  </div>\r\n  <div id="tabs-3">\r\n    <p>Duis cursus.</p>\r\n  </div>\r\n{{/tabs}}\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Using {{tabs}} with a data-linked array",text:'Using {{tabs}} with a data-linked array\nA data-driven approach can be used, with the tab header text and panel contents rendered from a data array:\n{^{tabs}}\n  <ul>\n    {^{for tabPanels}}\n      <li><a href="#{{:id}}">{{:header}}</a></li>\n    {{/for}}\n  </ul>\n  {^{for tabPanels}}\n    <div id="{{:id}}">{{:content}}</div>\n  {{/for}}\n{{/tabs}}\n\n'},{_type:"para",title:"Sortable tabs with  a data-linked array",text:"Sortable tabs with  a data-linked array\nIf a {{tabs}} tag control with content coming from a data-driven array is also sortable, then sorting the tabs will sort the underlying data array – and raise corresponding observable events. This is the same behavior as is obtained with the {{sortable}} tag used alone, without {{tabs}}. To opt out of the observable binding on the array, set {^{sortable _bindArray=false ...}}.\nThe following sample shows data-linking to the underlying array, with a sortable {{tabs}} tag control:\n"},{_type:"sample",url:"samples/tag-controls/jqui/tabs/sortablearray",text:'{^{tabs selectedTab}}\n  {^{sortable elem="ul" _axis="x"}}\n    {^{for tabData}}<li><a href="#{{:id}}">{^{:header}}</a></li>{{/for}}\n  {{/sortable}}\n  {^{for tabData}}\n    <div id="{{:id}}">{^{:content}}</div>\n  {{/for}}\n{{/tabs}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar cnt = 2,\n  pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    selectedTab: 1,\n    tabData: [\n      {\n        id: "tabs-0",\n        header: "First tab",\n        content: "First tab content"\n      },\n      {\n        id: "tabs-1",\n        header: "Another tab",\n        content: "More content"\n      },\n      {\n        id: "tabs-2",\n        header: "Third tab",\n        content: "Even more content"\n      }\n    ]\n  };\n\npageTmpl.link("#page", model, {\n  remove: function(index) {\n    $.observable(model.tabData).remove(index);\n  },\n  append: function() {\n    cnt++;\n    $.observable(model.tabData).insert({\n      id: "tabs-" + cnt,\n      header: "Added" + cnt,\n      content: "Added content "  + cnt\n    });\n  }\n});\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<h4>Drag tabs to sort...</h4>\r\n\r\n{^{tabs selectedTab}}\r\n  {^{sortable elem="ul" _axis="x"}}\r\n    {^{for tabData}}<li><a href="#{{:id}}">{^{:header}}</a></li>{{/for}}\r\n  {{/sortable}}\r\n  {^{for tabData}}\r\n    <div id="{{:id}}">{^{:content}}</div>\r\n  {{/for}}\r\n{{/tabs}}\r\n\r\n<h4>Selected tab:</h4>\r\n\r\n<input data-link="selectedTab" />\r\n\r\n<h4>Tabs data (edit or sort):</h4>\r\n\r\n{^{on ~append}}Add tab{{/on}}<br/><br/>\r\n\r\n<ul>\r\n  {^{for tabData}}\r\n    <li>\r\n      <a data-link="{on ~remove #index}">x</a>\r\n      <input data-link="header" /> <input data-link="content" />\r\n      {^{if ~root.selectedTab===#index}}\r\n        (selected)\r\n      {{/if}}\r\n    </li>\r\n  {{/for}}\r\n</ul>\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Sortable tabs with  a data-linked array &ndash; top-level data-linking",text:"Sortable tabs with  a data-linked array – top-level data-linking\nFinally, here is the same sample as above, but achieved entirely through top-level data linking:\n"},{_type:"sample",url:"samples/tag-controls/jqui/tabs/sortablearray-toplevel",text:'<script id="tabsMarkup" type="text/x-jsrender">\n  {^{sortable elem="ul" _axis="x"}}\n    {^{for tabData}}<li><a href="#{{:id}}">{^{:header}}</a></li>{{/for}}\n  {{/sortable}}\n  {^{for tabData}}\n    <div id="{{:id}}">{^{:content}}</div>\n  {{/for}}\n</script>\n\nTop-level data-linked element:\n<div class="linkedUI" data-link="{include tmpl=\'#tabsMarkup\'}{tabs selectedTab}"></div>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar cnt = 2,\n  model = {\n    selectedTab: 1,\n    tabData: [\n      {\n        id: "tabs-0",\n        header: "First tab",\n        content: "First tab content"\n      },\n      {\n        id: "tabs-1",\n        header: "Another tab",\n        content: "More content"\n      },\n      {\n        id: "tabs-2",\n        header: "Third tab",\n        content: "Even more content"\n      }\n    ]\n  };\n\n$.link(true, ".linkedUI", model, {\n  remove: function(index) {\n    $.observable(model.tabData).remove(index);\n  },\n  append: function() {\n    cnt++;\n    $.observable(model.tabData).insert({\n      id: "tabs-" + cnt,\n      header: "Added" + cnt,\n      content: "Added content "  + cnt\n    });\n  }\n});\n\n<script id="tabsMarkup" type="text/x-jsrender">\r\n  {^{sortable elem="ul" _axis="x"}}\r\n    {^{for tabData}}<li><a href="#{{:id}}">{^{:header}}</a></li>{{/for}}\r\n  {{/sortable}}\r\n  {^{for tabData}}\r\n    <div id="{{:id}}">{^{:content}}</div>\r\n  {{/for}}\r\n</script>\r\n\r\n<script id="dataList" type="text/x-jsrender">\r\n  <li>\r\n    <a data-link="{on ~remove #index}">x</a>\r\n    <input data-link="header" /> <input data-link="content" />\r\n    {^{if ~root.selectedTab===#index}}\r\n      (selected)\r\n    {{/if}}\r\n  </li>\r\n</script>\r\n\r\n<h4>Drag tabs to sort...</h4>\r\n\r\n<div class="linkedUI" data-link="{include tmpl=\'#tabsMarkup\'}{tabs selectedTab}"></div>\r\n\r\n<h4>Selected tab:</h4>\r\n\r\n<input class="linkedUI" data-link="selectedTab" />\r\n\r\n<h4>Tabs data (edit or sort):</h4>\r\n\r\n<button class="linkedUI" data-link="{on ~append}">Add tab</button><br/><br/>\r\n\r\n<ul class="linkedUI" data-link="{for tabData tmpl=\'#dataList\'}"></ul>\n'
}]},"samples/tag-controls/jqui/selectmenu":{sections:[{_type:"para",title:"",text:'The {{selectmenu}} tag control integrates the jQuery UI selectmenu widget (api).\nWhen using tag syntax, the tag wraps directly the <option> elements:\n{^{selectmenu color}}\n  <option value="black">Black</option>\n  <option value="red">Red</option>\n  ...\n{{/selectmenu}}\n\nAlternatively, the selectmenu tag binding can be used with a data-linked <select> element:\n<select data-link="{selectmenu color}">\n  <option value="black">Black</option>\n  <option value="red">Red</option>\n  ...\n</select>\n\nA data-driven approach can be used, with the <option> elements rendered from a data array:\n{^{selectmenu color}}\n  {^{for colors}}\n    <option value="{{:name}}">{{:label}}</option>\n  {{/for}}\n{{/selectmenu}}\n\nThis is shown in the following sample, which is a declarative data-driven version of the jQuery UI Selectmenu – product selection demo:\n'},{_type:"sample",url:"samples/tag-controls/jqui/selectmenu/product-selection",text:'Data:\nvar model = {\n  color: "yellow",\n  colors: [\n    {name: "black", label: "Black"},\n    {name: "red", label: "Red"},\n    ...\n  ],\n};\n...\n\nTemplate:\n...\n<label for="color">Circle color</label>\n{^{selectmenu color name="color"}}\n  {^{for colors}}\n    <option value="{{:name}}">{{:label}}</option>\n  {{/for}}\n{{/selectmenu}}\n...\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    color: "yellow",\n    colors: [\n      {name: "black", label: "Black"},\n      {name: "red", label: "Red"},\n      {name: "yellow", label: "Yellow"},\n      {name: "blue", label: "Blue"},\n      {name: "green", label: "Green"}\n    ],\n    radius: 100,\n    radii: [50, 100, 150, 200, 250]\n  };\n\npageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<div data-link="\r\n  css-background{:color}\r\n  css-width{:radius}\r\n  css-height{:radius}\r\n" class="circle"></div>\r\n\r\n<fieldset>\r\n<label for="color">Circle color</label>\r\n{^{selectmenu color name="color"}}\r\n  {^{for colors}}\r\n    <option value="{{:name}}">{{:label}}</option>\r\n  {{/for}}\r\n{{/selectmenu}}\r\n\r\n<label for="radius">Circle radius</label>\r\n{^{selectmenu radius name="radius"}}\r\n  {^{for radii}}\r\n    <option value="{{:}}">{{:}}px</option>\r\n  {{/for}}\r\n{{/selectmenu}}\r\n</fieldset>\r\n\r\n<div class="clear">\r\n  {^{:color}} {^{:radius}}px\r\n</div>\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"",text:'For a data-driven approach using element-based data-link syntax, the data-linked <select> will have two tag bindings – a {for} binding and a {selectmenu} binding:\n<select data-link="html{for colors tmpl=...} {selectmenu color}"></select>\n\nThis is shown in the following sample, which is functionally the same as the sample above, but uses only top-level data-linked elements, rather than a rendered template:\n'},{_type:"sample",text:'\n  fieldset {border:0; margin-left:300px;}\n  label {display:block; margin:20px 0 5px;}\n  select {width:200px;}\n  .circle {float:left; border-radius:50%; width:150px; height:150px;}\n  .clear {clear:both}\n\n\n\n  <option value="{{:}}">{{:}}px</option>\n\n\n\n  \n\n  \n  Circle color\n  \n\n  Circle radius\n  \n  \n\n  \n    {^{:color}} {^{:radius}}px\n  \n\nvar model = {\n  color: "yellow",\n  colors: [\n    {name: "black", label: "Black"},\n    {name: "red", label: "Red"},\n    {name: "yellow", label: "Yellow"},\n    {name: "blue", label: "Blue"},\n    {name: "green", label: "Green"}\n  ],\n  radius: 100,\n  radii: [50, 100, 150, 200, 250]\n};\n\n// Top-level data linking\n$.link(true, "#linked", model, {\n  // For the colorOption template we will pass in the template as\n  // helper, rather than using a template declared in a script element.\n  colorOptionTmpl:\n    $.templates(\'{{:label}}\')\n});\nTop-level elements:\n<div id="linked">\n  ...\n  <select data-link="html{for colors tmpl=~colorOptionTmpl} {selectmenu color}" ...></select>\n  ...\n\n\n'},{_type:"para",title:"",text:"Note that {{selectmenu}} is an alternative to data-linking directly to a <select> element. Using {{selectmenu}} brings the jQuery UI themable look and feel…\nBoth provide two-way binding to the data-linked expression such as color – as shown in the following example:\n"},{_type:"sample",text:'\n  fieldset {border:0; margin-left:300px;}\n  label {display:block; margin:20px 0 5px;}\n  select {width:200px;}\n  .circle {float:left; border-radius:50%; width:150px; height:150px;}\n  .clear {clear:both}\n\n\n\n\n<div data-link="\n  css-background{:color}\n  css-width{:radius}\n  css-height{:radius}\n" class="circle"></div>\n\n<fieldset>\n{^{selectmenu color}}\n  {^{for colors}}\n    <option value="{{:name}}">{{:label}}</option>\n  {{/for}}\n{{/selectmenu}}<br/><br/>\n\n<select data-link="{selectmenu color}">\n  {^{for colors}}\n    <option value="{{:name}}">{{:label}}</option>\n  {{/for}}\n</select><br/><br/>\n\n<select data-link="color">\n  {^{for colors}}\n    <option value="{{:name}}">{{:label}}</option>\n  {{/for}}\n</select><br/><br/>\n\n<select data-link="color" size="5">\n  {^{for colors}}\n    <option value="{{:name}}">{{:label}}</option>\n  {{/for}}\n</select>\n</fieldset>\n\n<div class="clear">\n  {^{:color}}\n</div>\n\n\n\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    color: "yellow",\n    colors: [\n      {name: "black", label: "Black"},\n      {name: "red", label: "Red"},\n      {name: "yellow", label: "Yellow"},\n      {name: "blue", label: "Blue"},\n      {name: "green", label: "Green"}\n    ]\n  };\n\npageTmpl.link("#page", model);\nAlternative drop-down styles:\n{^{selectmenu color}}\n  {^{for colors}}...{{/for}}\n{{/selectmenu}}\n\n<select data-link="{selectmenu color}">\n  {^{for colors}}...{{/for}}\n</select>\n\n<select data-link="color">\n  {^{for colors}}...{{/for}}\n</select>\n\n<select data-link="color" size="5">\n  {^{for colors}}...{{/for}}\n</select>\n\n\n'}]},"samples/tag-controls/jqui/autocomplete":{sections:[{_type:"para",title:"",text:"The {{autocomplete}} tag control – based on the jQuery UI autocomplete widget (api) – can be used with <input> or <textarea> elements, or with contenteditable elements.\nThe following sample shows each of these cases, using either tag syntax or element-based data-link syntax.\n"},{_type:"sample",url:"samples/tag-controls/jqui/autocomplete/variants",text:'Each variant has two-way data binding to the val property, and obtains the autocomplete suggestion list locally from a suggestionList helper property (assigned to the _source property, from the jQuery UI API).\nFor example:\nTag syntax:\n{^{autocomplete val _source=~suggestionList/}}\n\nTag syntax wrapping a <textarea> element:\n{^{autocomplete val _source=~suggestionList}}\n  <textarea ...></textarea>\n{{/autocomplete}}\n\nData-linked element syntax (textarea):\n<textarea ... data-link="{autocomplete val _source=~suggestionList}"></textarea>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  data = {\n    val: "",\n  };\n\npageTmpl.link("#page", data, {\n  suggestionList: [\n    "ActionScript",\n    "AppleScript",\n    "Asp",\n    "BASIC",\n    "C",\n    "C++",\n    "Clojure",\n    "COBOL",\n    "ColdFusion",\n    "Erlang",\n    "Fortran",\n    "Groovy",\n    "Haskell",\n    "Java",\n    "JavaScript",\n    "Lisp",\n    "Perl",\n    "PHP",\n    "Python",\n    "Ruby",\n    "Scala",\n    "Scheme"\n  ]\n});\n\n<style>\r\n  input {width: 200px;}\r\n  .box {border:solid 1px #a14503; height: 40px; width: 200px;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<em>Start typing (e.g. \'a\') to see autocomplete suggestions</em>\r\n\r\n<h4>Tag syntax:</h4>\r\n\r\n<pre>\r\n&lcub;^{autocomplete val _source=... /}&rcub;\r\n</pre>\r\n\r\n{^{autocomplete val _source=~suggestionList/}}\r\n\r\n<h4>Tag syntax, wrapping input element:</h4>\r\n\r\n<pre>\r\n&lcub;^{autocomplete val _source=... }&rcub;\r\n  &lt;input/&gt;\r\n&lcub;^{/autocomplete}&rcub;\r\n</pre>\r\n\r\n{^{autocomplete val _source=~suggestionList}}\r\n  <input/>\r\n{{/autocomplete}}\r\n\r\n<h4>Tag syntax, wrapping textarea element:</h4>\r\n\r\n<pre>\r\n&lcub;^{autocomplete val ...}&rcub;\r\n  &lt;textarea ... &gt;&lt;/textarea&gt;\r\n&lcub;^{/autocomplete}&rcub;\r\n</pre>\r\n\r\n{^{autocomplete val _source=~suggestionList}}\r\n  <textarea cols="40" rows="3"></textarea>\r\n{{/autocomplete}}\r\n\r\n<h4>Tag syntax, wrapping contenteditable div element:</h4>\r\n\r\n<pre>\r\n&lcub;^{autocomplete val ...}&rcub;\r\n  &lt;div contenteditable=true ... &gt;&lt;/div&gt;\r\n&lcub;^{/autocomplete}&rcub;\r\n</pre>\r\n\r\n{^{autocomplete val _source=~suggestionList}}\r\n  <div contenteditable="true" class="box"></div>\r\n{{/autocomplete}}\r\n\r\n<h4>Element-based data-link syntax (input)</h4>\r\n\r\n<pre>\r\n&lt;input data-link="{autocomplete val ...}"/&gt;\r\n</pre>\r\n\r\n<input data-link="{autocomplete val _source=~suggestionList}"/>\r\n\r\n<h4>Element-based data-link syntax (textarea)</h4>\r\n\r\n<pre>\r\n&lt;textarea ... data-link="{autocomplete val ...}"&gt;&lt;/textarea&gt;\r\n</pre>\r\n\r\n<textarea cols="40" rows="3" data-link="{autocomplete val _source=~suggestionList}"></textarea>\r\n\r\n<h4>Element-based data-link syntax (contenteditable div)</h4>\r\n\r\n<pre>\r\n&lt;div contenteditable="true" ... data-link="{autocomplete val ...}"&gt;&lt;/div&gt;\r\n</pre>\r\n\r\n<div contenteditable="true" class="box" data-link="{autocomplete val _source=~suggestionList}"></div>\r\n\r\n<h4>Regular input tag without autocomplete</h4>\r\n\r\n<pre>\r\n&lt;input data-link="val ..."/&gt;\r\n</pre>\r\n\r\n<input data-link="val" />\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/jqui/selectable":{sections:[{_type:"para",title:"",text:'The {{selectable}} tag control integrates the jQuery UI Selectable widget (api).\nWhen using tag syntax, the tag wraps directly the container element (which wraps the markup for the selectable elements):\n{^{selectable ...}}\n  <ol data-link="{selectable}">\n    <li>Jo</li>\n    <li>Pierre</li>\n    ...\n  </ol>\n{{/selectable}}\n\nThe tag can also be used wrapping the selectable elements directly, and with the elem=... property specifying a container element. (The tag will render the container element):\n{^{selectable ... elem="ol"}}\n  <li>Jo</li>\n  <li>Pierre</li>\n  ...\n{{/selectable}}\n\nAlternatively, the selectable tag binding can be used with a data-linked wrapper element:\n<ol data-link="{selectable ...}">\n  <li>Jo</li>\n  <li>Pierre</li>\n  ...\n</ol>\n\nThe following sample shows two selectables – one using tag syntax, and the other using element syntax, and is a declarative data-driven version of the jQuery UI Selectable – Display as grid demo.\n'},{_type:"sample",title:"Selectable &ndash; Display as grid",text:'Selectable – Display as grid\n\n  ol.grid {list-style-type: none; margin: 0 0 162px 0; padding: 0; width: 360px;}\n  .grid .ui-selecting {background: #FECA40;}\n  .grid .ui-selected {background: #F39814; color: white;}\n  .grid li {float: left; margin: 3px; padding: 1px; height: 50px; font-size: 18px;\n    line-height: 46px; cursor:pointer; width: 66px; text-align: center;\n    border: 1px solid #c5c5c5; background: #f6f6f6; color: #454545;}\n  h4 {clear:both}\n\n\n\n\n<h4>Tag syntax:</h4>\n\n<pre>\n&lcub;^{selectable ...}&rcub;...&lcub;^{/selectable}&rcub;\n</pre>\n\n{^{selectable class="grid" elem="ol"}}\n  <li>Jo</li>\n  <li>Pierre</li>\n  <li>Rudy</li>\n  <li>Mara</li>\n  <li>Mando</li>\n  <li>Ivor</li>\n  <li>Graca</li>\n  <li>Sabrine</li>\n{{/selectable}}\n\n<h4>Element-based data-link syntax:</h4>\n\n<pre>\n&lt;ol data-link="{selectable}">...&lt;/ol>\n</pre>\n\n<ol class="grid" data-link="{selectable}">\n  <li>Jo</li>\n  <li>Pierre</li>\n  <li>Rudy</li>\n  <li>Mara</li>\n  <li>Mando</li>\n  <li>Ivor</li>\n  <li>Graca</li>\n  <li>Sabrine</li>\n</ol>\n\n\n\nDrag (or ctrl-click) to select one or more elements:\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {};\n\npageTmpl.link("#page", model);\nTag syntax:\n{^{selectable class="grid" elem="ol"}}\n  <li>Jo</li>\n  <li>Pierre</li>\n  ...\n{{/selectable}}\n\nData-linked element syntax:\n<ol class="grid" data-link="{selectable}">\n  <li>Jo</li>\n  <li>Pierre</li>\n  ...\n</ol>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n'
},{_type:"para",title:"Initializing and data-linking the selection",text:'Initializing and data-linking the selection\nBy default the none of the elements are initially selected. By providing as argument an array of integers (the indices of the initially selected elements) the initial selection be specified.\nIn addition, the {{selectable}} tag control provides two-way binding, so the array will be observably updated whenever selection changes.\n{^{selectable selection}}...\n\nor\n<div data-link="{selectable selection}">...\n\nThis is illustrated in the following sample, which is the same as the sample above except that both selectable tag controls are data-linked to the same selectedPanel property. As a result, the two stay in sync: changing selection on one will trigger the corresponding change on the other.\n'},{_type:"sample",title:"Data-linking the selection",text:'Data-linking the selection\n\n\n\n  ol.grid {list-style-type: none; margin: 0 0 162px 0; padding: 0; width: 360px;}\n  .grid .ui-selecting {background: #FECA40;}\n  .grid .ui-selected {background: #F39814; color: white;}\n  .grid li {float: left; margin: 3px; padding: 1px; height: 50px; font-size: 18px;\n    line-height: 46px; cursor:pointer; width: 66px; text-align: center;\n    border: 1px solid #c5c5c5; background: #f6f6f6; color: #454545;}\n  h4 {clear:both}\n\n\n\n<b>Selected indices:</b> {^{for selected}}{{:}} {{/for}}\n\n<h4>Tag syntax:</h4>\n\n<pre>\n&lcub;^{selectable selected ...}&rcub;...&lcub;^{/selectable}&rcub;\n</pre>\n\n{^{selectable selected class="grid" elem="ol"}}\n  <li>Jo</li>\n  <li>Pierre</li>\n  <li>Rudy</li>\n  <li>Mara</li>\n  <li>Mando</li>\n  <li>Ivor</li>\n  <li>Graca</li>\n  <li>Sabrine</li>\n{{/selectable}}\n\n<h4>Element-based data-link syntax:</h4>\n\n<pre>\n&lt;ol data-link="{selectable selected ...}">...&lt;/ol>\n</pre>\n\n<ol class="grid" data-link="{selectable selected}">\n  <li>Jo</li>\n  <li>Pierre</li>\n  <li>Rudy</li>\n  <li>Mara</li>\n  <li>Mando</li>\n  <li>Ivor</li>\n  <li>Graca</li>\n  <li>Sabrine</li>\n</ol>\n\n\n\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {selected: [3, 6]};\n\npageTmpl.link("#page", model);\nTag syntax:\n{^{selectable selected}}\n  ...\n\nData-linked element syntax:\n<div data-link="{selectable selected}">\n  ...\n\nTracking the selection:\nSelected indices: {^{for selected}}{{:}} {{/for}}\n\nCode:\nvar model = {selected: [3, 6]};\npageTmpl.link("#page", model);\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n'
},{_type:"para",title:"Using {{selectable}} with a data-linked array",text:"Using {{selectable}} with a data-linked array\nA data-driven approach can be used, with the selectable elements rendered from a data array:\n{^{selectable ... elem='ol'}}\n  {^{for itemData}}\n    <li>{^{:title}}</li>\n  {{/for}}\n{{/selectable}}\n\n\n"},{_type:"para",title:"Sortable selectable elements with  a data-linked array",text:"Sortable selectable elements with  a data-linked array\nIf a {{selectable}} tag control with content coming from a data-driven array is also sortable, then sorting will sort the underlying data array – and raise corresponding observable events.\nThe following sample shows data-linking to the underlying array, with nested {{sortable}} and {{selectable}} tag control. Two styles of markup are shown, one with the tag syntax and the other with data-linked element syntax:\n"},{_type:"sample",title:"{{sortable}} and {{selectable}}",url:"samples/tag-controls/jqui/selectable/sortablearray",text:'{{sortable}} and {{selectable}}\nTag syntax:\n<table>\n  {^{sortable ... _handle=\'.sort\'}}\n    {^{selectable selectedItems _cancel="td:not(.sel)" _filter=".sel" elem="tbody"}}\n      {^{for people ...}}\n        <tr>\n          <td class="sel">Select</td>\n          <td class="sort">Sort</td>\n          ...\n        </tr>\n      {{/for}}\n    {{/selectable}}\n  {{/sortable}}\n</table>\n\nData-linked element syntax:\n<table>\n  <tbody data-link="\n    {for people ... tmpl=\'#itemMarkup\'}\n    {sortable ... _handle=\'.sort\'}\n    {selectable selectedItems _cancel=\'td:not(.sel)\' _filter=\'.sel\'}\n  "></tbody>\n</table>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar cnt = 5,\n  pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    selectedPeople: function() {\n      var person, itemIndex,\n        people = [];\n      for (var i = 0; i<this.selectedItems.length; i++) {\n        itemIndex = this.selectedItems[i];\n        person = this.people[itemIndex];\n        if (person) {\n          people.push({index: itemIndex, person: person});\n        }\n      }\n      return people;\n    },\n    insert: function() {\n      cnt++;\n      $.observable(this.people).insert({\n        name: "name" + cnt,\n        lastName: "lastName "  + cnt\n      });\n    },\n    remove: function(index) {\n      $.observable(this.people).remove(index);\n    },\n    people: [\n      {name: "Jo", lastName: "Johnson"},\n      {name: "Pierre", lastName: "Ponce"},\n      {name: "Radagu", lastName: "Regy"},\n      {name: "Mara", lastName: "May"},\n      {name: "Mando", lastName: "Mechy"}\n    ],\n    selectedItems: [1,3]\n  };\n\nmodel.selectedPeople.depends = ["people", "selectedItems"];\n\npageTmpl.link("#page", model);\n\n<style>\r\n  table {margin: 25px 7px;}\r\n  table, tr {border: 1px solid gray;}\r\n  .ui-selecting {background: #FECA40;}\r\n  .ui-selected {background: #F39814; color: white;}\r\n  td a {color: red; cursor:pointer; padding: 3px;}\r\n  td.sel, td.sort {width: 12px; border:1px solid #F39814; padding: 0 5px; cursor:pointer}\r\n  td.sort {cursor:ns-resize}\r\n  td.name {padding: 5px 20px; border:1px solid #AAA;}\r\n  .list {padding: 5px; border:1px solid #F39814; width: 300px; margin: 7px;}\r\n</style>\r\n\r\n<script id="itemMarkup" type="text/x-jsrender">\r\n  <tr>\r\n    <td class="sel">Select</td>\r\n    <td class="sort">Sort</td>\r\n    <td><input data-link="name"/></td>\r\n    <td><input data-link="lastName"/></td>\r\n    <td><a data-link="{on ~remove #index context=~root}">x</a></td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n<h4>Tag syntax:</h4>\r\n\r\n<pre>\r\n&lcub;^{sortable ...}} &lcub;^{selectable ...}&rcub; ...\r\n</pre>\r\n\r\n<table>\r\n  {^{sortable _axis=\'y\' _handle=\'.sort\'}}\r\n    {^{selectable selectedItems _cancel="td:not(.sel)" _filter=".sel" elem="tbody"}}\r\n      {^{for people ~remove=remove}}\r\n        <tr>\r\n          <td class="sel">Select</td>\r\n          <td class="sort">Sort</td>\r\n          <td><input data-link="name"/></td>\r\n          <td><input data-link="lastName"/></td>\r\n          <td><a data-link="{on ~remove #index context=~root}">x</a></td>\r\n        </tr>\r\n      {{/for}}\r\n    {{/selectable}}\r\n  {{/sortable}}\r\n</table>\r\n\r\n<h4>Element-based data-link syntax:</h4>\r\n\r\n<pre>\r\n&lt;tbody data-link="{for ...} {sortable ...} {selectable ...}"> ... &lt;/tbody>\r\n</pre>\r\n\r\n<table>\r\n  <tbody data-link="\r\n    {for people ~remove=remove tmpl=\'#itemMarkup\'}\r\n    {sortable _axis=\'y\' _handle=\'.sort\'}\r\n    {selectable selectedItems _cancel=\'td:not(.sel)\' _filter=\'.sel\'}\r\n  "></tbody>\r\n</table>\r\n\r\n<h3>Selected people</h3>\r\n\r\n{^{for selectedPeople()}}\r\n  <div class="list">\r\n    <div><b>Index:</b> {^{:index}}</div>\r\n    <div><b>First name:</b> {^{:person.name}}</div>\r\n    <div><b>Last name:</b> {^{:person.lastName}}</div>\r\n  </div>\r\n{{/for}}\r\n\r\n{^{on insert}}Add item{{/on}}\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Sortable selectable elements with  a data-linked array &ndash; top-level data-linking",text:"Sortable selectable elements with  a data-linked array – top-level data-linking\nFinally, here is the same sample as above, but achieved entirely through top-level data linking:\n"},{_type:"sample",title:"{{sortable}} and {{selectable}} &ndash; top-level",url:"samples/tag-controls/jqui/selectable/sortablearray-toplevel",text:'{{sortable}} and {{selectable}} – top-level\n<script id="itemMarkup" type="text/x-jsrender">\n  <tr>\n    <td class="sel">Select</td>\n    <td class="sort">Sort</td>\n    ...\n  </tr>\n</script>\n\nTop-level data-linked element:\n<tbody class="linkedUI" data-link="\n  {for people ... tmpl=\'#itemMarkup\'}\n  {sortable ...}\n  {selectable selectedItems ...}\n"></tbody>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar cnt = 5,\n  pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    selectedPeople: function() {\n      var person, itemIndex,\n        people = [];\n      for (var i = 0; i<this.selectedItems.length; i++) {\n        itemIndex = this.selectedItems[i];\n        person = this.people[itemIndex];\n        if (person) {\n          people.push({index: itemIndex, person: person});\n        }\n      }\n      return people;\n    },\n    insert: function() {\n      cnt++;\n      $.observable(this.people).insert({\n        name: "name" + cnt,\n        lastName: "lastName "  + cnt\n      });\n    },\n    remove: function(index) {\n      $.observable(this.people).remove(index);\n    },\n    people: [\n      {name: "Jo", lastName: "Johnson"},\n      {name: "Pierre", lastName: "Ponce"},\n      {name: "Radagu", lastName: "Regy"},\n      {name: "Mara", lastName: "May"},\n      {name: "Mando", lastName: "Mechy"}\n    ],\n    selectedItems: [1,3]\n  };\n\nmodel.selectedPeople.depends = ["people", "selectedItems"];\n\n$.link(true, ".linkedUI", model);\n\n<style>\r\n  table {margin: 25px 7px;}\r\n  table, tr {border: 1px solid gray;}\r\n  .ui-selecting {background: #FECA40;}\r\n  .ui-selected {background: #F39814; color: white;}\r\n  td a {color: red; cursor:pointer; padding: 3px;}\r\n  td.sel, td.sort {width: 12px; border:1px solid #F39814; padding: 0 5px; cursor:pointer}\r\n  td.sort {cursor:ns-resize}\r\n  td.name {padding: 5px 20px; border:1px solid #AAA;}\r\n  .list {padding: 5px; border:1px solid #F39814; width: 300px; margin: 7px;}\r\n</style>\r\n\r\n<script id="itemMarkup" type="text/x-jsrender">\r\n  <tr>\r\n    <td class="sel">Select</td>\r\n    <td class="sort">Sort</td>\r\n    <td><input data-link="name"/></td>\r\n    <td><input data-link="lastName"/></td>\r\n    <td><a data-link="{on ~remove #index context=~root}">x</a></td>\r\n  </tr>\r\n</script>\r\n\r\n<script id="peopleList" type="text/x-jsrender">\r\n  <div class="list">\r\n    <div><b>Index:</b> {^{:index}}</div>\r\n    <div><b>First name:</b> {^{:person.name}}</div>\r\n    <div><b>Last name:</b> {^{:person.lastName}}</div>\r\n  </div>\r\n</script>\r\n\r\n<table>\r\n  <tbody class="linkedUI" data-link="\r\n    {for people ~remove=remove tmpl=\'#itemMarkup\'}\r\n    {sortable _axis=\'y\' _handle=\'.sort\'}\r\n    {selectable selectedItems _cancel=\'td:not(.sel)\' _filter=\'.sel\'}\r\n  "></tbody>\r\n</table>\r\n\r\n<h3>Selected people</h3>\r\n\r\n<div class="linkedUI" data-link="{for selectedPeople() tmpl=\'#peopleList\'}"></div>\r\n\r\n<button class="linkedUI" data-link="{on insert}">Add item</button>\n'
},{_type:"para",title:"Advanced scenario: Data-linking directly to the {{selectable}} tag control properties",text:"Advanced scenario: Data-linking directly to the {{selectable}} tag control properties\nGenerally to track selection it is best to use the two-way data-linking on the argument. If you have two independent {{selectable}} tags, they can each bind to a different data or helper property.\nHowever it is possible to use {{selectable}} without argument (so without binding to model or helper properties), and instead to bind to the selected property of the tag instance  – which will update observable when the selection changes.\nHere is an advanced sample which does that:\n"},{_type:"sample",text:'\n\n\n  table {margin: 25px 7px; border-collapse:collapse}\n  table, td {border: 1px solid gray; padding: 8px; cursor:pointer}\n  .ui-selecting {background: #FECA40;}\n  .ui-selected {background: #F39814; color: white;}\n\n\n\n\n<h4>Selection</h4>\n\n{^{for #childTags(\'selectable\') lateRender=true}}\n  List {{:tagCtx.props.list}} [\n    {^{for selected}} {{:}} {{/for}} \n  ]<br/>\n{{/for}}\n\n<h4>List one</h4>\n\n<table>\n  {^{selectable _filter="tr" elem="tbody" list="one"}}\n    {^{for people}}\n      <tr>\n        <td>{{:name}}</td>\n      </tr>\n    {{/for}}\n  {{/selectable}}\n</table>\n\n<h4>List two</h4>\n\n<table>\n  {^{selectable _filter="tr" elem="tbody" list="two"}}\n    {^{for people}}\n      <tr>\n        <td>{{:name}}</td>\n      </tr>\n    {{/for}}\n  {{/selectable}}\n</table>\n\n\n\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    people: [\n      {name: "Jo"},\n      {name: "Pierre"},\n      {name: "Radagu"},\n      {name: "Mando"}\n    ]\n  };\n\npageTmpl.link("#page", model);\nBinding to the tag.selected property of any {{selectable}} tags in the page is achieved by first finding all sibling {{selectable}} tags, and iterating through them:\n{^{for #childTags(\'selectable\') lateRender=true}}\n\nHere lateRender=true ensures that the declarative childTags() call only happens after the initial data-linking has been completed.\nThen for each {{selectable}} tag, we iterate through the selected array property:\n{^{for selected}} {{:}} {{/for}}\n\nThe complete markup is:\n{^{for #childTags(\'selectable\') lateRender=true}}\n  List {{:tagCtx.props.list}} [\n    {^{for selected}} {{:}} {{/for}} \n  ]<br/>\n{{/for}}\n...\n{^{selectable ... list="One"}}\n...\n\n\n'}]},"samples/tag-controls/jqui/sortable":{sections:[{_type:"para",title:"",text:"The {{sortable}} tag control integrates the jQuery UI sortable widget (api).\nWhen using tag syntax, the tag wraps directly the container element:\n{^{sortable ...}}\n  <ul>\n    <li>Drag me</li>\n    ...\n  </ul>\n{{/sortable}}\n\nThe tag can also be used wrapping the sorted elements directly, and with the elem=... property specifying a container element. (The tag will render the container element):\n{^{sortable ... elem='ul'}}\n  <li>Drag me</li>\n  ...\n{{/sortable}}\n\nAlternatively, the sortable tag binding can be used with a data-linked wrapper element:\n<ul data-link=\"{sortable ...}\">\n  <li>Drag me</li>\n  ...\n</ul>\n\nThe following sample shows each of the above alternative syntax styles:\n"},{_type:"sample",title:"Alternate syntaxes",text:'Alternate syntaxes\n\n  .ui-sortable li {list-style-type:none;}\n  .ui-sortable li, .ui-state-highlight {\n   height:1.2em; margin:0 0 5px 0; padding:5px;\n   font-size:.9em; width: 200px;}\n\n\n\n\n{^{sortable\n  _placeholder=\'ui-state-highlight\'\n  _axis=\'y\'\n}}\n  <ul>\n    <li class="ui-state-default">Drag me</li>\n    <li class="ui-state-default">up or down</li>\n    <li class="ui-state-default">to sort...</li>\n  </ul>\n{{/sortable}}\n\n<hr/>\n\n{^{sortable\n  _placeholder=\'ui-state-highlight\'\n  _axis=\'y\'\n  elem=\'ul\'\n}}\n  <li class="ui-state-default">Drag me</li>\n  <li class="ui-state-default">up or down</li>\n  <li class="ui-state-default">to sort...</li>\n{{/sortable}}\n\n<hr/>\n\n<ul data-link="{sortable\n  _placeholder=\'ui-state-highlight\'\n  _axis=\'y\'\n}">\n  <li class="ui-state-default">Drag me</li>\n  <li class="ui-state-default">up or down</li>\n  <li class="ui-state-default">to sort...</li>\n</ul>\n\n\n\n\nvar model = {},\n  pageTmpl = $.templates("#pageTmpl");\n\npageTmpl.link("#page", model);\n\nAlternative syntaxes with {{sortable}} or data-link="{sortable}".\n\n'},{_type:"para",title:"Using {{sortable}} with a data-linked array",text:"Using {{sortable}} with a data-linked array\nA data-driven approach can be used, with the sorted elements rendered from a data array:\n{^{sortable ... elem='ul'}}\n  {^{for items}}\n    <li>{{:name}}</li>\n  {{/for}}\n{{/sortable}}\n\nor\n<ul data-link=\"{sortable ...} {for items tmpl=...}\"/>\n\n"},{_type:"para",title:"Triggering observable array-change events on the underlying data array, with {{sortable}}",text:"Triggering observable array-change events on the underlying data array, with {{sortable}}\nWhen {{sortable}} wraps a data-linked {^{for}}array of sorted items, the tag detects the {^{for}} binding and raises observable array-change (move) events, whenever items are dragged to a new position.\nThis is shown in the following sample, where the two {{sortable}} collections remain in sync:\n"},{_type:"sample",title:"{{sortable}} with an 'items' array, triggering array-change events",text:'{{sortable}} with an \'items\' array, triggering array-change events\n\n  .ui-sortable li {list-style-type:none;}\n  .ui-sortable li, .ui-state-highlight,\n  div.ui-state-default {height:1.2em;\n  margin:0 0 5px 0; padding:5px;\n  font-size:.9em; width: 200px;}\n\n\n\n  <li class="ui-state-default">{{:name}}</li>\n\n\n\n\n{^{sortable\n  _placeholder=\'ui-state-highlight\'\n  _axis=\'y\'\n  elem=\'ul\'\n}}\n  {^{for items}}\n    <li class="ui-state-default">{{:name}}</li>\n  {{/for}}\n{{/sortable}}\n\n<hr/>\n\n<ul data-link="{sortable\n  _placeholder=\'ui-state-highlight\'\n  _axis=\'y\'\n} {for items tmpl=\'#liTmpl\'}"></ul>\n\n<hr/>\n\n<h4>Data:</h4>\n{^{for items}}\n  <div class="ui-state-default">{{:name}}</div>\n{{/for}}\n\n\n\n\nvar model = {\n  items: [{name: "Drag me"}, {name: "up or down"}, {name: "to sort..."}] \n},\n  pageTmpl = $.templates("#pageTmpl");\n\npageTmpl.link("#page", model);\n\n{^{sortable ...}}\n  {^{for items}}\n    <li>...</li>\n  {{/for}}\n{{/sortable}}\n\n\n'},{_type:"para",title:"",text:"You can opt out of triggering array-change events, while still using a data-driven approach for rendering the sorted elements from a data array, by setting the _bindArray option to false:\n"},{_type:"sample",title:"{{sortable}} with an 'items' array &ndash; without array-change events",text:'{{sortable}} with an \'items\' array – without array-change events\n\n  .ui-sortable li {list-style-type:none;}\n  .ui-sortable li, .ui-state-highlight, div.ui-state-default {height:1.2em;\n   margin:0 0 5px 0; padding:5px; font-size:.9em; width: 200px;}\n\n\n\n  <li class="ui-state-default">{{:name}}</li>\n\n\n\n\n{^{sortable\n  _bindArray=false\n  _placeholder=\'ui-state-highlight\'\n  _axis=\'y\'\n  elem=\'ul\'\n}}\n  {^{for items}}\n    <li class="ui-state-default">{{:name}}</li>\n  {{/for}}\n{{/sortable}}\n\n<hr/>\n\n<ul data-link="{sortable\n  _bindArray=false\n  _placeholder=\'ui-state-highlight\'\n  _axis=\'y\'\n} {for items tmpl=\'#liTmpl\'}"></ul>\n\n<hr/>\n\n<h4>Data:</h4>\n{^{for items}}<div class="ui-state-default">{{:name}}</div>{{/for}}\n\n\n\n\nvar model = {\n  items: [{name: "Drag me"}, {name: "up or down"}, {name: "to sort..."}] \n},\n  pageTmpl = $.templates("#pageTmpl");\n\npageTmpl.link("#page", model);\n\n{^{sortable _bindArray=false ...}}\n  {^{for items}}\n    <li>...</li>\n  {{/for}}\n{{/sortable}}\n\n\n'},{_type:"para",title:"",text:'The following sample shows many variants of a data-driven {{sortable}} list.\nIt shows full editing of the items array. It also includes top-level data-linking using the data-link="{sortable}" binding.\n'},{_type:"sample",title:"{{sortable}} variants",url:"samples/tag-controls/jqui/sortable/variants",text:'{{sortable}} variants\nMultiple variants of data-driven editable {{sortable}} lists.\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar model = {\n    items: [\n      { name: \'Drag me\' },\n      { name: \'up or down\' },\n      { name: \'to sort...\' }\n    ]\n  },\n\n  pageTmpl = $.templates("#pageTmpl"),\n  itemTmpl = $.templates(\'#item-template\'),\n  editTmpl = $.templates(\'#edit-template\'),\n  emptyListTmpl = $.templates(\'#empty-list-template\'),\n\n  helpers = {\n    edit: function(view) {\n      // Can also use var view = eventArgs.view;\n      view.tmpl = editTmpl;\n      view.refresh();\n    },\n    save: function(view) {\n      view.tmpl = itemTmpl;\n      view.refresh();\n      console.log("save");\n    },\n    remove: function(index) {\n      $.observable(model.items).remove(index);\n    },\n    itemTmpl: itemTmpl,\n    emptyListTmpl: emptyListTmpl\n  };\n\npageTmpl.link("#page", model, helpers);\n\n$.link(true, ".linkedUl", model, helpers)\n$.link(true, "#add", {\n  add: function() {\n    $.observable(model.items).insert({name: "new"});\n  }\n})\n\n$(".sortable").sortable({\n  placeholder: "ui-state-highlight",\n  start: function(event, ui) {\n    console.log("start");\n  },\n  stop: function(event, ui) {\n    console.log("stop");\n  }\n})\n\n<script id="pageTmpl" type="text/x-jsrender">\r\nUsing data-linked sortable and for tags\r\n<ul data-link="\r\n  {sortable _placeholder=\'ui-state-highlight\'}\r\n  {for items tmpl=~itemTmpl}{else tmpl=~emptyListTmpl}\r\n"></ul>\r\n\r\nUsing data-linked sortable with inline for tag\r\n<ul data-link="{sortable _placeholder=\'ui-state-highlight\'}">\r\n  {^{for items}}\r\n    <li class="ui-state-default">\r\n      <button data-link="{on ~edit #view}">Edit</button>\r\n      <a data-link="{on ~remove #index}">x</a>\r\n      <span data-link="name"></span>\r\n      (Index: {^{:#index}})\r\n    </li>\r\n  {{else tmpl=~emptyListTmpl}}{{/for}}\r\n</ul>\r\n\r\nUsing code with data-linked for tag\r\n<ul class="sortable" data-link="\r\n  {for items tmpl=~itemTmpl}\r\n  {else tmpl=~emptyListTmpl}\r\n"></ul>\r\n\r\nUsing code with for tag\r\n<ul class="sortable">\r\n  {^{for items tmpl=~itemTmpl}}\r\n  {{else tmpl=~emptyListTmpl}}\r\n  {{/for}}\r\n</ul>\r\n\r\nUsing sortable tag with for tag and element wrapper\r\n{^{sortable _placeholder=\'ui-state-highlight\'}}\r\n  <ul>\r\n    {^{for items tmpl=~itemTmpl}}\r\n    {{else tmpl=~emptyListTmpl}}\r\n    {{/for}}\r\n  </ul>\r\n{{/sortable}}\r\n\r\nUsing sortable tag with for tag (element type specified)\r\n{^{sortable _placeholder=\'ui-state-highlight\' elem=\'ul\'}}\r\n  {^{for items tmpl=~itemTmpl}}\r\n  {{else tmpl=~emptyListTmpl}}\r\n  {{/for}}\r\n{{/sortable}}\r\n\r\n</script>\r\n\r\n<script id="item-template" type="text/x-jsrender">\r\n  <li class="ui-state-default">\r\n    <button data-link="{on ~edit #view}">Edit</button>\r\n    <a data-link="{on ~remove #index}">x</a>\r\n    <span data-link="name"></span>\r\n    (Index: {^{:#index}})\r\n  </li>\r\n</script>\r\n\r\n<script id="edit-template" type="text/x-jsrender">\r\n  <li class="ui-state-default">\r\n    <button data-link="{on ~save #view}">OK</button>\r\n    <input type="text" data-link="{:name:} {on \'blur\' ~save #view}" />\r\n  </li>\r\n</script>\r\n\r\n<script id="empty-list-template" type="text/x-jsrender">\r\n  <li class="ui-state-default">No items left</li>\r\n</script>\r\n\r\n<button id="add" data-link="{on add}">Add</button><br/><br/>\r\n\r\nCode on top-level linked data-linked for\r\n<ul class="linkedUl sortable" data-link="\r\n  {for items tmpl=~itemTmpl}\r\n  {else tmpl=~emptyListTmpl}\r\n"></ul>\r\n\r\nTop-level linked data-linked sortable and for\r\n<ul class="linkedUl" data-link="\r\n  {for items tmpl=~itemTmpl}{else tmpl=~emptyListTmpl}\r\n  {sortable _placeholder=\'ui-state-highlight\'}\r\n"></ul>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/jqui/resizable":{sections:[{_type:"para",title:"",text:"The following sample uses the {{resizable}} tag control – based on the jQuery UI resizable widget (api).\nThe sample is a declarative data-driven version of the jQuery UI Resizable – maximum / minimum size demo.\nThe width and height are initialized by setting the width and height properties of the tag control.\n"},{_type:"sample",text:'\n  .resize {border: 1px solid #ddd; padding: 10px; margin: 25px 0;}\n  .resize h3 {text-align: center; margin: -10px -10px 10px -10px;\n     border: 1px solid #ddd; background: #e9e9e9; color: #333;}\n\n\n\n<h4>Tag syntax</h4>\n\n<pre>&lcub;^{resizable .../}&rcub;</pre>\n\n{^{resizable width=187 height=70\n  _minWidth=136 _minHeight=40\n  _maxWidth=250 _maxHeight=100\n  class="resize"\n}}\n  <h3>Resize this</h3>\n  <div>Some initial content</div>\n{{/resizable}}\n\n<h4>Element-based data-link syntax:</h4>\n\n<pre>\n&lt;div data-link="{resizable ...}" /&gt;\n</pre>\n\n<div class="resize" data-link="{resizable\n   width=187 height=70\n  _minWidth=136 _minHeight=40\n  _maxWidth=250 _maxHeight=100\n}">\n  <h3>Resize this too</h3>\n  <div>Some more content</div>\n</div>\n\n\n\nvar pageTmpl = $.templates("#pageTmpl");\n\npageTmpl.link("#page");\nTag syntax:\n{^{resizable width=187 height=70 _minWidth=136 ...}}\n  <h3>Resize this</h3>\n  <div>Some initial content</div>\n{{/resizable}}\n\nData-linked element syntax:\n<div data-link="{resizable width=187 height=70 _minWidth=136 ...}">\n  <h3>Resize this too</h3>\n  <div>Some more content</div>\n</div>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n'
},{_type:"para",title:"Two-way data-binding to width and height",text:"Two-way data-binding to width and height\nThe JsViews {{resizable}} tag control provides two-way data-binding on the width and height properties. This permits many powerful scenarios, illustrated by the following examples.\nThe next sample data-links the width and height of the resizable element to underlying data properties w1 and h1.\nNeighboring layout elements also have width or height data-linked to the same data, so resizing the target element drives dynamic rendering of the surrounding layout.\nIn addition, the w1 and h1 data values are data-linked to {{slider}} and {{spinner}} controls.\n"},{_type:"sample",url:"samples/tag-controls/jqui/resizable/grid",text:'...\n<div data-link="css-height{:100-h1/2}" ... >top</div>\n<span data-link="css-width{:120-w1/2} css-height{:h1}" ... >left</span>\n<span data-link="{resizable width=w1 height=h1 _minWidth=46 ...}" ... >Resize!</span>\n<span data-link="css-width{:120-w1/2} css-height{:h1}" ... >right</span>\n<div data-link="css-height{:100-h1/2}" ... >bottom</div>\n...\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    w1: 116,\n    h1: 90\n  },\n  helpers = {\n    toNum: function(val) {\n      // ConvertBack: If spinner text set to non-numeric value, return instead the minimum value\n      return +val || this.widget.options.min;\n    },\n    rnd: function(val) {\n      // Round to nearest integer\n      return Math.round(val);\n    }\n  };\n\npageTmpl.link("#page", model, helpers);\n\n<style>\r\n  .slider {width: 358px; margin-bottom: 15px;}\r\n  .sliderpanel {position: absolute; left: 420px; top: 60px;}\r\n  span.box {display: inline-block;}\r\n  .box {padding: 14px;}\r\n  .box.l {border-left: 1px solid #bbb;}\r\n  .box.t {border-top: 1px solid #bbb; padding: 14px;}\r\n  .outer {border: 1px solid #bbb; display: inline-block}\r\n  span.resize {color: #ff6a00; font-style: italic;\r\n    border: 1px solid #ff6a00 !important; margin: -1px;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<h4>Grid with spans</h4>\r\n\r\n<div class="outer"><div class="box" data-link="css-height{:100-h1/2}">\r\ntop</div><span class="box t" \r\n  data-link="css-width{:120-w1/2} css-height{:h1}">left\r\n</span><span class="box l t resize"\r\n  data-link="{resizable width=w1 height=h1 _minWidth=46 _minHeight=17 _maxWidth=188 _maxHeight=162}">\r\nResize!</span><span class="box l t"\r\n  data-link="css-width{:120-w1/2} css-height{:h1}">\r\nright</span><div class="box t" data-link="css-height{:100-h1/2}">bottom</div></div>\r\n\r\n<div class="sliderpanel">\r\n<h4>Width:</h4>\r\n{^{slider w1 _range="min" _min=46 _max=188 class="slider"/}}\r\n{^{spinner w1 _min=46 _max=188 width=90 convert=~rnd convertBack=~toNum class="spinner"/}}\r\n<h4>Height:</h4>\r\n{^{slider h1 _range="min" _min=17 _max=162 class="slider"/}}\r\n{^{spinner h1 _min=17 _max=162 width=90 convert=~rnd convertBack=~toNum class="spinner"/}}<br/>\r\n</div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Using converters with multi-parameter two-way data-linking",text:"Using converters with multi-parameter two-way data-linking\nThe following sample is similar, but adds a second layout using <table> elements, rather than <div>s and <span>s.\nThe second layout is reduced in scale, using converter functions to multiply heights and widths by a scaling factor. The two {{resizable}} tags (one in each layout) are linked to the same underlying data, w1 and  h1, but the second one used converters (convert and convertBack) to apply the appropriate scaling factor in both directions.\nNote the since the {{resizable}} tag control has two data-linked properties, callback functions should have a signature taking two parameters, and returning an array of two converted values.\n"},{_type:"sample",url:"samples/tag-controls/jqui/resizable/grid2",text:'Data-linking with converters:\n...\n<td data-link="{resizable width=w1 height=h1 convert=\'reduce\' convertBack=\'increase\' _minWidth=53*scale ..." ...>\n...\n\nConverters for two-parameter binding:\n$.views.converters({\n  reduce: function(w, h) {\n    return [scale*w, scale*h];\n  },\n  increase: function(w, h) {\n    return [w/scale, h/scale];\n  }\n});\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  scale = 0.75,\n  model = {\n    scale: scale,\n    w1: 86,\n    h1: 56\n  };\n\n$.views.converters({\n  toNum: function(val) {\n    // ConvertBack: If spinner text set to non-numeric value, return instead the minimum value\n    return +val || this.widget.options.min;\n  },\n  rnd: function(val) {\n    // Round to nearest integer\n    return Math.round(val);\n  },\n  scale: function(val) {\n    return scale*val;\n  },\n  reduce: function(w, h) {\n    return [scale*w, scale*h];\n  },\n  increase: function(w, h) {\n    return [w/scale, h/scale];\n  }\n});\n\npageTmpl.link("#page", model);\n\n<style>\r\n  .slider {width: 358px; margin-bottom: 15px;}\r\n  .sliderpanel {position: absolute; left: 420px; top: 70px;}\r\n  span.resize {color: #ff6a00; font-style: italic; border: 1px solid #ff6a00; margin: -1px;}\r\n  table.outer td.resize {color: #ff6a00; font-style: italic; border: 1px solid #ff6a00; margin: -1px;}\r\n  span.box {display: inline-block;}\r\n  .box {padding: 14px;}\r\n  .box.l {border-left: 1px solid #bbb;}\r\n  .box.t {border-top: 1px solid #bbb; padding: 14px;}\r\n  div.outer {border: 1px solid #bbb; display: inline-block;}\r\n  table.outer {border-collapse: collapse; border: none; margin-top: 10px;}\r\n  table.outer td {border: 1px solid #bbb; padding: 0;}\r\n  .bottom {position: absolute; top: 354px;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<h4>Grid with spans</h4>\r\n\r\n<div class="outer"><div><span class="box resize" data-link="{resizable width=w1 height=h1 _minWidth=53 _minHeight=19 _maxWidth=118 _maxHeight=93}">Resize!\r\n</span><span class="box l" data-link="css-width{:280-2*w1} css-height{:h1}">center\r\n</span><span class="box l" data-link="css-width{:w1} css-height{:h1}">right\r\n</span></div><span class="box t" data-link="css-width{:w1} css-height{:200-2*h1}">left\r\n</span><span class="box l t" data-link="css-width{:280-2*w1} css-height{:200-2*h1}">center\r\n</span><span class="box l t" data-link="css-width{:w1} css-height{:200-2*h1}">right\r\n</span><div><span class="box t" data-link="css-width{:w1} css-height{:h1}">left\r\n</span><span class="box l t" data-link="css-width{:280-2*w1} css-height{:h1}">center\r\n</span><span class="box l t" data-link="css-width{:w1} css-height{:h1}">right\r\n</span></div></div><br/>\r\n\r\n<div class="bottom">\r\n<h4>Grid with table (reduced scale)</h4>\r\n\r\n<table class="outer"><tbody>\r\n  <tr>\r\n  <td class="resize" data-link="{resizable width=w1 height=h1 convert=\'reduce\' convertBack=\'increase\'\r\n    _minWidth=53*scale _minHeight=19*scale _maxWidth=118*scale _maxHeight=93*scale}"></td><td data-link="css-width{scale:280-2*w1}"></td><td data-link="css-width{scale:w1}"></td></tr>\r\n  <tr>\r\n  <td data-link="css-height{scale:200-2*h1}"></td><td></td><td></td></tr>\r\n  <tr>\r\n  <td data-link="css-height{scale:h1}"></td><td></td><td></td></tr>\r\n</tbody></table>\r\n</div>\r\n\r\n<div class="sliderpanel">\r\n<h4>Width:</h4>\r\n{^{slider w1 _range="min" _min=53 _max=118 class="slider"/}}\r\n{^{spinner w1 _min=53 _max=118 width=90 convert="rnd" convertBack="toNum" class="spinner"/}}\r\n<h4>Height:</h4>\r\n{^{slider h1 _range="min" _min=19 _max=90 class="slider"/}}\r\n{^{spinner h1 _min=19 _max=90 width=90 convert="rnd" convertBack="toNum" class="spinner"/}}\r\n</div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Converters as parameter transforms",text:"Converters as parameter transforms\nWith any tag that provides ‘multi-parameter’ two-way data-linking (such as this {{resizable}} tag) it is quite possible to use converters which ‘mix and match’ incoming parameters – so an outgoing parameter is any kind of transform combining values from different incoming parameters.\nA very simple example would be the following converter, which maps width to height and height to width:\nfunction(w, h) {\n return [h, w];\n}\n\n"},{_type:"para",title:"Tag contextual parameters: ~width, ~height",text:'Tag contextual parameters: ~width, ~height\nThe {{resizable}} tag control provides two tag contextual parameters – which give access to the values of the width and height from anywhere within the {{resizable}} tag’s content.\nFor example you can write:\n{^{resizable}}\n  {^{int:~width}}\n  {^{int:~height}}\n{{/resizable}}\n\nor you can even use two-way data-binding to the tag contextual parameters as in:\n{^{resizable}}\n  <input data-link="~height" />\n  {^{slider ~width ... /}}\n{{/resizable}}\n\nIf the {^{resizable}} tag uses converters, then the tag contextual parameters will correspond to the values after conversion (i.e. the actual width and height of the {^{resizable}} control.\nThis is illustrated by the next sample, which adds display of ~width and ~height to the previous sample.\n'},{_type:"sample",url:"samples/tag-controls/jqui/resizable/grid3",text:'{^{resizable width=w1 height=h1 convert=\'reduce\' convertBack=\'increase\' ...}}\n  {^{int:~width}} {^{int:~height}}\n{{/resizable}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  scale = 0.75,\n  model = {\n    scale: scale,\n    w1: 86,\n    h1: 56\n  };\n\n$.views.converters({\n  toNum: function(val) {\n    // ConvertBack: If spinner text set to non-numeric value, return instead the minimum value\n    return +val || this.widget.options.min;\n  },\n  rnd: function(val) {\n    // Round to nearest integer\n    return Math.round(val);\n  },\n  scale: function(val) {\n    return scale*val;\n  },\n  reduce: function(w, h) {\n    return [scale*w, scale*h];\n  },\n  increase: function(w, h) {\n    return [w/scale, h/scale];\n  },\n  int: function(val){\n    return val | 0; // Truncate float to int\n  }\n});\n\npageTmpl.link("#page", model);\n\n<style>\r\n  .slider {width: 358px; margin-bottom: 15px;}\r\n  .sliderpanel {position: absolute; left: 420px; top: 70px;}\r\n  span.resize {color: #ff6a00; font-style: italic; border: 1px solid #ff6a00; margin: -1px;}\r\n  table.outer td.resize {color: #ff6a00; font-style: italic; border: 1px solid #ff6a00; margin: -1px;}\r\n  span.box {display: inline-block;}\r\n  .box {padding: 14px;}\r\n  .box.l {border-left: 1px solid #bbb;}\r\n  .box.t {border-top: 1px solid #bbb; padding: 14px;}\r\n  div.outer {border: 1px solid #bbb; display: inline-block;}\r\n  table.outer {border-collapse: collapse; border: none; margin-top: 10px;}\r\n  table.outer td {border: 1px solid #bbb; padding-left: 4px;}\r\n  .bottom {position: absolute; top: 354px;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\n<h4>Grid with spans</h4>\r\n\r\n<div class="outer"><div>{^{resizable width=w1 height=h1 _minWidth=53 _minHeight=19\r\n  _maxWidth=118 _maxHeight=93 elem="span" class="box resize"\r\n\t}}{^{int:~width}}&nbsp;{^{int:~height}}{{/resizable}}<span\r\n  class="box l" data-link="css-width{:280-2*w1} css-height{:h1}">center\r\n</span><span class="box l" data-link="css-width{:w1} css-height{:h1}">right\r\n</span></div><span class="box t" data-link="css-width{:w1} css-height{:200-2*h1}">left\r\n</span><span class="box l t" data-link="css-width{:280-2*w1} css-height{:200-2*h1}">center\r\n</span><span class="box l t" data-link="css-width{:w1} css-height{:200-2*h1}">right\r\n</span><div><span class="box t" data-link="css-width{:w1} css-height{:h1}">left\r\n</span><span class="box l t" data-link="css-width{:280-2*w1} css-height{:h1}">center\r\n</span><span class="box l t" data-link="css-width{:w1} css-height{:h1}">right\r\n</span></div></div><br/>\r\n\r\n<div class="bottom">\r\n<h4>Grid with table (reduced scale)</h4>\r\n\r\n<table class="outer"><tbody>\r\n  <tr>\r\n  {^{resizable width=w1 height=h1 convert=\'reduce\' convertBack=\'increase\' _minWidth=53*scale\r\n  _minHeight=19*scale _maxWidth=118*scale _maxHeight=93*scale elem="td" class="resize"\r\n  }}{^{int:~width}}&nbsp;{^{int:~height}}{{/resizable}}\r\n  <td data-link="css-width{scale:280-2*w1}"></td><td data-link="css-width{scale:w1}"></td></tr>\r\n  <tr>\r\n  <td data-link="css-height{scale:200-2*h1}"></td><td></td><td></td></tr>\r\n  <tr>\r\n  <td data-link="css-height{scale:h1}"></td><td></td><td></td></tr>\r\n</tbody></table>\r\n</div>\r\n\r\n<div class="sliderpanel">\r\n<h4>Width:</h4>\r\n{^{slider w1 _range="min" _min=53 _max=118 class="slider"/}}\r\n{^{spinner w1 _min=53 _max=118 width=90 convert="rnd" convertBack="toNum" class="spinner"/}}\r\n<h4>Height:</h4>\r\n{^{slider h1 _range="min" _min=19 _max=90 class="slider"/}}\r\n{^{spinner h1 _min=19 _max=90 width=90 convert="rnd" convertBack="toNum" class="spinner"/}}\r\n</div>\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]},"samples/tag-controls/jqui/spinner":{sections:[{_type:"para",title:"",text:"The {{spinner}} tag integrates the jQuery UI spinner widget (api).\nThis allows data-linking directly to widget properties, as well as using generic tag functionality such as convert and convertBack.\nIn addition, validation support is obtained, simply by wrapping a {{spinner}} tag with a {{validate}}.\n"},{_type:"links",title:"",text:""}]},"samples/tag-controls/jqui/datepicker/formats":{sections:[{_type:"para",title:"Display format",text:'Display format\nThe {{datepicker}} tag control lets you specify the date format displayed in the textbox (when used with an <input>, rather than as inline datepicker with a <div>) – by setting the dateFormat property, using jQuery UI datepicker date formats.\nFor example:\n{^{datepicker date dateFormat="DD MM d, yy"/}}\n\nwill show the date in the format ‘Monday September 22, 2017’.\n(Note: you can also, equivalently, use _dateFormat, since dateFormat is a widget option.)\nIf the dateFormat is not specified, then the current default date format of the datepicker widget, will be used (as returned by $(element).datepicker("option", "dateFormat")).\nA different default date can be set using the setDefaults API: $.datepicker.setDefaults("dateFormat", ...)\n'},{_type:"para",title:"Data format",text:'Data format\nThe underlying data format used by {{datepicker}} will by default be a string value with the same format as the display format. So setting a different value or the dateFormat property (dateFormat=...) will also change the persistence/serialization format of the underlying data.\nHowever you can specify a different data format by setting the dataFormat property.\nFor example:\n{^{datepicker date dataFormat="mm/dd/yy" dateFormat="DD MM d, yy"/}}\n\nwill show the date in the format ‘Monday September 22, 2017’, but the underlying data-bound date will have the value "09/22/2017".\n'},{_type:"para",title:"Using the JavaScript Date() type for the underlying data-linked data ",text:'Using the JavaScript Date() type for the underlying data-linked data \nIf dataFormat is set to false (or null or ""), then {{datepicker}} will use JavaScript Date() objects as the underlying date type:\n{^{datepicker date dataFormat=false dateFormat="D M d yy"/}}\n\n'},{_type:"para",title:"Using a number (number of ticks - JavaScript Date timestamp) for the underlying data-linked data ",text:'Using a number (number of ticks - JavaScript Date timestamp) for the underlying data-linked data \nIf dataFormat is set to 0, then {{datepicker}} will use the timestamp of the JavaScript Date object (milliseconds since Jan 01 1970) as the underlying date type:\n{^{datepicker date dataFormat=0 dateFormat="D M d yy"/}}\n\nThe above alternative dataFormat options are shown in the following example:\n'},{_type:"sample",title:"Alternative data formats",url:"samples/tag-controls/jqui/datepicker/date-formats/basic",text:'Alternative data formats\nDefault “date string” format:\n{^{datepicker dateString /}}\n\nBinding to a chosen “date string” format:\n{^{datepicker dateString2 dateFormat="mm-dd-yy" /}}\n{^{datepicker dateString2 dataFormat="mm-dd-yy" dateFormat="DD MM d, yy" /}}\n\nBinding to Date object:\n{^{datepicker date dataFormat=false /}}\n{^{datepicker date dataFormat=\'\' dateFormat="DD MM d, yy" /}}\n\nBinding to a Date number\n{^{datepicker dateNumber dataFormat=0 /}}\n{^{datepicker dateNumber dataFormat=0 dateFormat="DD MM d, yy" /}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n$.datepicker.setDefaults("dateFormat", "mm/dd/yy"); // Set default date format for jQuery UI Datepicker\n\nvar pageTmpl = $.templates("#pageTmpl"),\n\n  model = {\n    date: new Date(),\n    dateNumber: +new Date(),\n    dateString: $.datepicker.formatDate("mm/dd/yy", new Date()),\n    dateString2: $.datepicker.formatDate("mm-dd-yy", new Date())\n  };\n\npageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Default "date string" format</h4>\r\n  <pre>Default format "mm/dd/yy" ($.datepicker.setDefaults("dateFormat", ...)</pre>\r\n  <p>\r\n    Underlying data (string):\r\n    <em>{^{:dateString}}</em>\r\n  </p>\r\n  <p>\r\n    {^{datepicker dateString /}}\r\n  </p>\r\n\r\n  <h4>Using a jQuery UI date patterns to bind to a chosen "date string" format</h4>\r\n  <pre>dataFormat="mm-dd-yy"</pre>\r\n  <p>\r\n    Underlying data (string):\r\n    <em>{^{:dateString2}}</em>\r\n  </p>\r\n  <p>\r\n    {^{datepicker dateString2 dateFormat="mm-dd-yy" /}}\r\n    {^{datepicker dateString2 dataFormat="mm-dd-yy" dateFormat="DD MM d, yy" /}}\r\n  </p>\r\n\r\n  <h4>Binding to Date object</h4>\r\n  <pre>dataFormat=false</pre>\r\n  <p>\r\n    Underlying data (date):\r\n    <em>{^{:date}}</em>\r\n  </p>\r\n  <p>\r\n    {^{datepicker date dataFormat=false /}}\r\n    {^{datepicker date dataFormat=\'\' dateFormat="DD MM d, yy" /}}\r\n  </p>\r\n\r\n  <h4>Binding to a Date number</h4>\r\n  <pre>dataFormat=0</pre>\r\n  <p>\r\n    Underlying data (number):\r\n    <em>{^{:dateNumber}}</em>\r\n  </p>\r\n  <p>\r\n    {^{datepicker dateNumber dataFormat=0 /}}\r\n    {^{datepicker dateNumber dataFormat=0 dateFormat="DD MM d, yy" /}}\r\n  </p>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Using a data formatter to bind to a custom underlying data format",text:'Using a data formatter to bind to a custom underlying data format\nAny underlying data format can be used (for example a string format such as the WCF Date serialization) by providing a corresponding “data formatter” (an object with a parse() method and a format() method) – and setting the dataFormat to that formatter:\nvar wcfDateFormatter = {\n  parse: function(wcfString) {\n    // Use moment.js to parse WCF date string\n    return moment(wcfString, "/\\\\D\\\\at\\\\e(xZZ)/").toDate();\n  },\n  format: function(date) {\n    // Use moment.js to format WCF date string\n    return moment(date).format("/\\\\D\\\\at\\\\e(xZZ)/");\n  }\n};\n\n// Provide wcfDateFormatter as a helper:\n$.views.helpers("wcfDate", wcfDateFormatter);\n\nUsage:\n{^{datepicker wcfDateString dataFormat=~wcfDate /}}\n\nNote that the this pointer within parse or format is the datepicker tag instance, so it can be used to access tag properties etc. (e.g. this.tagCtx.props.someprop or this.widget.options.someoption).\n'},{_type:"para",title:"Custom datepicker tags",text:'Custom datepicker tags\nYou can create your own flavor of datepicker which defaults to chosen dateFormat and dataFormat (for display format and underlying data format):\n$.views.tags({\n  myDatepicker: {\n    baseTag: "datepicker",\n    dataFormat: false, // Any falsy value\n    dateFormat: "DD MM d, yy"\n  },\n  myWcfDatepicker: {\n    baseTag: "datepicker",\n    dataFormat: wcfDateFormatter,\n    dateFormat: \'m-d-yy\'\n  }\n);\n\nUsage:\n{^{myDatepicker date /}}\n{^{myWcfDatepicker wcfString/}}\n\nTo override the default settings for the regular {{datepicker}} tag, use:\n$.views.tags("datepicker", {\n  baseTag: "datepicker",\n  dataFormat: ...\n  dateFormat: ...\n})\n\nUsage:\n{^{datepicker date /}}\n\n'},{_type:"para",title:"Using converters with {{datepicker}}",text:"Using converters with {{datepicker}}\nConverters can be useful with the {{datepicker}} tag. For example, they can be used as an alternative to the “data formatter” pattern, to convert to and from a custom underlying data format. Or they can be used for adding a date or time shift to the displayed date. (This can be done in conjunction with any dataFormat including when using a “data formatter”):\n{^{datepicker wcfString ... convert=~wcfToJqui convertBack=~jquiToWcf /}}\n\n{^{myWcfDatepicker ... wcfString daysToAdd=delay convert=~addDays convertBack=~removeDays /}}\n\n// Converters for shifting date\nfunction addDays(val) {\n  var dt = this.dataFormat.parse(val); // 'this' is the tag instance\n  dt.setDate(dt.getDate() + this.tagCtx.props.daysToAdd);\n  return this.dataFormat.format(dt);\n}\n\nfunction removeDays(val) {\n  var dt = this.dataFormat.parse(val); // 'this' is the tag instance\n  dt.setDate(dt.getDate() - this.tagCtx.props.daysToAdd);\n  return this.dataFormat.format(dt);\n}\n\nThe following sample shows examples using data formatters and converters, and examples of custom datepicker tags:\n"},{_type:"sample",title:"Data formatters, converters and custom tag examples",url:"samples/tag-controls/jqui/datepicker/date-formats/custom",text:'Data formatters, converters and custom tag examples\nUsing a formatter to bind to a custom “date string” format:\n{^{datepicker wcfString dataFormat=~wcfDate /}}\n{^{datepicker wcfString dataFormat=~wcfDate dateFormat="DD MM d, yy" /}}\n\nCustom datepickers:\n{^{myDatepicker date/}}\n{^{myDatepicker date dateFormat="mm-dd-yy (DD)" /}}\n\n{^{myWcfDatepicker wcfString /}}\n{^{myWcfDatepicker wcfString dateFormat="DD mm/dd/yy" /}}\n\nUsing converters\n{^{datepicker wcfString dateFormat="D M d, yy"\n    convert=~fromWcfDate convertBack=~toWcfDate /}}\n\n{^{myWcfDatepicker wcfString dateFormat="D M d, yy" ^daysToAdd=delay\n    convert=~addDays convertBack=~removeDays /}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\n// Use moment.js to format WCF date string\nfunction wcfFormat(date) {\n  return moment(date).format("/\\\\D\\\\at\\\\e(xZZ)/");\n}\n\n// Use moment.js to parse WCF date string\nfunction wcfParse(wcfString) {\n  return moment(wcfString, "/\\\\D\\\\at\\\\e(xZZ)/").toDate();\n}\n\n// Converters between data formats:\n// WCF date string format to jQuery UI date format\nfunction fromWcfToJqui(wcfDate) {\n  return $.datepicker.formatDate(\n    this.dateFormat, wcfParse(wcfDate)\n  );\n}\n// jQuery UI date format to WCF date string format\nfunction fromJquiToWcf(dateString) {\n  return wcfFormat(\n    $.datepicker.parseDate(this.dateFormat, dateString)\n  );\n}\n\n// Converters for shifting date\nfunction addDays(val) {\n  var dt = this.dataFormat.parse(val);\n  dt.setDate(dt.getDate() + this.tagCtx.props.daysToAdd);\n  return this.dataFormat.format(dt);\n}\n\nfunction removeDays(val) {\n  var dt = this.dataFormat.parse(val);\n  dt.setDate(dt.getDate() - this.tagCtx.props.daysToAdd);\n  return this.dataFormat.format(dt);\n}\n\n// DateFormatter using WCF date string format\nvar wcfDateFormatter = {\n  parse: wcfParse,\n  format: wcfFormat\n};\n\n// Hash of helpers\nvar helpers = {\n  wcfDate: wcfDateFormatter,\n  wcfToJqui: fromWcfToJqui,\n  jquiToWcf: fromJquiToWcf,\n  addDays: addDays,\n  removeDays: removeDays\n}\n\n// Custom datepicker tags\n$.views.tags({\n  myDatepicker: {\n    baseTag: "datepicker",\n    dataFormat: false, // Any falsy value\n    dateFormat: "DD MM d, yy"\n  },\n  myWcfDatepicker: {\n    baseTag: "datepicker",\n    dataFormat: wcfDateFormatter,\n    dateFormat: \'m-d-yy\'\n  },\n  myWcfDatepicker2: {\n    baseTag: "datepicker",\n    convert: fromWcfToJqui,\n    convertBack: fromJquiToWcf,\n    dateFormat: \'m-d-yy\'\n    }\n  }\n);\n\n// Compiled page template\nvar pageTmpl = $.templates("#pageTmpl");\n\n// Load the page:\nvar model = {\n    delay: 30,\n    date: new Date(),\n    dateNumber: +new Date(),\n    dateString: $.datepicker.formatDate("mm-dd-yy", new Date()),\n    wcfString: wcfFormat()\n  };\n\npageTmpl.link("#page", model, helpers);\n\n// Alternatively, register helpers: \n//$.views.helpers(helpers);\n//pageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Using a formatter to bind to a custom "date string" format</h4>\r\n  <pre>dataFormat=~wcfDate</pre>\r\n  <p>\r\n    Underlying data (string):\r\n    <em>{^{:wcfString}}</em>\r\n  </p>\r\n  <p>\r\n    {^{datepicker wcfString dataFormat=~wcfDate /}}\r\n    {^{datepicker wcfString dataFormat=~wcfDate dateFormat="DD MM d, yy" /}}\r\n  </p>\r\n\r\n  <h4>Custom datepickers</h4>\r\n  <pre>&lcub;^{myDatepicker ... /}&rcub;</pre>\r\n  <p>\r\n    Underlying data (date):\r\n    <em>{^{:date}}</em>\r\n  </p>\r\n  <p>\r\n    {^{myDatepicker date /}}\r\n    {^{myDatepicker date dateFormat="mm-dd-yy (DD)" /}}\r\n  </p>\r\n\r\n  <pre>&lcub;^{myWcfDatepicker ... /}&rcub;</pre>\r\n  <p>\r\n    Underlying data (string):\r\n    <em>{^{:wcfString}}</em>\r\n  </p>\r\n  <p>\r\n    {^{myWcfDatepicker wcfString /}}\r\n    {^{myWcfDatepicker wcfString dateFormat="DD mm/dd/yy" /}}\r\n  </p>\r\n\r\n  <h4>Using converters</h4>\r\n  <pre>&lcub;^{datepicker ... convert=... convertBack=... /}&rcub;</pre>\r\n  <p>\r\n    Underlying data (string):\r\n    <em>{^{:wcfString}}</em>\r\n  </p>\r\n  <p>\r\n    {^{datepicker wcfString dateFormat="D M d, yy"\r\n        convert=~wcfToJqui convertBack=~jquiToWcf /}}\r\n  </p>\r\n  <p>\r\n    Delayed date:\r\n    {^{myWcfDatepicker wcfString dateFormat="D M d, yy" ^daysToAdd=delay\r\n        convert=~addDays convertBack=~removeDays /}}\r\n    Add days:\r\n    {^{spinner delay width=50 /}}\r\n  </p>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"",text:"See also: {{timespinner}}\n"}]},"samples/tag-controls/jqui/timespinner":{sections:[{_type:"para",title:"",text:"The {{timespinner}} is a derived {{spinner}} tag for showing time (hours and minutes).\nBy default it binds to underlying data of type Date. The default display shows time using the 24 hour clock (e.g. 13:30).\nIt can be used in conjunction with the {{datepicker}}:\n"},{_type:"sample",text:'\n  Time: {^{timespinner date /}}<br/><br/>\n  Date: {^{datepicker date elem="div" dataFormat=false /}}<br/><br/>\n  <b>Underlying data (date):</b><br/><br/> <em>{^{:date}}</em>\n\n\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl");\nvar nextWeek = new Date();\nnextWeek.setDate(nextWeek.getDate()+7);\n\nvar model = {\n    date: nextWeek\n  };\n\npageTmpl.link("#page", model);\nTime: {^{timespinner date /}}\n\nDate: {^{datepicker date elem="div" dataFormat=false /}}\n\nUnderlying data (date):{^{:date}}\n\n\n'},{_type:"para",title:"",text:"Note that if the {{timespinner}} moves past 23:59 to 00:00, the {{datepicker}} moves to the next day… To make the {{timespinner}} stay on the same day, set:\n{{timespinner ... keepDay=true /}}\n\n"},{_type:"para",title:"Locale-specific time formatting: displayFormatter",text:"Locale-specific time formatting: displayFormatter\nA built-in displayFormatter provides locale-specific formatting (by setting _culture to the desired locale), but for this to work, the 0.1.1 version of jQuery Globalize must be included:\n"},{_type:"sample",title:"Time formatting using globalize.js 0.1.1",url:"samples/tag-controls/jqui/timespinner/globalize",text:'Time formatting using globalize.js 0.1.1\n<script src="//cdnjs.cloudflare.com/ajax/libs/globalize/0.1.1/globalize.min.js"></script>\n<script src="//cdnjs.cloudflare.com/ajax/libs/globalize/0.1.1/cultures/globalize.culture.de-DE.min.js"></script>\n<script src="//cdnjs.cloudflare.com/ajax/libs/globalize/0.1.1/cultures/globalize.culture.ja-JP.min.js"></script>\n\n{^{timespinner date ^_culture=culture /}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl");\n\nvar model = {\n    culture: "en-US",\n    date: new Date()\n  };\n\npageTmpl.link("#page", model);\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Choose culture:</h4>\r\n  <p>\r\n    <select data-link="culture" name="culture">\r\n      <option value="en-US">US</option>\r\n      <option value="de-DE">Germany</option>\r\n    </select>\r\n  </p>\r\n  <p>\r\n    Underlying data (date):\r\n    <em>{^{:date}}</em>\r\n  </p>\r\n  <p>\r\n    {^{timespinner date ^_culture=culture /}}\r\n  </p>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Custom display formatters",text:'Custom display formatters\nThe {{timespinner}} tag control lets you provide your own "display formatter" (an object with a parse and a format() method) – to provide conversion between Date and any string display you wish.\nIn particular, you can use your own display formatter to provide formatting based on culture, without depending on the Globalize 0.1.1 library.\nThe following sample uses moment.js for time formatting based on culture:\n'},{_type:"sample",title:"Custom display formatter using moment.js for culture/locale support",url:"samples/tag-controls/jqui/timespinner/moment",text:'Custom display formatter using moment.js for culture/locale support\n  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment.min.js"></script>\n\n// Time formatter using moment.js\nvar timeFormatter = {\n  parse: function(value, props) {\n    // Note that the \'this\' pointer is the tag instance, so it can be used to access any tag properties\n    var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n    return moment(value, format).toDate();\n  },\n  format: function(value, props) {\n    var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n    return moment(value).format(format);\n  }\n};\n\nUsage:\n$.views.helpers({time: timeFormatter, ...});\n\n{^{timespinner date ^_culture=culture displayFormat=~time /}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar formatters = {\n\n  // Time formatter using moment.js\n  time: {\n    parse: function(value, props) {\n      var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n      return moment(value, format).toDate();\n    },\n    format: function(value, props) {\n      var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n      return moment(value).format(format);\n    }\n  }\n\n};\n\n// Compiled page template\nvar pageTmpl = $.templates("#pageTmpl");\n\n// Load the page:\nvar model = {\n    culture: "en-US",\n    date: new Date()\n  };\n\npageTmpl.link("#page", model, formatters);\n\n// Alternatively, register formatters as helpers: \n//$.views.helpers(formatters);\n//pageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Choose culture:</h4>\r\n  <p>\r\n    <select data-link="culture" name="culture">\r\n      <option value="en-US">US</option>\r\n      <option value="de-DE">Germany</option>\r\n    </select>\r\n  </p>\r\n  <p>\r\n    Underlying data (date):\r\n    <em>{^{:date}}</em>\r\n  </p>\r\n  <p>\r\n    {^{timespinner date ^_culture=culture displayFormat=~time /}}\r\n  </p>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Alternative data formats: binding to timestamp number",text:"Alternative data formats: binding to timestamp number\nTo bind to a timestamp (tick count) number, simply set dataFormat=0:\n{^{timespinner dateNumber ^_culture=culture dataFormat=0 /}}\n\nor if using a different display formatter:\n{^{timespinner dateNumber ^_culture=culture displayFormat=~time dataFormat=0 /}}\n\n"},{_type:"para",title:"Alternative data formats: binding to a custom string",text:'Alternative data formats: binding to a custom string\nTo bind to a custom string format for the underlying date, provide a "data formatter" (object with a parse() and a format() method), or provide converters, to convert between Date and the chosen string format.\nThe next sample shows the use of both a “data formatters” to create a timespinner bindng to underlying data of type number or string. It also shows the use of converters to shift the displayed date-time relative to the underlying data:\n'},{_type:"sample",url:"samples/tag-controls/jqui/timespinner/dataformat",text:'Binding to number:\n{^{datepicker dateNumber dataFormat=0 /}}\n{^{timespinner dateNumber dataFormat=0 ... /}}\n\nBinding to custom string\n{^{datepicker dateTimeString dataFormat=~fullDate /}}\n{^{timespinner dateTimeString dataFormat=~fullDate ... /}}\n\nBinding to a WCF date-time string\n{^{datepicker wcfString dataFormat=~wcfDate /}}\n{^{timespinner wcfString dataFormat=~wcfDate ... /}}\n\nUsing convert/convertBack to display date-time shifted by a delay\n{^{datepicker wcfString dataFormat=~wcfDate\n      convert=~add convertBack=~subtract ^delay=delay /}}\n{^{timespinner wcfString dataFormat=~wcfDate\n      convert=~add convertBack=~subtract ^delay=delay ... /}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar helpers = {\n  // Data formatter using moment.js - for wcfDate serialization\n  wcfDate: {\n    parse: function(wcfString, props) {\n      return moment(wcfString, "/\\\\D\\\\at\\\\e(xZZ)/").toDate();\n    },\n    format: function(date, props) {\n      return moment(date).format("/\\\\D\\\\at\\\\e(xZZ)/");\n    }\n  },\n\n  // Data formatter using moment.js - using custom full date/time string\n  fullDate: {\n    parse: function(dateTimeString, props) {\n      return moment(dateTimeString, "YYYY-MM-DD@HH:mm").toDate();\n    },\n    format: function(date, props) {\n      return moment(date).format("YYYY-MM-DD@HH:mm");\n    }\n  },\n\n  // Time display formatter (culture-based) using moment.js\n  time: {\n    parse: function(timeString, props) {\n      var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n      return moment(timeString, format).toDate();\n    },\n    format: function(date, props) {\n      var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n      return moment(date).format(format);\n    }\n  },\n\n  // Date to number formatter\n  dateToNumber: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n\n  // Converters for shifting time\n  add: function(data, props) {\n    var dt = this.dataFormat.parse(data);\n    dt.setMinutes(dt.getMinutes() + this.tagCtx.props.delay * 60);\n    return this.dataFormat.format(dt);\n  },\n  subtract: function(data) {\n    var dt = this.dataFormat.parse(data);\n    dt.setMinutes(dt.getMinutes() - this.tagCtx.props.delay * 60);\n    return this.dataFormat.format(dt);\n  }\n};\n\n// Compiled page template\nvar pageTmpl = $.templates("#pageTmpl");\n\n// Load the page:\nvar startDate = new Date();\nvar model = {\n    culture: "en-US",\n    delay: 25,\n    date: startDate,\n    dateNumber: +startDate,\n    dateTimeString: moment(startDate).format("YYYY-MM-DD@HH:mm"),\n    wcfString: moment(startDate).format("/\\\\D\\\\at\\\\e(xZZ)/")\n  };\n\npageTmpl.link("#page", model, helpers);\n\n// Alternatively, register helpers: \n//$.views.helpers(helpers);\n//pageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Choose culture:</h4>\r\n  <select data-link="culture" name="culture">\r\n    <option value="en-US">US</option>\r\n    <option value="de-DE">Germany</option>\r\n  </select>\r\n\r\n  <h4>Binding to timestamp number</h4>\r\n  <em>{^{:dateNumber}}</em>\r\n\r\n  <pre>dataFormat=0</pre>\r\n\r\n  {^{datepicker dateNumber dataFormat=0 /}}<br/>\r\n\r\n  {^{timespinner dateNumber dataFormat=0\r\n        ^_culture=culture displayFormat=~time /}}\r\n\r\n  <h4>Binding to a custom date time string</h4>\r\n  <em>{^{:dateTimeString}}</em>\r\n\r\n  <pre>dataFormat=~fullDate</pre>\r\n\r\n  {^{datepicker dateTimeString dataFormat=~fullDate /}}<br/>\r\n\r\n  {^{timespinner dateTimeString dataFormat=~fullDate\r\n        ^_culture=culture displayFormat=~time /}}\r\n\r\n  <h4>Binding to a WCF date-time string</h4>\r\n  <em>{^{:wcfString}}</em>\r\n\r\n  <pre>dataFormat=~wcfDate</pre>\r\n\r\n  {^{datepicker wcfString dataFormat=~wcfDate /}}<br/>\r\n\r\n  {^{timespinner wcfString dataFormat=~wcfDate\r\n        ^_culture=culture displayFormat=~time /}}\r\n\r\n  <h4>Using convert/convertBack to display date-time shifted by a delay</h4>\r\n\r\n  <em>Hours delay:</em>\r\n  {^{spinner delay /}}<br/>\r\n\r\n  <pre>dataFormat=~wcfDate convert=~add convertBack=~subtract</pre>\r\n\r\n  {^{datepicker wcfString dataFormat=~wcfDate convert=~add convertBack=~subtract ^delay=delay /}}<br/>\r\n\r\n  {^{timespinner wcfString dataFormat=~wcfDate convert=~add convertBack=~subtract ^delay=delay\r\n        ^_culture=culture displayFormat=~time /}}\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Custom timespinner tags",text:'Custom timespinner tags\nYou can create your own flavor of timespinner which defaults to a chosen displayFormat and/or dataFormat and/or default converters:\n$.views.tags({\n  myTimespinner: {\n    baseTag: "timespinner",\n    displayFormat: momentTimeFormatter,\n    dataFormat: momentCustomDateTime,\n    convert: addDays,\n    convertBack: subtractDays\n  }\n);\n\nUsage:\n{^{myTimespinner dateTimeString culture="en-US" delay=48 /}}\n\nSee also: Datepicker date formats\n'}]},"samples/tag-controls/jqui/spinner/formats":{sections:[{_type:"para",title:"",text:"The jQuery UI spinner includes support for displaying number using number or currency formats based on culture or locale. However this support depends on including the 0.1.1 version of jQuery Globalize.\n"},{_type:"sample",title:"Number and currency formats using globalize.js 0.1.1",url:"samples/tag-controls/jqui/spinner/globalize",text:'Number and currency formats using globalize.js 0.1.1\n<script src="//cdnjs.cloudflare.com/ajax/libs/globalize/0.1.1/globalize.min.js"></script>\n<script src="//cdnjs.cloudflare.com/ajax/libs/globalize/0.1.1/cultures/globalize.culture.de-DE.min.js"></script>\n<script src="//cdnjs.cloudflare.com/ajax/libs/globalize/0.1.1/cultures/globalize.culture.ja-JP.min.js"></script>\n\n{^{spinner amount ^_culture=culture _numberFormat="C" /}}\n\n{^{spinner amount ^_culture=culture _numberFormat="n" /}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl");\n\nvar model = {\n    culture: "de-DE",\n    amount: 1099.20\n  };\n\npageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Choose culture:</h4>\r\n  <p>\r\n    <select data-link="culture" name="culture">\r\n      <option value="en-US">US</option>\r\n      <option value="de-DE">Germany</option>\r\n    </select>\r\n  </p>\r\n  <p>\r\n    Underlying data (number):\r\n    <em>{^{:amount}}</em>\r\n  </p>\r\n  <p>\r\n    <pre>_numberFormat="C"</pre>\r\n    {^{spinner amount ^_culture=culture _numberFormat="C" width=100 /}}\r\n  </p>\r\n  <p>\r\n    <pre>_numberFormat="n"</pre>\r\n    {^{spinner amount ^_culture=culture _numberFormat="n" width=100 /}}\r\n  </p>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Custom display formatters",text:'Custom display formatters\nThe {{spinner}} tag control lets you specify a “display formatter” (an object with a parse() and a format() method) – to provide conversion between the underlying number and any string display you wish.\nIn particular, you can use your own formatter to provide formatting based on culture, without depending on the Globalize 0.1.1 library.\n(Note that the this pointer within parse or format is the tag instance (in this case the spinner instance) so it can be used to access any tag properties.)\nThe following formatter uses accounting.js to provide culture-based number formatting:\nvar accountingCulture = {\n  "de-DE": {symbol: "€", thousand: ".", decimal: ",", format: "%v %s"},\n  "en-US": {symbol: "$", thousand: ",", decimal: "."}\n};\n\nvar numberFormatter = {\n  format: function(value, props) {\n    return accounting.formatNumber(\n      value,\n      accountingCulture[props._culture]\n    );\n  },\n  parse: function(value, props) {\n    return accounting.unformat(\n      value,\n      accountingCulture[props._culture].precision\n    );\n  }\n};\n\nUsage:\n$.views.helpers({number: numberFormatter, ...});\n\n{^{spinner amount ^_culture=culture displayFormat=~number /}}\n\nThe following sample uses accounting.js for currency and number formatting based on culture:\n'},{_type:"sample",title:"Custom display formatters using accounting.js for culture/locale support",url:"samples/tag-controls/jqui/spinner/accounting",text:'Custom display formatters using accounting.js for culture/locale support\n<script src="//cdnjs.cloudflare.com/ajax/libs/accounting.js/0.4.1/accounting.js"></script>\n\n{^{spinner amount ^_culture=culture displayFormat=~currency /}}\n\n{^{spinner amount ^_culture=culture displayFormat=~number /}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar accountingCulture = {\n  "de-DE": {symbol: "€", thousand: ".", decimal: ",", format: "%v %s"},\n  "en-US": {symbol: "$", thousand: ",", decimal: "."}\n};\n\nvar formatters = {\n\n  // Currency formatter using accounting.js\n  currency: {\n    format: function(value, props) {\n      return accounting.formatMoney(\n        value,\n        accountingCulture[props._culture]\n      );\n    },\n    parse: function(value, props) {\n      return accounting.unformat(\n        value,\n        accountingCulture[props._culture].decimal\n      );\n    }\n  },\n\n  // Number formatter using accounting.js\n  number: {\n    format: function(value, props) {\n      return accounting.formatNumber(\n        value,\n        accountingCulture[props._culture]\n      );\n    },\n    parse: function(value, props) {\n      return accounting.unformat(\n        value,\n        accountingCulture[props._culture].decimal\n      );\n    }\n  }\n};\n\n// Compiled page template\nvar pageTmpl = $.templates("#pageTmpl");\n\n// Load the page:\nvar model = {\n    culture: "de-DE",\n    amount: 1099.25\n  };\n\npageTmpl.link("#page", model, formatters);\n\n// Alternatively, register formatters as helpers: \n//$.views.helpers(formatters);\n//pageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Choose culture:</h4>\r\n  <p>\r\n    <select data-link="culture" name="culture">\r\n      <option value="en-US">US</option>\r\n      <option value="de-DE">Germany</option>\r\n    </select>\r\n  </p>\r\n  <p>\r\n    Underlying data (number):\r\n    <em>{^{:amount}}</em>\r\n  </p>\r\n  <p>\r\n    <pre>displayFormat=~currency</pre>\r\n    {^{spinner amount ^_culture=culture displayFormat=~currency width=100 /}}\r\n  </p>\r\n  <p>\r\n    <pre>displayFormat=~number</pre>\r\n    {^{spinner amount ^_culture=culture displayFormat=~number width=100 /}}\r\n  </p>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"",text:"The same approach can be used for a time spinner with localized display format. The following sample uses moment.js for time formatting based on culture (but note that it is simpler and better to use the specific {{timespinner}}) tag):\n"},{_type:"sample",url:"samples/tag-controls/jqui/spinner/moment",text:'<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment.min.js"></script>\n\ntime: {\n  parse: function(value, props) {\n    var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n    return moment(value, format).toDate();\n  },\n  format: function(value, props) {\n    var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n    return moment(value).format(format);\n  }\n}\n\n{^{spinner dateNumber ^_culture=culture ... displayFormat=~time /}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar formatters = {\n\n  // Time formatter using moment.js\n  time: {\n    parse: function(value, props) {\n      var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n      return moment(value, format).toDate();\n    },\n    format: function(value, props) {\n      var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n      return moment(value).format(format);\n    }\n  }\n\n};\n\n// Compiled page template\nvar pageTmpl = $.templates("#pageTmpl");\n\n// Load the page:\nvar model = {\n    culture: "de-DE",\n    dateNumber: +new Date()\n  };\n\npageTmpl.link("#page", model, formatters);\n\n// Alternatively, register formatters as helpers: \n//$.views.helpers(formatters);\n//pageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Choose culture:</h4>\r\n  <p>\r\n    <select data-link="culture" name="culture">\r\n      <option value="en-US">US</option>\r\n      <option value="de-DE">Germany</option>\r\n    </select>\r\n  </p>\r\n  <p>\r\n    Underlying data (timestamp number):\r\n    <em>{^{:dateNumber}}</em>\r\n  </p>\r\n  <p>\r\n    <pre>displayFormat=~time</pre>\r\n    {^{spinner dateNumber ^_culture=culture _step=60000 _page=60 displayFormat=~time width=100 /}}\r\n  </p>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Using a data formatter, or converters, to bind to a custom underlying data format",text:"Using a data formatter, or converters, to bind to a custom underlying data format\nBy default the underlying data format used by {{spinner}} is a number. However any underlying data format can be used by providing a corresponding “data formatter” (object with a parse() and a format() method), and setting the dataFormat to that formatter.\nThe next sample shows the use of both a “data formatter”, and converters, to create a timespinner bindng to underlying data of type Date (though this is can be done more simply using the {{timespinner}}) tag):\n"},{_type:"sample",url:"samples/tag-controls/jqui/spinner/dataformat",text:'// Date to number formatter\ndateToNumber: {\n  parse: function(value, props) {\n    return +value;\n  },\n  format: function(value, props) {\n    return new Date(value);\n  }\n}\n\n{^{spinner date ^_culture=culture ... displayFormat=~time dataFormat=~dateToNumber /}}\n\n{^{spinner date ^_culture=culture ... displayFormat=~time convert=~toNumber convertBack=~toDate /}}\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n"use strict";\nvar helpers = {\n\n  // Time formatter using moment.js\n  time: {\n    parse: function(value, props) {\n      var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n      return moment(value, format).toDate();\n    },\n    format: function(value, props) {\n      var format = props._culture === "en-US" ? "h:mm A" : "HH:mm";\n      return moment(value).format(format);\n    }\n  },\n\n  // Date to number formatter\n  dateToNumber: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n\n  // Converters\n  toNumber: function(value, props) {\n    return +value;\n  },\n  toDate: function(value, props) {\n    return new Date(value);\n  }\n};\n\n// Compiled page template\nvar pageTmpl = $.templates("#pageTmpl");\n\n// Load the page:\nvar model = {\n    culture: "de-DE",\n    date: new Date()\n  };\n\npageTmpl.link("#page", model, helpers);\n\n// Alternatively, register helpers: \n//$.views.helpers(helpers);\n//pageTmpl.link("#page", model);\n\n<script id="pageTmpl" type="text/x-jsrender">\r\n  <h4>Choose culture:</h4>\r\n  <p>\r\n    <select data-link="culture" name="culture">\r\n      <option value="en-US">US</option>\r\n      <option value="de-DE">Germany</option>\r\n    </select>\r\n  </p>\r\n  <p>\r\n    Underlying data (date):\r\n    <em>{^{:date}}</em>\r\n  </p>\r\n  <p>\r\n    <pre>displayFormat=~time dataFormat=~dateToNumber</pre>\r\n    {^{spinner date ^_culture=culture _step=60000 _page=60 displayFormat=~time dataFormat=~dateToNumber width=100 /}}\r\n  </p>\r\n  <p>\r\n    <pre>displayFormat=~time convert=~toNumber convertBack=~toDate</pre>\r\n    {^{spinner date ^_culture=culture _step=60000 _page=60 displayFormat=~time convert=~toNumber convertBack=~toDate width=100 /}}\r\n  </p>\r\n</script>\r\n\r\n<div id="page"></div>\n'
},{_type:"para",title:"Custom spinner tags",text:'Custom spinner tags\nYou can create your own flavor of spinner which defaults to a chosen displayFormat and dataFormat:\n$.views.tags({\n  myCurrencySpinner: {\n    baseTag: "spinner",\n    displayFormat: currencyFormatter\n  }\n);\n\nUsage:\n{^{myCurrencySpinner amount culture=culture /}}\n\n'}]},"samples/tag-controls/jqui/spinner/variants":{sections:[{_type:"para",title:"",text:"The {{spinner}} tag integrates the jQuery UI spinner widget (api).\nThis allows data-linking directly to widget properties, as well as using generic tag functionality such as convert and convertBack.\nIn addition, validation support is obtained, simply by wrapping a {{spinner}} tag with a {{validate}}.\nHere is a sample with three {{spinner}} controls, using alternate syntaxes: tag syntax or element-based data-link syntax:\n"},{_type:"sample",text:'Variants of the {{spinner}} tag:\n\n\n<h4>Tag syntax</h4>\n\n<pre>&lcub;^{spinner amount .../}&rcub;</pre>\n\n{^{spinner amount/}}\n\n<h4>Tag syntax, wrapping element:</h4>\n\n<pre>\n&lcub;^{spinner amount ...}&rcub;\n    &lt;input .../&gt;\n&lcub;^{/spinner}&rcub;\n</pre>\n\n{^{spinner amount}}\n  <input/>\n{{/spinner}}\n\n<h4>Element-based data-link syntax:</h4>\n\n<pre>\n&lt;input data-link="{spinner amount ...}" /&gt;\n</pre>\n\n<input data-link="{spinner amount}"/>\n\n<h4>Regular input tag without spinner:</h4>\n\n<input type="text" data-link="{:amount:tonum}" />\n\n\n\n\n\n\n\n$.views.converters({\n  tonum: function(val) {\n    return +val; // Convert string to number\n  }\n});\n\nvar pageTmpl = $.templates("#pageTmpl"),\n  model = {\n    amount: 150\n  };\n\npageTmpl.link("#page", model);\nMultiple examples of {{spinner}} syntax…\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n'
},{_type:"para",title:"",text:"The following sample is a declarative data-driven version of the jQuery UI Currency spinner demo.\nThe sample also shows the use of {{validate}} with the {{spinner}} tag. (Uncheck Enforce in-range amount, and move the slider left or right.)\nNote that the page includes the jQuery Globalize.js library version 0.1.1. It also includes the jQuery mousewheel plugin (which allows you to use the mousewheel to ‘spin’ the {{spinner}} control).\n"},{_type:"sample",url:"samples/tag-controls/jqui/spinner/sample",text:'{^{validate amount messagewrap=true ...}}\n\n  {^{spinner amount\n    ^_culture=currency\n    _numberFormat="C"\n    ...\n  /}}\n\n{{/validate}}\n\n<select data-link="currency" ...>\n  <option value="en-US">US $</option>\n  ...\n</select>\n\n\n/*! JsViews jQueryUI widget integration v0.9.87 (Beta)\nsee: http://www.jsviews.com/#download/jqueryui-tagcontrols */\n/*\n* https://www.jsviews.com/download/sample-tag-controls/jsviews-jqueryui-widgets.js\n* Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n/* Wrap behavior (wrapping HTML content) and default element, for each widget: */\n\n/*       autocomplete button   buttonset droppable   menu        progressbar  resizable\n * wrap: -            wrap     -         wrap        wrap        wrap         wrap     \n * elem: input        button   -         -           ul          div          div      \n */\n\n/*       selectable   slider   spinner   timespinner  tabs       sortable     draggable\n * wrap: wrap         -        -         -            wrap       wrap         wrap     \n * elem: -            div      input     input        -          -            -      \n */\n\n/*       accordion    checkbox radio     controlgroup selectmenu datepicker\n * wrap: wrap         -        -         wrap         wrap       wrap\n * elem: -            div      input     span         selectv    input\n */\n\n(function(global, $, undefined) {\n"use strict";\n\nif (!$ || !$.fn || !$.ui || !$.views) {\n  // jQuery is not loaded.\n  throw "jsviews-jqueryui-widgets.js requires jQuery, jQuery UI and JsViews";\n}\n\nfunction getConverter(tag, cvt) {\n  return cvt + "" === cvt ? tag.tagCtx.contentView.getRsc("converters", cvt) : cvt;\n}\n\nfunction checkboxRadioBeforeBind(tagCtx, linkCtx) {\n  var tag = this,\n    props = tagCtx.props,\n    elem = tag.mainElem[0],\n    val = tag.bndArgs()[0];\n  // Set the value to arg[0] (after applying converter, if there is one)\n\n  if (props.name) {\n    elem.name = props.name;\n  }\n  if (props.value) {\n    elem.value = props.value;\n  }\n\n  tag.baseApply(arguments);\n  tag.displayElem = tag.widget.label;\n\n  if (props.label) {\n    tag.widget.option("label", props.label);\n  }\n}\n\nfunction tabsAccordionOnBind(tagCtx, linkCtx) {\n  var tag = this;\n  tag.baseApply(arguments);\n\n  tag.mainElem.on("jsv-domchange", function(ev, tagCtx, linkCtx, eventArgs) {\n    var newSelected,\n      selected = tag.widget.option("active");\n\n    tag.widget.refresh();\n    newSelected = tag.widget.option("active")\n\n    if (selected !== newSelected) {\n      tag.updateValue(newSelected);\n    }\n  });\n}\n\nfunction tabsAccordionOptions() {\n  var tag = this;\n  return {\n    activate: function(evt, ui) {\n      // Raise elemChangeHandler event when selected tab changes - for two-way binding to arg(0)\n\t\t\ttag.updateValue(tag.widget.option("active"));\n    }\n  };\n}\n\nfunction initFormatter(tag, tagCtx) { // Used by datepicker and spinner\n  var dataFormatter,\n    dataFormat = tagCtx.props.dataFormat;\n  if (dataFormat === undefined) {\n    dataFormat = tag.dataFormat;\n  }\n  dataFormatter = dataFormat && dataFormat.parse\n    ? dataFormat\n    : tag.dataFormatter;\n\n  // Formatter can be provided as tag.dataFormat or tagCtx.props.dataFormat\n  tag.parseData = function(value) {\n    return dataFormatter.parse.call(tag, value, tag.tagCtx.props);\n  };\n  tag.formatData = function(value) {\n    return dataFormatter.format.call(tag, value, tag.tagCtx.props);\n  };\n  return dataFormat;\n}\n\nvar tagDefs = {\n// ============================= WIDGET =============================\nwidget: {\n  argDefault: false, // Do not default missing arg to #data\n  mainElement: "*",\n  init: function(tagCtx) {\n    var content, elemType,\n      tag = this;\n\n    if (tag._.inline) {\n      content = tagCtx.tmpl.markup;\n      if (!tag.template && (elemType = tagCtx.props.elem || tag.elem)) {\n        if (content) {\n          if (tag.wrap) {\n            tag.template = "<"+elemType+">" + $.trim(content) + "</"+elemType+">";\n          }\n        } else {\n          tag.template = (elemType === "input") ? "<input/>" : "<"+elemType+"></"+elemType+">";\n        }\n      }\n      tag.attr = "html";\n    }\n  },\n  onBeforeBind: function(tagCtx) {\n    var mainElem, prop, i, optionKey,\n      tag = this,\n      presets = tag.initOptions, // initOptions: array of option names that when set declaratively\n                                 // as tag options will be set on creation, not on afterLink\n      widgetName = tag.widgetName,\n      options = tag.options,     // hash (or function returning hash) of option settings\n      widgetFullName = widgetName;\n\n    widgetName = widgetName.split("-").pop();\n\n    if (i = presets && presets.length) {\n      presets = {};\n      while (i--) {\n        optionKey = tag.initOptions[i];\n        if (prop = tagCtx.props["_" + optionKey]) {\n          presets[optionKey] = prop;\n        }\n      }\n    }\n    if (widgetFullName === widgetName) {\n      widgetFullName = "ui-" + widgetName;\n    }\n\n    mainElem = tag.mainElem;\n    if (!mainElem || !mainElem[0]) {\n      // This may be due to using {{myWidget}} No element found here {{/myWidget}} \n      throw "No element found for tag \'" + tag.tagName +"\'";\n    }\n\n    if (tagCtx.props.id && !mainElem[0].id) {\n      mainElem[0].id = tagCtx.props.id;\n    }\n\n    // Instantiate widget\n    mainElem[widgetName](presets);\n\n    // Store widget instance\n    tag.widget = mainElem.data(widgetFullName) || mainElem.data(widgetName);\n\n    if (!tag.widget) {\n      // Widget failed to load, or is not a valid widget factory type\n      throw "widget \'" + widgetName + "\' failed";\n    }\n\n    if (options) {\n      if ($.isFunction(options)) {\n        options = tag.options();\n      }\n      mainElem[widgetName]("option", options); // initialize options\n    }\n  },\n  onAfterLink: function(tagCtx) {\n    var mainElem,\n      tag = this,\n      options = tag.options, // hash (or function returning hash) of option settings\n      props = tagCtx.props,\n      widgetName = tag.widgetName.split("-").pop();\n\n    mainElem = tag.mainElem;\n    $.each(props, function(key, prop) {\n      var option;\n      if (key.charAt(0) === "_") {\n        key = key.slice(1);\n        option = options && options[key];\n        mainElem[widgetName]("option", key,\n          option && $.isFunction(option) && prop && $.isFunction(option)\n            ? function() {\n              // If the same event function option is overridden on the tagDef options\n              // (or in a _create override) and the tagCtx.props, call first the one on\n              // the initOptions options, and then the one declared on the tag properties.\n              option.apply(mainElem[0], arguments);\n              return prop.apply(mainElem[0], arguments);\n            }\n            : prop\n          );\n      }\n    });\n  },\n  onUpdate: false, // Don\'t rerender whole tag on update\n  dataBoundOnly: true,\n  attr: "none"\n},\n// ============================= BUTTON =============================\nbutton: {\n  baseTag: "widget",\n  widgetName: "button",\n  elem: "button",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  onBind: function(tagCtx, linkCtx) {\n    var elem = this.mainElem[0];\n      elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n    this.baseApply(arguments);\n  },\n  onAfterLink: function(tagCtx, linkCtx, ctx, event) {\n    this.baseApply(arguments);\n    if (event) {\n      this.widget.refresh();\n    }\n  }\n},\n// ============================= AUTOCOMPLETE =============================\nautocomplete: {\n  baseTag: "widget",\n  widgetName: "autocomplete",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n          // If there is a selected item, update bound value on keydown.\n          // (Alternatively can set trigger=false to update on change)\n        }\n      },\n      select: function(evt, ui) {\n        if (ui.item) {\n          tag.updateValue(ui.item.value);\n        }\n      },\n      focus: function(evt, ui) {\n        return false;\n      }\n    };\n  }\n},\n// ============================= CHECKBOX =============================\ncheckbox: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'checkbox\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val && val !== "false";\n    }\n  }\n},\n// ============================= RADIO =============================\nradio: {\n  baseTag: "widget",\n  widgetName: "checkboxradio",\n  template: "<label><input type=\'radio\'/></label>",\n  mainElement: "input",\n  linkedElement: "input",\n  setSize: true,\n  onBeforeBind: checkboxRadioBeforeBind,\n  onBind: function() {\n    var tag = this,\n      radiogroup = tag.parents.radiogroup;\n    tag.baseApply(arguments);\n    if (radiogroup && !radiogroup.onAfterLink) {\n      // If {{radio}} is child of {{radiogroup}}, make radiogroup\n      // notify radio buttons of selection changes\n      radiogroup.onAfterLink = function(tagCtx) {\n        var val = this.bndArgs()[0],\n          radios = this.childTags("radio"),\n          l = radios.length;\n        while (l--) {\n          radios[l].setValue(val);\n        }\n      }\n    }\n  },\n  setValue: function(val) {\n    if (val !== undefined) {\n      var elem = this.mainElem[0];\n      elem.checked = val === elem.value;\n    }\n    this.widget.refresh();\n  }\n},\n// ============================= CONTROLGROUP =============================\ncontrolgroup: {\n  baseTag: "widget",\n  widgetName: "controlgroup",\n  elem: "span",\n  wrap: true,\n  contentCtx: true,\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  }\n},\n// ============================= DATEPICKER =============================\ndatepicker: {\n  baseTag: "widget",\n  widgetName: "datepicker",\n  linkedElement: "*",\n  elem: "input",\n  setSize: true,\n  dataFormat: true,\n  dataFormatter: {\n    // Default data formatter uses built-in datepicker formatter as used in display.\n    // Override as tag.dataFormat in tagDef or as tagCtxprops.dataFormat\n    parse: function(value, props) {\n      return $.datepicker.parseDate(this.dataFormat, value);\n    },\n    format: function(value, props) {\n      return $.datepicker.formatDate(this.dataFormat, value);\n    }\n  },\n  init: function(tagCtx) {\n    var tag = this,\n      dateFormat = tag.dateFormat = tagCtx.props.dateFormat\n        || tagCtx.props._dateFormat // Can set as _dateFormat=... or as dateFormat=...\n        || tag.dateFormat // or set as property in tagDef\n        || $.datepicker._defaults.dateFormat, // or use internal date-picker default\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack),\n      dataFormat = initFormatter(tag, tagCtx);\n      tag.dataFormat = dataFormat === true ? tag.dateFormat : dataFormat;\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val;\n      if (tag.dataFormat && ("" + val === val)) {\n        val = tag.parseData(val);\n      }\n      return $.datepicker.formatDate(dateFormat, dataFormat === 0 ? new Date(val) : val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = $.datepicker.parseDate(dateFormat, val);\n      val = dataFormat ? tag.formatData(val) : dataFormat === 0 ? +val : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n    tag.baseApply(arguments);\n  },\n  options: function() {\n    var tag = this;\n    return {\n      onSelect: function(dateText) {\n        tag.value = dateText;\n        tag.updateValue(dateText);\n      }\n    };\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.datepicker("option", "dateFormat", tag.dateFormat);\n    if (tag.mainElem[0].tagName !== "INPUT") {\n      // This datepicker is not using an input (e.g. using a div) - so set to inline-\n      tag.mainElem.css("display", "inline-block");\n    } else {\n      tag.tagCtx.props.trigger = false;\n    }\n  },\n  setValue: function(value) {\n    var tag = this;\n    if (value !== undefined && value !== tag.value) {\n      tag.value = value;\n      tag.mainElem.datepicker("setDate", value);\n    }\n  },\n  getValue: function() {\n    return this.value;\n  }\n},\n//dialog: { // Currently not supported. (Support would require overriding _createWrapper code.)\n//  baseTag: "widget",\n//  widgetName: "dialog",\n//  wrap: true,\n//  elem: "div"\n//},\n// ============================= DROPPABLE =============================\ndroppable: {\n  baseTag: "widget",\n  widgetName: "droppable",\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("drop", value); // Set the handler function for the drop action\n    }\n  }\n},\n// ============================= MENU =============================\nmenu: {\n  baseTag: "widget",\n  widgetName: "menu",\n  elem: "ul",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  initOptions: ["menus", "items", "role"], // Options which need to be set on creation, not later\n  setValue: function(value) {\n    if ($.isFunction(value)) {\n      this.widget.option("select", value); // Set the menu select handler\n    }\n  }\n},\n// ============================= PROGRESSBAR =============================\nprogressbar: {\n  baseTag: "widget",\n  widgetName: "progressbar",\n  boundProps: ["busy"],\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  setValue: function(value) {\n    if (!this.tagCtx.props.busy) {\n      this.widget.value(parseFloat(value) || 0);\n    }\n  },\n  getValue: function() {\n    return this.widget.value();\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    if (tagCtx.props.busy) {\n      tag.widget.value(false);\n    }\n  }\n},\n// ============================= RESIZABLE =============================\nresizable: {\n  baseTag: "widget",\n  widgetName: "resizable",\n  bindTo: ["width", "height"],\n  linkedCtxParam: ["width", "height"],\n  elem: "div",\n  wrap: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      resize: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValues(ui.size.width, ui.size.height);\n        },0);\n      }\n    };\n  },\n  setValue: function(value, index) {\n    var mainElem = this.mainElem;\n    mainElem[index ? "height" : "width"](value || 0);\n  },\n  getValue: function() {\n    var mainElem = this.mainElem;\n    return [mainElem.width(), mainElem.height()];\n  }\n},\n// ============================= SELECTMENU =============================\nselectmenu: {\n  baseTag: "widget",\n  widgetName: "selectmenu",\n  linkedElement: "select",\n  elem: "select",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: function() {\n    var tag = this;\n    return {\n      change: function(evt, ui) {\n        tag.updateValue(ui.item.value);\n      }\n    };\n  },\n  onBeforeBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.displayElem = tag.widget.button;\n  },\n  onBind: function() {\n    var tag = this;\n    tag.baseApply(arguments);\n    tag.mainElem.on("jsv-domchange", function() {\n      tag.widget.refresh();\n    });\n  },\n  setValue: function(value) {\n    this.mainElem[0].value = value;\n    this.widget.refresh();\n  },\n  getValue: function() { \n    return this.mainElem[0].value;\n  }\n},\n// ============================= SLIDER =============================\nslider: {\n  baseTag: "widget",\n  widgetName: "slider",\n  bindTo: [0, 1],\n  linkedElement: ["*", "~foo"],\n  elem: "div",\n  setSize: true,\n  options: function() {\n    var tag = this;\n    return {\n      slide: function(evt, ui) {\n        setTimeout(function() {\n          tag.updateValue(ui.value);\n        }, 0);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by a the slider itself changing value\n      tag.baseApply(arguments);\n    }\n  },\n  setValue: function(value) {\n    this.widget.value(value || 0);\n  },\n  getValue: function() {\n    return this.widget.value();\n  }\n},\n// ============================= SPINNER =============================\nspinner: {\n  baseTag: "widget",\n  widgetName: "spinner",\n  mainElement: "input",\n  linkedElement: "input",\n  elem: "input",\n  setSize: true,\n  // Default display formatter uses Globalize 0.1.1.\n  // Override as tag.displayFormat in tagDef or as tagCtx.props.displayFormat\n  displayFormat: {\n    parse: function(value, props) {\n      return window.Globalize\n        ? Globalize.parseFloat(value, 10, props._culture)\n        : value;\n    },\n    format: function(value, props) {\n      return window.Globalize\n        ? Globalize.format(value, this.widget.options.numberFormat, props._culture)\n        : value;\n    }\n  },\n  options: function() {\n    var tag = this;\n    return {\n      spin: function(evt, ui) {\n        tag.updateValue(tag.widget._format(ui.value));\n      }\n    };\n  },\n  init: function(tagCtx) {\n    var dataFormat,\n      tag = this,\n      displayFormat = tagCtx.props.displayFormat;\n    tag.parse = function(value) {\n      return displayFormat.parse.call(tag, value, tag.tagCtx.props);\n    };\n    tag.format = function(value, props) {\n      return displayFormat.format.call(tag, value, tag.tagCtx.props);\n    };\n    if (displayFormat === undefined) {\n      displayFormat = tag.displayFormat;\n    }\n    tag.dataFormat = dataFormat = initFormatter(tag, tagCtx);\n    tag.baseApply(arguments);\n  },\n  onBeforeBind: function(tagCtx) {\n    var tag = this;\n    if (!tag.linkCtx.elem._jsvChg) {\n      // If change not triggered by the spinner itself changing value\n      tag.baseApply(arguments);\n      tag.displayElem = tag.mainElem.parent(); // jQuery UI wraps the input in a span\n      if (tagCtx.props.width) {\n        // In addition to generic setting of width on the\n        // displayElem, need also to set width on the input.\n        tag.mainElem.width(tagCtx.props.width - tag.displayElem.find(".ui-spinner-up").width()-9);\n      }\n    }\n  },\n  onBind: function(tagCtx) {\n    var tag = this,\n      cvt = getConverter(tag, tag.convert),\n      cvtBk = getConverter(tag, tag.convertBack);\n\n    tag.baseApply(arguments);\n\n    tag.convert = function(val) {\n      // Wrapped converter calls converter then does widget format\n      val = cvt ? cvt.call(tag, val) : val\n      val = tag.dataFormat ? +tag.parseData(val) : val;\n      return tag.widget._format(val);\n    };\n    tag.convertBack = function(val) {\n      // Wrapped converter, does widget parse then calls converter\n      val = tag.widget._parse(val);\n      val = tag.dataFormat ? tag.formatData(val) : val;\n      return cvtBk ? cvtBk.call(tag, val) : val;\n    };\n    // Prevent onAfterLink replacing wrapped converters with unwrapped ones\n    tag.convert.fix = tag.convertBack.fix = true;\n\n    tag.widget._parse = function(value) {\n      return value + "" === value && value\n        ? +tag.parse(value, tagCtx.props)\n        : value;\n    };\n    tag.widget._format = function(value) {\n      return value !== ""\n        ? tag.format(value, tagCtx.props)\n        : value;\n    };\n  }\n},\n// ============================= TIMESPINNER =============================\ntimespinner: {\n  baseTag: "spinner",\n  dataFormat: {\n    parse: function(value, props) {\n      return +value;\n    },\n    format: function(value, props) {\n      return new Date(value);\n    }\n  },\n  displayFormat: {\n    parse: function(value, props) {\n      var date;\n      if (value) {\n        return window.Globalize\n          ? Globalize.parseDate(value, "t", props._culture)\n          : ((date = new Date()).setHours(value.slice(0, 2), value.slice(3)), date);\n      }\n    },\n    format: function(value, props) {\n      if (value.getDay) {\n        return window.Globalize\n          ? Globalize.format(value, "t", props._culture)\n          : (100 + value.getHours() + "").slice(1) + ":" + (100 + value.getMinutes() + "").slice(1);\n      }\n    }\n  },\n  options: function() {\n    return $.extend(\n      this.baseApply(), // Get options object from base class and extend it\n      {step: 60000, page: 60}\n    );\n  },\n  init: function(tagCtx) {\n    this.baseApply(arguments);\n    this.tagCtx.props.width = this.tagCtx.props.width || 80;\n  },\n  onBind: function(tagCtx) {\n    var tag = this;\n    tag.baseApply(arguments);\n    tagCtx.props.trigger = false;\n\n    tag.widget._parse = function(value) {\n      if ("" + value === value && value) {\n        value = tag.parse(value, tagCtx.props);\n        if (value && !tag.keepDay) {\n          // Make return dateNumber (ticks) change the hours and minutes but keep current date (day/month)\n          var returnDate = new Date(tag.value);\n          returnDate.setHours(value.getHours());\n          returnDate.setMinutes(value.getMinutes());\n          value = returnDate;\n        }\n      }\n      return +value;\n    };\n    tag.widget._format = function(value) {\n      if (+value === value) {\n        tag.value = value;\n        return tag.format(new Date(value), tagCtx.props);\n      }\n    };\n  },\n  onAfterLink: function(tagCtx) {\n    var keepDay = tagCtx.props.keepDay;\n\n    if (keepDay !== undefined) {\n      this.keepDay = keepDay;\n    }\n    this.baseApply(arguments);\n  }\n},\n// ============================= TABS =============================\ntabs: {\n  baseTag: "widget",\n  widgetName: "tabs",\n  bindTo: 0,\n  elem: "div",\n  wrap: true,\n  setSize: true,\n  contentCtx: true,\n  options: tabsAccordionOptions,\n  onBind: tabsAccordionOnBind,\n  setValue: function(value) {\n    // Select the tab whose index is the currently selected one\n    this.widget.option("active", parseInt(value));\n  },\n  onBeforeBind: function(value) {\n    var anchor,\n      base = window.location.href.replace(/#.*$/, \'\');\n    $(\'ul>li>a[href^="#"]\', this.mainElem).each(function () {\r\n      anchor = $(this);\r\n      anchor.attr(\'href\', base + anchor.attr(\'href\'));\r\n    });\n    this.baseApply(arguments);\n  },\n  getValue: function() { // Helper: get the index of the currently selected tab\n    return this.widget.option("active");\n  }\n}\n\n};\n\n\n\n$.views.tags(tagDefs);\n\n// ============================= BUTTON AND BUTTONSET =============================\nif ($.ui.version.slice(0, 4) === "1.11") {\n  // Add backward compatibility for {{buttonset}} and {{button}}\n  tagDefs.button = {\n    baseTag: "widget",\n    widgetName: "button",\n    elem: "button",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx, linkCtx) {\n      var template,\n        tag = this,\n        content = tagCtx.tmpl,\n        props = tagCtx.props,\n        id = props.id,\n        parent = tag.parent;\n\n      if (tag._.radio = parent && parent.tagName === "buttonset") {\n        tagCtx = parent.tagCtx;\n      } else {\n        tag._.chkBx = (tag._.inline ? props : linkCtx.elem).type === "checkbox";\n      }\n\n      var  params = tagCtx.params,\n        paramprops = params.props || {};\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        content = content && content.markup || "&nbsp;";\n        // (&nbsp; fixes a jQueryUI button rendering issue)\n        if (tag._.radio || tag._.chkBx) {\n          id = id || "jsv" + Math.random();\n          template = \'<input id="\' + id + \'" data-link="\' + params.args[0] \n            + (paramprops.convert ? " convert=" + paramprops.convert : "")\n            + (paramprops.convertBack ? " convertBack=" + paramprops.convertBack : "")\n            + (tag._.radio\n              ? \'" name="\' + parent.id + \'" type="radio" value="\' + props.value + \n                \'"/><label for="\' + id + \'">\' + content + \'</label>\'\n              : \'" type="checkbox"/><label for="\' + id + \'">\' + content + \'</label>\');\n        } else {\n          template = "<button>" + content + "</button>";\n        }\n        tag.template = template;\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n\n      if (tag._.radio || tag._.chkBx) {\n        if (!tag._.inline) {\n          if (tag._.unlinked && !elem.id) {\n            elem.id = "jsv" + Math.random();\n            $(elem).after(\'<label for="\' + elem.id + \'">&nbsp;</label>\');\n          }\n          elem.checked = tag._.radio\n            ? (elem.name = tag.parent.id, val === elem.value)\n            : val && val !== "false";\n        }\n\n        tag.baseApply(arguments);\n\n        elem = tag.mainElem[0];\n\n        if (tag._.radio) {\n          // Use {^{button value="xxx"}}Label{{/button}}\n          if (elem.value === "undefined") {\n            // Default, for {^{button}}xxx{{/button}} or {^{button _label="xxx"/}}\n            elem.value = tag.widget.option("label"); \n          }\n          elem.checked = val === elem.value;\n        } else {\n          elem.checked = val && val !== "false";\n        }\n\n        if (tag._.chkBx) {\n          tag.widget.refresh();\n        }\n      } else {\n        if (!tag._.inline) {\n          elem.innerHTML = elem.innerHTML || "&nbsp;"; // Fixes jQuery UI button issue if no label text\n        }\n        tag.baseApply(arguments);\n      }\n    }\n  };\n\n  tagDefs.buttonset = {\n    baseTag: "widget",\n    widgetName: "buttonset",\n    setSize: true,\n    contentCtx: true,\n    init: function(tagCtx) {\n      var id,\n        tag = this;\n\n      tag.baseApply(arguments);\n\n      if (tag._.inline) {\n        tag.id = tagCtx.props.id || "jsv" + Math.random();\n        tag.template = \'<span id="\' + tag.id + \'">\' + tagCtx.tmpl.markup + "</span>";\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        elem = linkCtx.elem,\n        val = tag.bndArgs()[0];\n      tag.baseApply(arguments);\n      tag.widget.buttons.each(function(i, elem) {\n        elem.checked = val === elem.value;\n        $(elem).button("refresh");\n      });\n    }\n  };\n}\n\n// Compile tags\n$.views.tags(tagDefs);\n\nfunction unlinkedClone() {\n  // Ensure that cloned element (and its contents) created by jQuery UI to show dragging\n  // element does not have any data-jsv tokens (since deleting the element would then\n  // remove those views associated with the original element)\n  var clone = $(this).clone();\n  clone.find("*").addBack().removeAttr( "id data-link data-jsv data-jsv-df" );\n  clone.find("script").remove();\n  return clone;\n}\n\n// ============================= DRAGGABLE =============================\nif ($.ui.draggable) {\n  // Create derived draggable widget\n  $.widget("jsv.draggable", $.ui.draggable, {\n    _createHelper: function() {\n      if (this.options.helper === "clone") {\n        this.options.helper = unlinkedClone;\n      }\n      return this._super();\n    }\n  });\n\n  $.views.tags("draggable", {\n    baseTag: "widget",\n    widgetName: "jsv-draggable",\n    bindTo: ["left", "top"],\n    linkedCtxParam: ["left", "top"],\n    elem: "div",\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        drag: function(evt, ui) {\n          setTimeout(function() {\n            tag.updateValues(ui.offset.left, ui.offset.top);\n          },0);\n        }\n      };\n    },\n    setValue: function(value, index) {\n      this.mainElem.offset(index ? {top: value} : {left: value});\n    },\n    getValue: function(left, top) {\n      var offset = this.mainElem.offset();\n      return [offset.left, offset.top];\n    }\n  });\n}\n\n// ============================= ACCORDION =============================\nif ($.ui.accordion) {\n  // Create derived accordion widget\n  $.widget("jsv.accordion", $.ui.accordion, {\n    _create: function() {\n      var widget = this;\n      widget.options.header = widget.options.header.replace(":not(li):even", ":not(li,script):even");\n      widget._super();\n    }\n  });\n\n  $.views.tags("accordion", {\n    baseTag: "widget",\n    widgetName: "jsv-accordion",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: tabsAccordionOptions,\n    initOptions: ["header"], // Options which need to be set on creation, not later\n    onBind: tabsAccordionOnBind,\n    setValue: function(value) {\n      // Select the panel whose index is the currently selected one\n      this.widget.option("active", parseInt(value));\n    },\n    getValue: function() { // Helper: get the index of the currently selected panel\n      return this.widget.option("active");\n    }\n  });\n}\n\n// ============================= SORTABLE =============================\nif ($.ui.sortable) {\n  $.widget("jsv.sortable", $.ui.sortable, {\n    _create: function() {\n      var innerView, moveFrom,\n        widget = this,\n        startOption = widget.options.start,\n        stopOption = widget.options.stop;\n\n      widget.option({\n        start: function(event, ui) {\n          startOption && startOption.apply(this, arguments);\n\n          if (widget.option("bindArray") !== false) {\n            innerView = ui.item.view(); // The view of the item that is being dragged\n            if (innerView.type === "item") {\n              // The sortable items are within a {{for}} loop, so this is a data-linked sortable list\n              moveFrom = innerView.index + 1; // 1-based starting index of dragged item\n            }\n          }\n        },\n        stop: function(event, ui) {\n          var moveTo;\n\n          if (moveFrom) {\n            // This is a data-linked sortable list\n            moveTo = ui.item.prevAll(ui.item[0].tagName).length; // The new index after\n            // being dragged (count of previous siblings of same tagName)\n            widget.cancel(); // Now cancel the DOM changes, since we are data-driven,\n            // and should use JsViews data-linking to move the sorted items\n            $.observable(innerView.parent.data).move(moveFrom-1, moveTo); // Make the equivalent\n            // observable change to the underlying data\n            moveFrom = undefined;\n            // Remove the starting index, ready for new sorting actions on this sortable list\n          }\n          stopOption && stopOption.apply(this, arguments);\n        }\n      });\n      widget._super();\n    }\n  });\n\n  $.views.tags("sortable", {\n    baseTag: "widget",\n    widgetName: "jsv-sortable",\n    wrap: true,\n    contentCtx: true,\n  });\n}\n\n// ============================= SELECTABLE =============================\nif ($.ui.selectable) {\n  $.widget("jsv.selectable", $.ui.selectable, {\n    _create: function() {\n      var widget = this;\n\n      widget.options.filter += ":not(script)";\n      widget._super();\n    }\n  });\n\n  $.views.tags("selectable", {\n    baseTag: "widget",\n    widgetName: "jsv-selectable",\n    bindTo: 0,\n    wrap: true,\n    setSize: true,\n    contentCtx: true,\n    options: function() {\n      var tag = this;\n      return {\n        stop: function(evt, ui) {\n          tag.setSelectedItems();\n        }\n      };\n    },\n    initOptions: ["filter"], // Options which need to be set on creation, not later\n    onBind: function() {\n      var tag = this;\n      tag.selected = []; // Value of first arg (after applying converter, if there is one)\n\n      function selObs(ev, eventArgs) {\n        if (!eventArgs.refresh) {\n          tag.setSelection();\n        }\n      }\n\n      tag.selObs = selObs; // Store function instance, for disposing of just this binding, in onDispose\n      tag.baseApply(arguments);\n      tag.mainElem.on("jsv-domchange.sel", function() {\n        tag.widget.refresh();\n        tag.selected._domChg = 2;\n        tag.setSelectedItems();\n        tag.selected._domChg = undefined;\n      });\n    },\n    onDispose: function() {\n      $.unobserve(this.selected, this.selObs);  // Remove just this binding to selected array\n    },\n    setValue: function(selected) { // Set the new observed array of selected indices\n      var tag = this;\n      if ($.isArray(selected) && tag.selected !== selected) {\n        $.unobserve(tag.selected, tag.selObs);\n        tag.selected = selected;\n        if (selected !== tag.bndArgs[0]) {\n          tag.updateValue(selected);\n        }\n        $.observe(selected, tag.selObs);\n        tag.setSelection();\n      }\n    },\n    getValue: function() {\n      return this.selected;\n    },\n    setSelection: function() {\n      // Set the class on the new selected elements (based on tag.selected array of indices)\n      var tag = this,\n        l = tag.selected.length;\n      if (!tag.selected._domChg) {\n        // No need to update if during a domchange event - only if a selectable change event\n        // Remove selected class from all selectable elements\n        tag.widget.selectees.removeClass("ui-selected");\n        while (l--) {\n          // Set selected class on elements at indices in tag.selected array\n          tag.widget.selectees.eq(tag.selected[l]).addClass("ui-selected");\n        }\n      }\n    },\n    setSelectedItems: function() {\n      // Set observable selectedItems array based on selected elements managed by widget\n      var tag = this,\n        selected = [];\n      if (tag.selected && tag.selected._domChg !== 1) {\n        if (tag.selected._domChg) {\n          // Avoid race conditions when multiple selectables bind to same selected array\n          tag.selected._domChg--;\n        }\n        tag.widget.selectees.each(function(index, elem) {\n          if ((\' \' + elem.className + \' \').indexOf(\' ui-selected \') > -1) {\n            selected.push(index); // This is the index of a selected element\n          }\n        });\n        tag.setValue(tag.selected); // Update the tag to bind to the new selected array\n        $.observable(tag.selected).refresh(selected); // Refresh to the new selected indices\n      }\n    }\n  });\n}\n})(this, this.jQuery);\n\n/*! Sample JsViews tag control: {{validate}} control v0.9.84 (Beta)\nsee: http://www.jsviews.com/#download/sample-tagcontrols */\n/*\n * Copyright 2017, Boris Moore\n * Released under the MIT License.\n */\n\n(function($) {\n"use strict";\n\n  $.views.tags({\n  validation: {\n    init: function() {\n      this.childValidates = [];\n    },\n    validate: function() {\n      var l = this.childValidates.length,\n          result = true;\n      while (l-- && result !== false) {\n        result = this.childValidates[l].validate();\n      }\n      return result;\n    },\n    clearMessage: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].clearMessage();\n      }\n    },\n    refreshValidates: function() {\n      var l = this.childValidates.length;\n      while (l--) {\n        this.childValidates[l].refresh();\n      }\n    },\n    addChild: function(child) {\n      this.childValidates.push(child);\n    },\n    removeChild: function(child) {\n      var l = this.childValidates.length;\n      while (l--) {\n        if (this.childValidates[l] === child) {\n          this.childValidates.splice(l, 1);\n          this.updateIsValid();\n          break;\n        }\n      }\n    },\n    onChildValidate: function() {\n      this.updateIsValid();\n    },\n    updateIsValid: function() {\n      var groupIsValid = true,\n        l = this.childValidates.length;\n      while (l--) {\n        if (!this.childValidates[l].isValid) {\n          groupIsValid = false;\n          break;\n        }\n      }\n      $.observable(this).setProperty("isValid", groupIsValid);\n    },\n    isValid: true,\n    dataBoundOnly: true\n  },\n  validate: {\n    baseTag: "radiogroup",\n    linkedElement: "select,textarea,input",\n    boundProps: ["preventInvalidData"],\n    init: function(tagCtx, linkCtx) {\n      var tag = this;\n      if (tag.radiogroup = tagCtx.props.radiogroup) {\n        tag.baseApply(arguments);\n      } else if (tag._.inline && !tagCtx.content) {\n        tag.template = "<input/>";\n      }\n      tag.validationGroup = this.parents.validation;\n      if (tag.validationGroup) {\n        tag.validationGroup.addChild(this);\n      }\n    },\n    render: function(val) {\n      var ret,\n        tag = this,\n        tagCtx = this.tagCtx;\n      if (tag._.inline) {\n         // Keep same data context for content\n        ret = tagCtx.render(tagCtx.view, true);\n        // For radio buttons provide wrapper for validation messages\n        ret = tag.radiogroup ? ("<div>" + ret + "</div>") : ret;\n        return ret;\n      }\n    },\n    onBind: function(tagCtx, linkCtx) {\n      var targetTag,\n        tag = this,\n        target = tag.linkedElem && tag.linkedElem[0];\n\n      if (targetTag = tag.childTags()[0]) {\n        // {{validate}} may wrap another tag, such as {{slider}}\n        // or {{datepicker}} rather than an element such as <input/>\n        tag.targetTag = targetTag;\n        if (target && $.view(target).tag === targetTag) {\n          tag.linkedElem = undefined;\n        }\n        targetTag.onBeforeChange = function(ev, val) {\n          return tag.onBeforeChange.call(tag, ev, val);\n        };\n      }\n      if (tag.radiogroup) {\n        this.baseApply(arguments);\n      }\n    },\n    onAfterLink: function(tagCtx, linkCtx) {\n      var tag = this,\n        targetTag = tag.targetTag,\n        props = tagCtx.props,\n        arg0 = tag.cvtArgs()[0];\n\n      if (targetTag) {\n        targetTag.updateValue(arg0);\n      }\n\n      if (props.preventInvalidData !== undefined) {\n        tag.preventInvalidData = props.preventInvalidData;\n      } else if (tag.parents.validation) {\n        tag.preventInvalidData = tag.parents.validation.tagCtx.props.preventInvalidData;\n      }\n      if (!tag.messageElem || !tag.messageElem.parentNode) {\n        if (tag.radiogroup) {\n          // messageElem is the div which wraps the group of radio buttons and/or labels\n          tag.messageElem = tag._.inline ? tagCtx.contents("div") : $(linkCtx.elem);\n          tag.messageElem.addClass("radiogroup");\n        } else {\n          if (!tag._.inline && (targetTag = $.views.sub._glt(linkCtx.elem)[0])) {\n            // Scenario with data-link="{targetTag ...}{validate ...}" (both tags data-linked on same linkedElem)\n            tag.targetTag = targetTag;\n          }\n          tag.messageElem = targetTag && (targetTag.displayElem || targetTag.linkedElem)\n            || tag.displayElem || tag.linkedElem;\n        }\n        tag.messageElem.addClass("val-msg");\n      }\n\n      if (!tag.label || !tag.label.parentNode) {\n        tag.label = $("<label class=\\"error\\"></label><br/>").insertAfter(tag.messageElem)[0];\n      }\n      tag.validate(arg0); // Validate initial data\n    },\n    onUpdate: function(ev, eventArgs, tagCtxs) {\n      this.clearMessage();\n      return false; // don\'t rerender\n    },\n    onBeforeChange: function(ev, eventArgs) {\n      if (this.preventInvalidData) {\n        this.validate(eventArgs.value);\n        return this.isValid;\n        // Allow data to be updated to invalid values - unless preventInvalidData set to true\n      }\n    },\n    onDispose: function() {\n      if (this.validationGroup) {\n        this.validationGroup.removeChild(this);\n      }\n    },\n    validate: function(val) {\n      var message, linkedElem, testName, condition,\n        tag = this,\n        props = tag.tagCtx.props,\n        linkedElems = tag.linkedElem;\n\n      if (val === undefined) {\n        // If no val passed in, get current value from linkedElem, and validate that\n        if (tag._.radio && linkedElems) {\n          linkedElems = linkedElems.find("input:checked");\n        }\n        linkedElem = linkedElems && linkedElems[0];\n        val = "";\n        if (linkedElem) {\n          val = linkedElem.type === "checkbox" ? linkedElem.checked : linkedElem.value;\n        } else if (tag.targetTag) {\n          val = tag.targetTag.bndArgs()[0];\n        }\n        val = val || "";\n      }\n      tag.clearMessage();\n\n      // Test the validation conditions, one after the other.\n      this.isValid = true;\n      for (var validator in this.validators) {\n        condition = props[validator];\n        if (condition !== undefined && this.validators[validator].test(condition, val)) {\n          testName = validator;\n          this.isValid = false;\n          break;\n        }\n      }\n      if (!this.isValid) {// A test failed. Show message for first failed test.\n        message = props["msg_" + testName] || this.validators[testName].message;\n        if ($.isFunction(message)) {\n          message = message(condition, val);\n        }\n        message = message.replace(/%cond%/g, condition).replace(/%val%/g, val)\n        if (tag.label.textContent !== undefined) {\n          tag.label.textContent = message;\n        } else {\n          tag.label.innerText = message; // Older IE does not support textContent\n        }\n        tag.messageElem.addClass("invalid");\n      }\n      if (this.validationGroup) {\n        this.validationGroup.onChildValidate();\n      }\n      return this.isValid;\n    },\n    validators: function(validators) {\n      for (var validator in validators) {\n        this.validators[validator] = validators[validator];\n      }\n    },\n    clearMessage: function() {\n      // Clear previous message.\n      var tag = this,\n        label = tag.label;\n      if (tag.messageElem) {\n        tag.messageElem.removeClass("invalid");\n        if (label.textContent !== undefined) {\n          label.textContent = "";\n        } else {\n          label.innerText = ""; // Older IE does not support textContent\n        }\n      }\n    }\n}\n});\n\n$.views.tags.validate.validators({\n  required: {\n    message: "Please provide a value",\n    test: function(condition, val) {\n      return condition && val === "";\n    }\n  },\n  equal: {\n    message: "Value must be %cond%",\n    test: function(condition, val) {\n      return val !== "" + condition;\n    }\n  },\n  checked: {\n    message: function(condition, val) {\n      return "Must be " + (condition ? "checked" : "unchecked");\n    },\n    test: function(condition, val) {\n      return (val && val !== "false") !== condition;\n    }\n  },\n  min: {\n    message: "Minimum: %cond%",\n    test: function(condition, val) {\n      return val < condition;\n    }\n  },\n  max: {\n    message: "Maximum:  %cond%",\n    test: function(condition, val) {\n      return val > condition;\n    }\n  },\n  maxLength: {\n    message: "Maximum length: %cond%",\n    test: function(condition, val) {\n      return val.length > condition;\n    }\n  },\n  minLength: {\n    message: "Minimum length: %cond%",\n    test: function(condition, val) {\n      return val.length < condition;\n    }\n  },\n  regex: {\n    message: "Invalid string format",\n    test: function(condition, val) {\n      var regex = condition.test ? condition : new RegExp(condition);\n      return !regex.test(val);\n    }\n  }\n});\n\n})(this.jQuery);\n\n"use strict";\nvar pageTmpl = $.templates("#pageTmpl"),\n  pageOptions = {\n    inRangeOnly: true\n  },\n  model = {\n    amount: 550,\n    currency: "de-DE"\n  };\n\npageTmpl.link("#page", model, {page: pageOptions});\n<style>\r\n  .slider {margin-left: 60px; width: 450px;}\r\n  .spinner.invalid {margin: 7px;}\r\n</style>\r\n\r\n<script id="pageTmpl" type="text/x-jsrender">\r\n\r\nAmount: {^{:amount}}<br/>\r\n\r\nEnforce in-range amount:\r\n<input type="checkbox" data-link="~page.inRangeOnly" /><br/><br/>\r\n\r\n{^{slider amount\r\n  ^_min=~page.inRangeOnly ? 500 : 25\r\n  ^_max=~page.inRangeOnly ? 1500 : 2000\r\n  _range=\'min\'\r\n  class="slider"\r\n/}}<br/><br/>\r\n\r\n<label for="amount">Amount to donate:</label>\r\n\r\n{^{validate amount\r\n  messagewrap=true\r\n  min=500\r\n  max=1500\r\n  msg_min="Minimum amount: %cond%"\r\n  msg_max="Maximum amount: %cond%"\r\n  preventInvalidData=~page.inRangeOnly\r\n}}\r\n  {^{spinner amount\r\n    ^_culture=currency \r\n    _numberFormat="C"\r\n    _min=25\r\n    _max=2000\r\n    _step=25\r\n    _page=4\r\n    name="amount"\r\n    class="spinner"\r\n    width=110\r\n  /}}\r\n{{/validate}}\r\n\r\n<label for="currency">Currency to donate</label>\r\n\r\n<select data-link="currency" name="currency">\r\n  <option value="en-US">US $</option>\r\n  <option value="de-DE">EUR €</option>\r\n  <option value="ja-JP">YEN ¥</option>\r\n</select>\r\n\r\n</script>\r\n\r\n<div id="page"></div>\n'
}]}};
//# sourceMappingURL=find-samples.min.js.map
