{"version":3,"sources":["jquery.observable.js"],"names":["factory","define","amd","this","jQuery","$","getCbKey","cb","_cId","observeCbKey","$observable","data","$isArray","ArrayObservable","ObjectObservable","_data","wrapArray","resolvePathObjects","paths","root","i","path","object","nextObj","l","length","out","$isFunction","concat","call","push","removeCbBindings","cbBindings","cbBindingsId","cbBindingsStore","undefined","onObservableChange","ev","eventArgs","isOb","val","OBJECT","allowArray","off","allPath","filter","parentObs","oldValue","value","ctx","observeAll","noArray","type","arrayChangeStr","array","prop","_path","target","parents","observe_apply","ns","$observe","innerObserve","observeOnOff","namespace","pathStr","isArrayBinding","j","evData","obIdExpando","$hasData","boundObOrArr","prntObs","allPth","initialNs","unobserve","events","propertyChangeStr","el","callback","fullPath","replace","all","inArray","on","observeObjKey","getInnerCb","exprOb","origRt","ob","contextCb","obj","sub","sb","newObj","bindArray","arr","unbind","isArray","relPath","prevObj","prevAllPath","_fltr","cbId","p","skip","parts","dep","items","depth","innerCb","initNsArr","initNsArrLen","observeStr","apply","arguments","slice","lastArg","pop","shift","_inId","match","rNotWhite","split","join","splice","_jsv","observeInnerCbKey","bnd","prm","origRoot","nodeType","depends","$unobserve","args","$observeAll","$unobserveAll","observeArray","unobs","newAllPath","filterAndObserveAll","nestedArray","newObject","newParentObs","$expando","nextParentObs","updatedTgt","unshift","wrappedCb","change","oldItems","isObject","shallowFilter","indexOf","versionNumber","requiresStr","observable","$eventSpecial","event","special","$views","views","jsviews","$sub","isFunction","expando","PARSEINT","parseInt","propChng","arrChng","_cbBnds","hasData","remove","getDeps","arg","deps","set","Object","Array","observe","_apply","prototype","unobserveAll","setProperty","nonStrict","key","pair","self","name","_setProperty","removeProperty","leaf","setter","getter","removeProp","property","Date","_trigger","triggerHandler","insert","index","_insert","oldLength","numToRemove","_remove","move","oldIndex","newIndex","numToMove","_move","refresh","newItems","_refresh","$data","handleObj","found","map","mapDef","Map","source","options","changing","src","unmap","tgt","update","obsSrc","obs","srcFlt","obsTgt","obt","tgtFlt","getTgt","baseMap","extend","_def","constructor"],"mappings":"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","file":"jquery.observable.min.js","sourcesContent":["/*! JsObservable v1.0.0-alpha: http://www.jsviews.com/#jsobservable\r\ninformal pre V1.0 commit counter: 64 (Beta Candidate)*/\r\n/*\r\n * Subcomponent of JsViews\r\n * Data change events for data-linking\r\n *\r\n * Copyright 2015, Boris Moore\r\n * Released under the MIT License.\r\n */\r\n\r\n//jshint -W018, -W041\r\n\r\n(function (factory) {\r\n\tif (typeof define === \"function\" && define.amd) {\r\n\t\t// Loading from AMD script loader. Register as an anonymous module.\r\n\t\tdefine([\"jquery\"], factory);\r\n\t} else {\r\n\t\t// Browser using plain <script> tag\r\n\t\tfactory(this.jQuery);\r\n\t}\r\n} (function($) {\r\n\t\"use strict\";\r\n\r\n\t//========================== Top-level vars ==========================\r\n\r\n\tvar versionNumber = \"v1.0.0-alpha\",\r\n\t\trequiresStr = \"JsViews requires \";\r\n\r\n\tif (!$) {\r\n\t\t// jQuery is not loaded.\r\n\t\tthrow requiresStr + \"jQuery\"; // We require jQuery\r\n\t}\r\n\r\n\tif ($.observable) { return $; } // JsObservable is already loaded\r\n\r\n\tvar $eventSpecial = $.event.special,\r\n\t\t$views = $.views =\r\n\t\t\t$.views // jsrender was loaded before jquery.observable\r\n\t\t\t|| { // jsrender not loaded so set up $.views and $.views.sub here, and merge back in jsrender if loaded afterwards\r\n\t\t\t\tjsviews: versionNumber,\r\n\t\t\t\tsub: {}\r\n\t\t\t},\r\n\t\t$sub = $views.sub,\r\n\t\t$isFunction = $.isFunction,\r\n\t\t$isArray = $.isArray,\r\n\t\tOBJECT = \"object\",\r\n\t\tslice = [].slice,\r\n\t\tsplice = [].splice,\r\n\t\tconcat = [].concat,\r\n\t\t$expando = $.expando,\r\n\t\tPARSEINT = parseInt,\r\n\t\trNotWhite = /\\S+/g,\r\n\t\tpropertyChangeStr = $sub.propChng = $sub.propChng || \"propertyChange\",// These two settings can be overridden on settings after loading\r\n\t\tarrayChangeStr = $sub.arrChng = $sub.arrChng || \"arrayChange\",        // jsRender, and prior to loading jquery.observable.js and/or JsViews\r\n\t\tcbBindingsStore = $sub._cbBnds = $sub._cbBnds || {},\r\n\t\tobserveStr = propertyChangeStr + \".observe\",\r\n\t\tobserveObjKey = 1,\r\n\t\tobserveCbKey = 1,\r\n\t\tobserveInnerCbKey = 1,\r\n\t\t$hasData = $.hasData,\r\n\t\tremove = {}; // flag for removeProperty\r\n\r\n\t//========================== Top-level functions ==========================\r\n\r\n\tfunction getCbKey(cb) {\r\n\t\treturn cb._cId = cb._cId || (\".obs\" + observeCbKey++);\r\n\t}\r\n\r\n\t$sub.getDeps = function() {\r\n\t\tvar args = arguments;\r\n\t\treturn function() {\r\n\t\t\tvar arg, dep,\r\n\t\t\t\tdeps = [],\r\n\t\t\t\tl = args.length;\r\n\t\t\twhile (l--) {\r\n\t\t\t\targ = args[l--];\r\n\t\t\t\tdep = args[l];\r\n\t\t\t\tif (dep) {\r\n\t\t\t\t\tdeps = deps.concat($isFunction(dep) ? dep(arg, arg) : dep);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn deps;\r\n\t\t};\r\n\t};\r\n\r\n\tfunction $observable(data) {\r\n\t\treturn $isArray(data)\r\n\t\t\t? new ArrayObservable(data)\r\n\t\t\t: new ObjectObservable(data);\r\n\t}\r\n\r\n\tfunction ObjectObservable(data) {\r\n\t\tthis._data = data;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tfunction ArrayObservable(data) {\r\n\t\tthis._data = data;\r\n\t\treturn this;\r\n\t}\r\n\r\n\tfunction wrapArray(data) {\r\n\t\treturn $isArray(data)\r\n\t\t\t? [data]\r\n\t\t\t: data;\r\n\t}\r\n\r\n\tfunction resolvePathObjects(paths, root) {\r\n\t\tpaths = $isArray(paths) ? paths : [paths];\r\n\r\n\t\tvar i, path,\r\n\t\t\tobject = root,\r\n\t\t\tnextObj = object,\r\n\t\t\tl = paths.length,\r\n\t\t\tout = [];\r\n\r\n\t\tfor (i = 0; i < l; i++) {\r\n\t\t\tpath = paths[i];\r\n\t\t\tif ($isFunction(path)) {\r\n\t\t\t\tout = out.concat(resolvePathObjects(path.call(root, root), root));\r\n\t\t\t\tcontinue;\r\n\t\t\t} else if (\"\" + path !== path) {\r\n\t\t\t\troot = nextObj = path;\r\n\t\t\t\tif (nextObj !== object) {\r\n\t\t\t\t\tout.push(object = nextObj);\r\n\t\t\t\t}\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (nextObj !== object) {\r\n\t\t\t\tout.push(object = nextObj);\r\n\t\t\t}\r\n\t\t\tout.push(path);\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n\tfunction removeCbBindings(cbBindings, cbBindingsId) {\r\n\t\t// If the cbBindings collection is empty we will remove it from the cbBindingsStore\r\n\t\tfor (var cb in cbBindings) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcbBindingsStore[cbBindingsId] = undefined; // This binding collection is empty, so remove from store\r\n\t}\r\n\r\n\tfunction onObservableChange(ev, eventArgs) {\r\n\t\tfunction isOb(val) {\r\n\t\t\treturn typeof val === OBJECT && (paths[0] || allowArray && $isArray(val));\r\n\t\t}\r\n\r\n\t\tif (!(ev.data && ev.data.off)) {\r\n\t\t\t// Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)\r\n\t\t\tvar allPath, filter, parentObs,\r\n\t\t\t\toldValue = eventArgs.oldValue,\r\n\t\t\t\tvalue = eventArgs.value,\r\n\t\t\t\tctx = ev.data,\r\n\t\t\t\tobserveAll = ctx.observeAll,\r\n\t\t\t\tallowArray = !ctx.cb.noArray,\r\n\t\t\t\tpaths = ctx.paths;\r\n\r\n\t\t\tif (ev.type === arrayChangeStr) {\r\n\t\t\t\t(ctx.cb.array || ctx.cb).call(ctx, ev, eventArgs); // If there is an arrayHandler expando on the regular handler, use it, otherwise use the regular handler for arrayChange events also - for example: $.observe(array, handler)\r\n\t\t\t\t// or observeAll() with an array in the graph. Note that on data-link bindings we ensure always to have an array handler - $.noop if none is specified e.g. on the data-linked tag.\r\n\t\t\t} else if (ctx.prop === eventArgs.path || ctx.prop === \"*\") {\r\n\t\t\t\tif (observeAll) {\r\n\t\t\t\t\tallPath = observeAll._path + \".\" + eventArgs.path;\r\n\t\t\t\t\tfilter = observeAll.filter;\r\n\t\t\t\t\tparentObs = [ev.target].concat(observeAll.parents());\r\n\r\n\t\t\t\t\tif (isOb(oldValue)) {\r\n\t\t\t\t\t\tobserve_apply(allowArray, observeAll.ns, [oldValue], paths, ctx.cb, true, filter, [parentObs], allPath); // unobserve\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isOb(value)) {\r\n\t\t\t\t\t\tobserve_apply(allowArray, observeAll.ns, [value], paths, ctx.cb, undefined, filter, [parentObs], allPath);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (isOb(oldValue)) { // oldValue is an object, so unobserve\r\n\t\t\t\t\t\tobserve_apply(allowArray, [oldValue], paths, ctx.cb, true); // unobserve\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isOb(value)) { // value is an object, so observe\r\n\t\t\t\t\t\tobserve_apply(allowArray, [value], paths, ctx.cb);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tctx.cb(ev, eventArgs);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction $observe() {\r\n\t\t// $.observe([namespace, ]root, [1 or more objects, path or path Array params...], callback[, contextCallback][, unobserve])\r\n\r\n\t\tfunction innerObserve() {\r\n\r\n\t\t\tfunction observeOnOff(namespace, pathStr, isArrayBinding, off) {\r\n\t\t\t\tvar j, evData,\r\n\t\t\t\t\tobIdExpando = $hasData(object),\r\n\t\t\t\t\tboundObOrArr = wrapArray(object),\r\n\t\t\t\t\tprntObs = parentObs,\r\n\t\t\t\t\tallPth = allPath;\r\n\r\n\t\t\t\tnamespace = initialNs ? namespace + \".\" + initialNs : namespace;\r\n\r\n\t\t\t\tif (unobserve || off) {\r\n\t\t\t\t\tif (obIdExpando) {\r\n\t\t\t\t\t\t$(boundObOrArr).off(namespace, onObservableChange);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (events = obIdExpando && $._data(object)) {\r\n\t\t\t\t\t\tevents = events && events.events;\r\n\t\t\t\t\t\tevents = events && events[isArrayBinding ? arrayChangeStr : propertyChangeStr];\r\n\t\t\t\t\t\tel = events && events.length;\r\n\r\n\t\t\t\t\t\twhile (el--) {\r\n\t\t\t\t\t\t\tif ((data = events[el].data) && data.cb._cId === callback._cId && data.ns === initialNs) {\r\n\t\t\t\t\t\t\t\tif (isArrayBinding) {\r\n\t\t\t\t\t\t\t\t\t// Duplicate exists, so skip. (This can happen e.g. with {^{for people ~foo=people}})\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t} else if (pathStr === \"*\" && data.prop !== pathStr) {\r\n\t\t\t\t\t\t\t\t\t$(object).off(namespace, onObservableChange);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tevData = isArrayBinding ? {}\r\n\t\t\t\t\t\t: {\r\n\t\t\t\t\t\t\tfullPath: path,\r\n\t\t\t\t\t\t\tpaths: pathStr ? [pathStr] : [],\r\n\t\t\t\t\t\t\tprop: prop\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\tevData.ns = initialNs;\r\n\t\t\t\t\tevData.cb = callback;\r\n\r\n\t\t\t\t\tif (allPath) {\r\n\t\t\t\t\t\t// This is an observeAll call\r\n\t\t\t\t\t\tevData.observeAll = {\r\n\t\t\t\t\t\t\t_path: allPth,\r\n\t\t\t\t\t\t\tpath: function() { // Step through path and parentObs parent chain, replacing '[]' by '[n]' based on current index of objects in parent arrays.\r\n\t\t\t\t\t\t\t\tj = prntObs.length;\r\n\t\t\t\t\t\t\t\treturn allPth.replace(/[[.]/g, function(all) {\r\n\t\t\t\t\t\t\t\t\tj--;\r\n\t\t\t\t\t\t\t\t\treturn all === \"[\"\r\n\t\t\t\t\t\t\t\t\t\t? \"[\" + $.inArray(prntObs[j - 1], prntObs[j])\r\n\t\t\t\t\t\t\t\t\t\t: \".\";\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tparents: function() {\r\n\t\t\t\t\t\t\t\treturn prntObs; // The chain of parents between the modified object and the root object used in the observeAll() call\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tfilter: filter,\r\n\t\t\t\t\t\t\tns: initialNs\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t\t$(boundObOrArr).on(namespace, null, evData, onObservableChange);\r\n\t\t\t\t\tif (cbBindings) {\r\n\t\t\t\t\t\t// Add object to cbBindings, and add the counter to the jQuery data on the object\r\n\t\t\t\t\t\t(cbBindingsStore[callback._cId] = cbBindings) // In some scenarios cbBindings was empty and removed\r\n\t\t\t\t\t\t\t//from store - so defensively add back to store, to ensure correct disposal e.g. when views are removed\r\n\t\t\t\t\t\t\t[$.data(object, \"obId\") || $.data(object, \"obId\", observeObjKey++)] = object;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfunction getInnerCb(exprOb) {\r\n\t\t\t\t// Returns the innerCb used for updating a computed in a compiled expression (setting the new instance as exprOb.ob, unobserving the previous object,\r\n\t\t\t\t// and observing the new one), then calling the outerCB - i.e. the handler for the whole compiled expression.\r\n\t\t\t\t// Initialized exprOb.ob to the current object.\r\n\t\t\t\t// Uses the contextCb callback to execute the compiled exprOb template in the context of the view/data etc. to get the returned value, typically an object or array.\r\n\t\t\t\t// If it is an array, registers array binding\r\n\t\t\t\tvar origRt = root;\r\n\t\t\t\t// Note:  For https://github.com/BorisMoore/jsviews/issues/292ctxCb will need var ctxCb = contextCb || function(exprOb, origRt) {return exprOb._jsv(origRt);};\r\n\r\n\t\t\t\texprOb.ob = contextCb(exprOb, origRt); // Initialize object\r\n\r\n\t\t\t\treturn exprOb.cb = function(ev, eventArgs) {\r\n\t\t\t\t\tvar obj = exprOb.ob, // The old object\r\n\t\t\t\t\t\tsub = exprOb.sb,\r\n\t\t\t\t\t\tnewObj = contextCb(exprOb, origRt);\r\n\r\n\t\t\t\t\tif (newObj !== obj) {\r\n\t\t\t\t\t\tif (typeof obj === OBJECT) {\r\n\t\t\t\t\t\t\tbindArray(obj, true);\r\n\t\t\t\t\t\t\tif (sub || allowArray && $isArray(obj)) {\r\n\t\t\t\t\t\t\t\tinnerObserve([obj], sub, callback, contextCb, true); // unobserve on the old object\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\texprOb.ob = newObj;\r\n\t\t\t\t\t\t// Put the updated object instance onto the exprOb in the paths array, so subsequent string paths are relative to this object\r\n\t\t\t\t\t\tif (typeof newObj === OBJECT) {\r\n\t\t\t\t\t\t\tbindArray(newObj);\r\n\t\t\t\t\t\t\tif (sub || allowArray && $isArray(newObj)) {\r\n\t\t\t\t\t\t\t\t// Register array binding\r\n\t\t\t\t\t\t\t\tinnerObserve([newObj], sub, callback, contextCb);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Call the outerCb - to execute the compiled expression that this computed is part of\r\n\t\t\t\t\tcallback(ev, eventArgs);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tfunction bindArray(arr, unbind, isArray, relPath) {\r\n\t\t\t\tif (allowArray) {\r\n\t\t\t\t\t// This is a call to observe that does not come from observeAndBind (tag binding), so we allow arrayChange binding\r\n\t\t\t\t\tvar prevObj = object,\r\n\t\t\t\t\t\tprevAllPath = allPath;\r\n\r\n\t\t\t\t\tobject = arr;\r\n\t\t\t\t\tif (relPath) {\r\n\t\t\t\t\t\tobject = arr[relPath];\r\n\t\t\t\t\t\tallPath += \".\" + relPath;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (filter && object) {\r\n\t\t\t\t\t\tobject = $observable._fltr(allPath, object, relPath ? [arr].concat(parentObs) : parentObs, filter);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (object && (isArray || $isArray(object))) {\r\n\t\t\t\t\t\tobserveOnOff(arrayChangeStr + \".observe\" + (callback ? (cbId = getCbKey(callback)) : \"\"), undefined, true, unbind);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tobject = prevObj;\r\n\t\t\t\t\tallPath = prevAllPath;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar i, p, skip, parts, prop, path, dep, unobserve, callback, cbId, el, data, events, contextCb, items, cbBindings, depth, innerCb, parentObs,\r\n\t\t\t\tallPath, filter, initNsArr, initNsArrLen,\r\n\t\t\t\tns = observeStr,\r\n\t\t\t\tpaths = this != 1 // Using != for IE<10 bug- see https://github.com/BorisMoore/jsviews/issues/237\r\n\t\t\t\t\t? concat.apply([], arguments) // Flatten the arguments - this is a 'recursive call' with params using the 'wrapped array'\r\n\t\t\t\t\t\t\t\t\t\t\t\t   // style - such as innerObserve([object], path.path, [origRoot], path.prm, innerCb, ...);\r\n\t\t\t\t\t: slice.call(arguments),   // Don't flatten - this is the first 'top-level call, to innerObserve.apply(1, paths)\r\n\t\t\t\tlastArg = paths.pop() || false,\r\n\t\t\t\troot = paths.shift(),\r\n\t\t\t\tobject = root,\r\n\t\t\t\tl = paths.length;\r\n\r\n\t\t\tif (lastArg + \"\" === lastArg) { // If last arg is a string then this observe call is part of an observeAll call,\r\n\t\t\t\tallPath = lastArg;          // and the last three args are the parentObs array, the filter, and the allPath string.\r\n\t\t\t\tparentObs = paths.pop();\r\n\t\t\t\tfilter = paths.pop();\r\n\t\t\t\tlastArg = !!paths.pop(); // unobserve\r\n\t\t\t\tl -= 3;\r\n\t\t\t}\r\n\t\t\tif (lastArg === !!lastArg) {\r\n\t\t\t\tunobserve = lastArg;\r\n\t\t\t\tlastArg = paths[l-1];\r\n\t\t\t\tlastArg = l && lastArg + \"\" !== lastArg ? (l--, paths.pop()) : undefined;\r\n\t\t\t}\r\n\t\t\tcallback = lastArg;\r\n\t\t\tif (l && $isFunction(paths[l - 1])) {\r\n\t\t\t\tcontextCb = callback;\r\n\t\t\t\tcallback = paths.pop();\r\n\t\t\t\tl--;\r\n\t\t\t}\r\n\r\n\t\t\t// Use a unique namespace (e.g. obs7) associated with each observe() callback to allow unobserve to remove handlers\r\n\t\t\tns += unobserve\r\n\t\t\t\t? (callback ? callback._cId + (callback._inId || \"\"): \"\")\r\n\t\t\t\t: (cbId = getCbKey(callback)) + (callback._inId || \"\");\r\n\t\t\tif (!unobserve) {\r\n\t\t\t\tcbBindings = cbBindingsStore[cbId] = cbBindingsStore[cbId] || {};\r\n\t\t\t}\r\n\r\n\t\t\tinitNsArr = initialNs && initialNs.match(rNotWhite) || [\"\"];\r\n\t\t\tinitNsArrLen = initNsArr.length;\r\n\r\n\t\t\twhile (initNsArrLen--) {\r\n\t\t\t\tinitialNs = initNsArr[initNsArrLen];\r\n\r\n\t\t\t\tif ($isArray(root)) {\r\n\t\t\t\t\tbindArray(root, unobserve, true);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// remove onObservableChange handlers that wrap that callback\r\n\t\t\t\t\tif (unobserve && l === 0 && root) {\r\n\t\t\t\t\t\tobserveOnOff(ns, \"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tdepth = 0;\r\n\t\t\t\tfor (i = 0; i < l; i++) {\r\n\t\t\t\t\tpath = paths[i];\r\n\t\t\t\t\tif (path === \"\" || path === undefined) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tobject = root;\r\n\t\t\t\t\tif (\"\" + path === path) {\r\n\t\t\t\t\t\t// Consider support for computed paths: https://github.com/BorisMoore/jsviews/issues/292\r\n\t\t\t\t\t\t//if (/[\\(\\[\\+]/.test(path)) {\r\n\t\t\t\t\t\t//\tvar b={links:{}}, t = $sub.tmplFn(\"{:\"+path+\"}\", b, true), items = t.paths[0];\r\n\t\t\t\t\t\t//\tl += items.length - 1;\r\n\t\t\t\t\t\t//\tsplice.apply(paths, [i--, 1].concat(items));\r\n\t\t\t\t\t\t//\tcontinue;\r\n\t\t\t\t\t\t//}\r\n\t\t\t\t\t\tparts = path.split(\"^\");\r\n\t\t\t\t\t\tif (parts[1]) {\r\n\t\t\t\t\t\t\t// We bind the leaf, plus additional nodes based on depth.\r\n\t\t\t\t\t\t\t// \"a.b.c^d.e\" is depth 2, so listens to changes of e, plus changes of d and of c\r\n\t\t\t\t\t\t\tdepth = parts[0].split(\".\").length;\r\n\t\t\t\t\t\t\tpath = parts.join(\".\");\r\n\t\t\t\t\t\t\tdepth = path.split(\".\").length - depth;\r\n\t\t\t\t\t\t\t// if more than one ^ in the path, the first one determines depth\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (contextCb && (items = contextCb(path, root))) {\r\n\t\t\t\t\t\t\t// If contextCb returns an array of objects and paths, we will insert them\r\n\t\t\t\t\t\t\t// into the sequence, replacing the current item (path)\r\n\t\t\t\t\t\t\tl += items.length - 1;\r\n\t\t\t\t\t\t\tsplice.apply(paths, [i--, 1].concat(items));\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tparts = path.split(\".\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (!$isFunction(path)) {\r\n\t\t\t\t\t\t\tif (path && path._jsv) {\r\n\t\t\t\t\t\t\t\t// This is a compiled function for binding to an object returned by a helper/data function.\r\n\t\t\t\t\t\t\t\t// Set current object on exprOb.ob, and get innerCb for updating the object\r\n\t\t\t\t\t\t\t\tinnerCb = unobserve ? path.cb : getInnerCb(path);\r\n\t\t\t\t\t\t\t\tinnerCb.noArray = !allowArray;\r\n\t\t\t\t\t\t\t\tinnerCb._cId = callback._cId;\r\n\t\t\t\t\t\t\t\t// Set the same cbBindingsStore key as for callback, so when callback is disposed, disposal of innerCb happens too.\r\n\t\t\t\t\t\t\t\tinnerCb._inId = innerCb._inId || \".obIn\" + observeInnerCbKey++;\r\n\t\t\t\t\t\t\t\tif (path.bnd || path.prm && path.prm.length || !path.sb) {\r\n\t\t\t\t\t\t\t\t\t// If the exprOb is bound e.g. foo()^sub.path, or has parameters e.g. foo(bar) or is a leaf object (so no sub path) e.g. foo()\r\n\t\t\t\t\t\t\t\t\t// then observe changes on the object, or its parameters and sub-path\r\n\t\t\t\t\t\t\t\t\tinnerObserve([object], path.path, [origRoot], path.prm, innerCb, contextCb, unobserve);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (path.sb) { // subPath\r\n\t\t\t\t\t\t\t\t\tinnerObserve([path.ob], path.sb, callback, contextCb, unobserve);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tpath = origRoot;\r\n\t\t\t\t\t\t\t\tobject = undefined;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tobject = path; // For top-level calls, objects in the paths array become the origRoot for subsequent paths.\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tparts = [root = path];\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile (object && (prop = parts.shift()) !== undefined) {\r\n\t\t\t\t\t\tif (typeof object === OBJECT) {\r\n\t\t\t\t\t\t\tif (\"\" + prop === prop) {\r\n\t\t\t\t\t\t\t\tif (prop === \"\") {\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif ((parts.length < depth + 1) && !object.nodeType) {\r\n\t\t\t\t\t\t\t\t\t// Add observer for each token in path starting at depth, and on to the leaf\r\n\t\t\t\t\t\t\t\t\tif (!unobserve && (events = $hasData(object) && $._data(object))) {\r\n\t\t\t\t\t\t\t\t\t\tevents = events.events;\r\n\t\t\t\t\t\t\t\t\t\tevents = events && events[propertyChangeStr];\r\n\t\t\t\t\t\t\t\t\t\tel = events && events.length;\r\n\t\t\t\t\t\t\t\t\t\tskip = 0;\r\n\t\t\t\t\t\t\t\t\t\twhile (el--) { // Skip duplicates\r\n\t\t\t\t\t\t\t\t\t\t\tdata = events[el].data;\r\n\t\t\t\t\t\t\t\t\t\t\tif (data && data.cb === callback && data.ns === initialNs) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (data.prop === prop || data.prop === \"*\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (p = parts.join(\".\")) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdata.paths.push(p); // We will skip this binding, but if it is not a leaf binding,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// need to keep bindings for rest of path, ready for if the object gets swapped.\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tskip++;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif (skip) {\r\n\t\t\t\t\t\t\t\t\t\t\t// Duplicate binding(s) found, so move on\r\n\t\t\t\t\t\t\t\t\t\t\tobject = object[prop];\r\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (prop === \"*\") {\r\n\t\t\t\t\t\t\t\t\t\tif (!unobserve && events && events.length) {\r\n\t\t\t\t\t\t\t\t\t\t\t// Remove existing bindings, since they will be duplicates with \"*\"\r\n\t\t\t\t\t\t\t\t\t\t\tobserveOnOff(ns, \"\", false, true);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tobserveOnOff(ns, \"\"); // observe the object for any property change\r\n\t\t\t\t\t\t\t\t\t\tfor (p in object) {\r\n\t\t\t\t\t\t\t\t\t\t\t// observing \"*\": So (in addition to listening to prop change, above) listen to arraychange on props of type array\r\n\t\t\t\t\t\t\t\t\t\t\tbindArray(object, unobserve, undefined, p);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t} else if (prop) {\r\n\t\t\t\t\t\t\t\t\t\tobserveOnOff(ns + \".\" + prop, parts.join(\"^\")); // By using \"^\" rather than \".\" we ensure that deep binding will be used on newly inserted object graphs\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (allPath) {\r\n\t\t\t\t\t\t\t\t\tallPath += \".\" + prop;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprop = object[prop];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif ($isFunction(prop)) {\r\n\t\t\t\t\t\t\t\tif (dep = prop.depends) {\r\n\t\t\t\t\t\t\t\t\t// This is a computed observable. We will observe any declared dependencies\r\n\t\t\t\t\t\t\t\t\tinnerObserve([object], resolvePathObjects(dep, object), callback, contextCb, unobserve);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tobject = prop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbindArray(object, unobserve);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (cbId) {\r\n\t\t\t\tremoveCbBindings(cbBindings, cbId);\r\n\t\t\t}\r\n\r\n\t\t\t// Return the cbBindings to the top-level caller, along with the cbId\r\n\t\t\treturn { cbId: cbId, bnd: cbBindings };\r\n\t\t}\r\n\r\n\t\tvar initialNs,\r\n\t\t\tallowArray = this != false, // If this === false, this is a call from observeAndBind - doing binding of datalink expressions. We don't bind\r\n\t\t\t// arrayChange events in this scenario. Instead, {^{for}} and similar do specific arrayChange binding to the tagCtx.args[0] value, in onAfterLink.\r\n\t\t\t// Note deliberately using this != false, rather than this !== false because of IE<10 bug- see https://github.com/BorisMoore/jsviews/issues/237\r\n\t\t\tpaths = slice.call(arguments),\r\n\t\t\torigRoot = paths[0];\r\n\r\n\t\tif (origRoot + \"\" === origRoot && allowArray) {\r\n\t\t\tinitialNs = origRoot; // The first arg is a namespace, since it is  a string, and this call is not from observeAndBind\r\n\t\t\tpaths.shift();\r\n\t\t\torigRoot = paths[0];\r\n\t\t}\r\n\r\n\t\treturn innerObserve.apply(1, paths);\r\n\t}\r\n\r\n\tfunction $unobserve() {\r\n\t\t[].push.call(arguments, true); // Add true as additional final argument\r\n\t\treturn $observe.apply(this, arguments);\r\n\t}\r\n\r\n\tfunction observe_apply() {\r\n\t\t// $.observe(), but allowing you to include arrays within the arguments - which you want flattened.\r\n\t\tvar args = concat.apply([], arguments); // Flatten the arguments\r\n\t\treturn $observe.apply(args.shift(), args);\r\n\t}\r\n\r\n\t//========================== Initialize ==========================\r\n\r\n\tfunction $observeAll(namespace, cb, filter, unobserve) {\r\n\t\tif (namespace + \"\" !== namespace) {\r\n\t\t\tfilter = cb;\r\n\t\t\tcb = namespace;\r\n\t\t\tnamespace = \"\";\r\n\t\t}\r\n\t\tobserveAll(namespace, this._data, cb, filter, [], \"root\", unobserve);\r\n\t}\r\n\r\n\tfunction $unobserveAll(namespace, cb, filter) {\r\n\t\t$observeAll.call(this, namespace, cb, filter, true);\r\n\t}\r\n\r\n\tfunction observeAll(namespace, object, cb, filter, parentObs, allPath, unobserve) {\r\n\t\tfunction observeArray(arr, unobs) {\r\n\t\t\tl = arr.length;\r\n\t\t\tnewAllPath = allPath + \"[]\";\r\n\t\t\twhile (l--) {\r\n\t\t\t\tfilterAndObserveAll(arr, l, unobs, 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction filterAndObserveAll(obj, prop, unobs, nestedArray) {\r\n\t\t\tvar newObject, newParentObs;\r\n\t\t\tif (prop !== $expando) {\r\n\t\t\t\tif (newObject = $observable._fltr(newAllPath, obj[prop], nextParentObs, filter)) {\r\n\t\t\t\t\tnewParentObs = nextParentObs.slice();\r\n\t\t\t\t\tif (nestedArray && updatedTgt) {\r\n\t\t\t\t\t\tnewParentObs.unshift(updatedTgt); // For array change events need to add updated array to parentObs\r\n\t\t\t\t\t}\r\n\t\t\t\t\tobserveAll(namespace, newObject, cb, filter || (nestedArray ? undefined : 0), newParentObs, newAllPath, unobs); // If nested array, need to observe the array too - so set filter to undefined\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction wrappedCb(ev, eventArgs) {\r\n\t\t\t// This object is changing.\r\n\t\t\tallPath = ev.data.observeAll._path;\r\n\t\t\tupdatedTgt = ev.target;\r\n\t\t\tswitch (eventArgs.change) { // observeAll/unobserveAll on added or removed objects\r\n\t\t\t\tcase \"insert\":\r\n\t\t\t\t\tobserveArray(eventArgs.items);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"remove\":\r\n\t\t\t\t\tobserveArray(eventArgs.items, true); // unobserveAll on removed items\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"refresh\":\r\n\t\t\t\t\tobserveArray(eventArgs.oldItems, true); // unobserveAll on old items\r\n\t\t\t\t\tobserveArray(ev.target); // observeAll on new items\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"set\":\r\n\t\t\t\t\tnewAllPath = allPath + \".\" + eventArgs.path;\r\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"oldValue\", true);\r\n\t\t\t\t\tfilterAndObserveAll(eventArgs, \"value\");\r\n\t\t\t}\r\n\t\t\tupdatedTgt = undefined;\r\n\t\t\tcb.apply(this, arguments); // Observe this object (invoke the callback)\r\n\t\t}\r\n\r\n\t\tvar l, isObject, newAllPath, nextParentObs, updatedTgt;\r\n\r\n\t\tif (typeof object === OBJECT) {\r\n\t\t\tnextParentObs = [object].concat(parentObs); // The parentObs chain for the next depth of observeAll\r\n\t\t\tisObject = $isArray(object) ? \"\" : \"*\";\r\n\t\t\tif (cb) {\r\n\t\t\t\t// Observe this object or array - and also listen for changes to object graph, to add or remove observers from the modified object graph\r\n\t\t\t\tif (isObject || filter !== 0) {\r\n\t\t\t\t\t// If an object, observe the object. If an array, only add arrayChange binding if has filter or if filter is undefined (!== 0) - which\r\n\t\t\t\t\t// is the case for top-level calls or for nested array (array item of an array - e.g. member of 2-dimensional array).\r\n\t\t\t\t\t// For array properties lower in the tree, with no filter, filter is set to 0 in filterAndObserveAll, so no arrayChange binding here,\r\n\t\t\t\t\t// since they get arrayChange binding added during regular $.observe(array ...) binding.\r\n\t\t\t\t\twrappedCb._cId = getCbKey(cb); // Identify wrapped callback with unwrapped callback, so unobserveAll will\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // remove previous observeAll wrapped callback, if inner callback was the same;\r\n\t\t\t\t\t$observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// No callback. Just unobserve if unobserve === true.\r\n\t\t\t\t$observe(namespace, object, isObject, undefined, unobserve, filter, nextParentObs, allPath);\r\n\t\t\t}\r\n\r\n\t\t\tif (isObject) {\r\n\t\t\t\t// Continue stepping through object graph, observing object and arrays\r\n\t\t\t\t// To override filtering, pass in filter function, or replace $.observable._fltr\r\n\t\t\t\tfor (l in object) {\r\n\t\t\t\t\tnewAllPath = allPath + \".\" + l;\r\n\t\t\t\t\tfilterAndObserveAll(object, l, unobserve);\r\n\t\t\t\t}\r\n\t\t\t} else { // Array\r\n\t\t\t\tobserveArray(object, unobserve);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t$.observable = $observable;\r\n\t$observable._fltr = function(allPath, object, parentObs, filter) {\r\n\t\tif (filter && $isFunction(filter)\r\n\t\t\t? filter(allPath, object, parentObs)\r\n\t\t\t: true // TODO Consider supporting filter being a string or strings to do RegEx filtering based on key and/or allPath\r\n\t\t) {\r\n\t\t\tobject = $isFunction(object)\r\n\t\t\t\t? object.set && object.call(parentObs[0]) // It is a getter/setter\r\n\t\t\t\t: object;\r\n\t\t\treturn typeof object === OBJECT && object;\r\n\t\t}\r\n\t};\r\n\r\n\t$observable.Object = ObjectObservable;\r\n\t$observable.Array = ArrayObservable;\r\n\t$.observe = $observable.observe = $observe;\r\n\t$.unobserve = $observable.unobserve = $unobserve;\r\n\t$observable._apply = observe_apply;\r\n\r\n\tObjectObservable.prototype = {\r\n\t\t_data: null,\r\n\r\n\t\tobserveAll: $observeAll,\r\n\t\tunobserveAll: $unobserveAll,\r\n\r\n\t\tdata: function() {\r\n\t\t\treturn this._data;\r\n\t\t},\r\n\r\n\t\tsetProperty: function(path, value, nonStrict) {\r\n\t\t\tvar key, pair, parts,\r\n\t\t\t\tself = this,\r\n\t\t\t\tobject = self._data;\r\n\r\n\t\t\tpath = path || \"\";\r\n\t\t\tif (object) {\r\n\t\t\t\tif ($isArray(path)) {\r\n\t\t\t\t\t// This is the array format generated by serializeArray. However, this has the problem that it coerces types to string,\r\n\t\t\t\t\t// and does not provide simple support of convertTo and convertFrom functions.\r\n\t\t\t\t\tkey = path.length;\r\n\t\t\t\t\twhile (key--) {\r\n\t\t\t\t\t\tpair = path[key];\r\n\t\t\t\t\t\tself.setProperty(pair.name, pair.value, nonStrict === undefined || nonStrict); //If nonStrict not specified, default to true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (\"\" + path !== path) {\r\n\t\t\t\t\t// Object representation where property name is path and property value is value.\r\n\t\t\t\t\tfor (key in path) {\r\n\t\t\t\t\t\tself.setProperty(key, path[key], value);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (path !== $expando) {\r\n\t\t\t\t\t// Simple single property case.\r\n\t\t\t\t\tparts = path.split(\".\");\r\n\t\t\t\t\twhile (object && parts.length > 1) {\r\n\t\t\t\t\t\tobject = object[parts.shift()];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (object) {\r\n\t\t\t\t\t\tself._setProperty(object, parts[0], value, nonStrict);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tremoveProperty: function(path) {\r\n\t\t\tthis.setProperty(path, remove);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t_setProperty: function(leaf, path, value, nonStrict) {\r\n\t\t\tvar setter, getter, removeProp,\r\n\t\t\t\tproperty = path ? leaf[path] : leaf;\r\n\r\n\t\t\tif ($isFunction(property)) {\r\n\t\t\t\tif (property.set) {\r\n\t\t\t\t\t// Case of property setter/getter - with convention that property is getter and property.set is setter\r\n\t\t\t\t\tgetter = property;\r\n\t\t\t\t\tsetter = property.set === true ? property : property.set;\r\n\t\t\t\t\tproperty = property.call(leaf); // get - only treated as getter if also a setter. Otherwise it is simply a property of type function. See unit tests 'Can observe properties of type function'.\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (property !== value || nonStrict && property != value) { // Optional non-strict equality, since serializeArray, and form-based editors can map numbers to strings, etc.\r\n\t\t\t\t// Date objects don't support != comparison. Treat as special case.\r\n\t\t\t\tif (!(property instanceof Date) || property > value || property < value) {\r\n\t\t\t\t\tif (setter) {\r\n\t\t\t\t\t\tsetter.call(leaf, value);\t//set\r\n\t\t\t\t\t\tvalue = getter.call(leaf);\t//get updated value\r\n\t\t\t\t\t} else if (removeProp = value === remove) {\r\n\t\t\t\t\t\tdelete leaf[path];\r\n\t\t\t\t\t\tvalue = undefined;\r\n\t\t\t\t\t} else if (path) {\r\n\t\t\t\t\t\tleaf[path] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._trigger(leaf, {change: \"set\", path: path, value: value, oldValue: property, remove: removeProp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_trigger: function(target, eventArgs) {\r\n\t\t\t$(target).triggerHandler(propertyChangeStr, eventArgs);\r\n\t\t}\r\n\t};\r\n\r\n\tArrayObservable.prototype = {\r\n\t\t_data: null,\r\n\r\n\t\tobserveAll: $observeAll,\r\n\t\tunobserveAll: $unobserveAll,\r\n\r\n\t\tdata: function() {\r\n\t\t\treturn this._data;\r\n\t\t},\r\n\r\n\t\tinsert: function(index, data) {\r\n\t\t\tvar _data = this._data;\r\n\t\t\tif (arguments.length === 1) {\r\n\t\t\t\tdata = index;\r\n\t\t\t\tindex = _data.length;\r\n\t\t\t}\r\n\t\t\tindex = PARSEINT(index);\r\n\t\t\tif (index > -1 && index <= _data.length) {\r\n\t\t\t\tdata = $isArray(data) ? data : [data];\r\n\t\t\t\t// data can be a single item (including a null/undefined value) or an array of items.\r\n\t\t\t\t// Note the provided items are inserted without being cloned, as direct references to the provided objects\r\n\r\n\t\t\t\tif (data.length) {\r\n\t\t\t\t\tthis._insert(index, data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t_insert: function(index, data) {\r\n\t\t\tvar _data = this._data,\r\n\t\t\t\toldLength = _data.length;\r\n\t\t\tsplice.apply(_data, [index, 0].concat(data));\r\n\t\t\tthis._trigger({change: \"insert\", index: index, items: data}, oldLength);\r\n\t\t},\r\n\r\n\t\tremove: function(index, numToRemove) {\r\n\t\t\tvar items,\r\n\t\t\t\t_data = this._data;\r\n\r\n\t\t\tif (index === undefined) {\r\n\t\t\t\tindex = _data.length - 1;\r\n\t\t\t}\r\n\r\n\t\t\tindex = PARSEINT(index);\r\n\t\t\tnumToRemove = numToRemove ? PARSEINT(numToRemove) : numToRemove === 0 ? 0 : 1; // if null or undefined: remove 1\r\n\t\t\tif (numToRemove > -1 && index > -1) {\r\n\t\t\t\titems = _data.slice(index, index + numToRemove);\r\n\t\t\t\tnumToRemove = items.length;\r\n\t\t\t\tif (numToRemove) {\r\n\t\t\t\t\tthis._remove(index, numToRemove, items);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t_remove: function(index, numToRemove, items) {\r\n\t\t\tvar _data = this._data,\r\n\t\t\t\toldLength = _data.length;\r\n\r\n\t\t\t_data.splice(index, numToRemove);\r\n\t\t\tthis._trigger({change: \"remove\", index: index, items: items}, oldLength);\r\n\t\t},\r\n\r\n\t\tmove: function(oldIndex, newIndex, numToMove) {\r\n\t\t\tnumToMove = numToMove ? PARSEINT(numToMove) : numToMove === 0 ? 0 : 1; // if null or undefined: move 1\r\n\t\t\toldIndex = PARSEINT(oldIndex);\r\n\t\t\tnewIndex = PARSEINT(newIndex);\r\n\r\n\t\t\tif (numToMove > 0 && oldIndex > -1 && newIndex > -1 && oldIndex !== newIndex) {\r\n\t\t\t\tvar items = this._data.slice(oldIndex, oldIndex + numToMove);\r\n\t\t\t\tnumToMove = items.length;\r\n\t\t\t\tif (numToMove) {\r\n\t\t\t\t\tthis._move(oldIndex, newIndex, numToMove, items);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t_move: function(oldIndex, newIndex, numToMove, items) {\r\n\t\t\tvar _data = this._data,\r\n\t\t\t\toldLength = _data.length;\r\n\t\t\t_data.splice(oldIndex, numToMove);\r\n\t\t\tsplice.apply(_data, [newIndex, 0].concat(items));\r\n\t\t\tthis._trigger({change: \"move\", oldIndex: oldIndex, index: newIndex, items: items}, oldLength);\r\n\t\t},\r\n\r\n\t\trefresh: function(newItems) {\r\n\t\t\tvar oldItems = this._data.slice();\r\n\t\t\tthis._refresh(oldItems, newItems);\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t_refresh: function(oldItems, newItems) {\r\n\t\t\tvar _data = this._data,\r\n\t\t\t\toldLength = _data.length;\r\n\r\n\t\t\tsplice.apply(_data, [0, _data.length].concat(newItems));\r\n\t\t\tthis._trigger({change: \"refresh\", oldItems: oldItems}, oldLength);\r\n\t\t},\r\n\r\n\t\t_trigger: function(eventArgs, oldLength) {\r\n\t\t\tvar _data = this._data,\r\n\t\t\t\tlength = _data.length,\r\n\t\t\t\t$data = $([_data]);\r\n\r\n\t\t\tif (length !== oldLength) {\r\n\t\t\t\t$data.triggerHandler(propertyChangeStr, {change: \"set\", path: \"length\", value: length, oldValue: oldLength});\r\n\t\t\t}\r\n\t\t\t$data.triggerHandler(arrayChangeStr, eventArgs);\r\n\t\t}\r\n\t};\r\n\r\n\t$eventSpecial[propertyChangeStr] = $eventSpecial[arrayChangeStr] = {\r\n\t\t// Register a jQuery special 'remove' event, to access the data associated with handlers being removed by jQuery.off().\r\n\t\t// We get data.cb._cId from the event handleObj and get the corresponding cbBindings hash from the cbBindingsStore,\r\n\t\t// then remove this object from that bindings hash - if the object does not have any other handlers associated with the same callback.\r\n\t\tremove: function (handleObj) {\r\n\t\t\tvar cbBindings, found, events, l, data,\r\n\t\t\t\tevData = handleObj.data;\r\n\t\t\tif ((evData) && (evData.off = true, evData = evData.cb)) { //Set off = true as marker for disposed event\r\n\t\t\t\t// Get the cb._cId from handleObj.data.cb._cId\r\n\t\t\t\tif (cbBindings = cbBindingsStore[evData._cId]) {\r\n\t\t\t\t\t// There were bindings for this callback. If this was the last one, we'll remove it.\r\n\t\t\t\t\tevents = $._data(this).events[handleObj.type];\r\n\t\t\t\t\tl = events.length;\r\n\t\t\t\t\twhile (l-- && !found) {\r\n\t\t\t\t\t\tfound = (data = events[l].data) && data.cb._cId === evData._cId;\r\n\t\t\t\t\t\t// Found another one with same callback (though may be a different innerCallback)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!found) {\r\n\t\t\t\t\t\t// This was the last handler for this callback and object, so remove the binding entry\r\n\t\t\t\t\t\tdelete cbBindings[$.data(this, \"obId\")];\r\n\t\t\t\t\t\tremoveCbBindings(cbBindings, evData._cId);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tfunction shallowFilter(allPath /*, object, parentObs*/) {\r\n\t\treturn allPath.indexOf(\".\") < 0 && allPath.indexOf(\"[\") < 0;\r\n\t}\r\n\r\n\t$views.map = function(mapDef) {\r\n\t\tfunction Map(source, options, target) {\r\n\t\t\tvar changing,\r\n\t\t\t\tmap = this;\r\n\t\t\tif (this.src) {\r\n\t\t\t\tthis.unmap(); // We are re-mapping a new source\r\n\t\t\t}\r\n\t\t\tif (typeof source === OBJECT) {\r\n\t\t\t\tmap.src = source;\r\n\t\t\t\tmap.tgt = target || map.tgt || [];\r\n\t\t\t\tmap.options = options || map.options;\r\n\t\t\t\tmap.update();\r\n\r\n\t\t\t\tif (mapDef.obsSrc) {\r\n\t\t\t\t\t$observable(map.src).observeAll(map.obs = function(ev, eventArgs) {\r\n\t\t\t\t\t\tif (!changing) {\r\n\t\t\t\t\t\t\tchanging = true;\r\n\t\t\t\t\t\t\tmapDef.obsSrc(map, ev, eventArgs);\r\n\t\t\t\t\t\t\tchanging = undefined;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, map.srcFlt);\r\n\t\t\t\t}\r\n\t\t\t\tif (mapDef.obsTgt ) {\r\n\t\t\t\t\t$observable(map.tgt).observeAll(map.obt = function(ev, eventArgs) {\r\n\t\t\t\t\tif (!changing) {\r\n\t\t\t\t\t\tchanging = true;\r\n\t\t\t\t\t\tmapDef.obsTgt(map, ev, eventArgs);\r\n\t\t\t\t\t\tchanging = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}, map.tgtFlt);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ($isFunction(mapDef)) {\r\n\t\t\t// Simple map declared as function\r\n\t\t\tmapDef = {\r\n\t\t\t\tgetTgt: mapDef\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (mapDef.baseMap) {\r\n\t\t\tmapDef = $.extend({}, mapDef.baseMap, mapDef);\r\n\t\t}\r\n\r\n\t\tmapDef.map = function(source, options, target) {\r\n\t\t\treturn new Map(source, options, target);\r\n\t\t};\r\n\r\n\t\t(Map.prototype = {\r\n\t\t\tsrcFlt: mapDef.srcFlt || shallowFilter, // default to shallowFilter\r\n\t\t\ttgtFlt: mapDef.tgtFlt || shallowFilter,\r\n\t\t\tupdate: function(options) {\r\n\t\t\t\tvar map = this;\r\n\t\t\t\t$observable(map.tgt).refresh(mapDef.getTgt(map.src, map.options = options || map.options));\r\n\t\t\t},\r\n\t\t\tunmap: function() {\r\n\t\t\t\tvar map = this;\r\n\t\t\t\tif (map.src) {\r\n\t\t\t\t\tif (map.obs) {\r\n\t\t\t\t\t\t$observable(map.src).unobserveAll(map.obs, map.srcFlt);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (map.obt) {\r\n\t\t\t\t\t\t$observable(map.tgt).unobserveAll(map.obt, map.tgtFlt);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmap.src = undefined;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tmap: Map,\r\n\t\t\t_def: mapDef\r\n\t\t}).constructor = Map;\r\n\r\n\t\treturn mapDef;\r\n\t};\r\n\r\n\r\n\treturn $;\r\n}));\r\n"],"sourceRoot":"/source/"}